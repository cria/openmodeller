/* omStub.h
   Generated by gSOAP 2.8.15 from openModeller.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef omStub_H
#define omStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_om	"http://openmodeller.cria.org.br/xml/2.0"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace om {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_om_om__ThresholdCalculationType
#define SOAP_TYPE_om_om__ThresholdCalculationType (62)
/* om:ThresholdCalculationType */
enum om__ThresholdCalculationType { om__ThresholdCalculationType__lpt = 0 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_om_xsd__anyType
#define SOAP_TYPE_om_xsd__anyType (9)
typedef struct soap_dom_element xsd__anyType;
#endif
#ifndef SOAP_TYPE_om_xsd__anyAttribute
#define SOAP_TYPE_om_xsd__anyAttribute (11)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif





#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_om_om__AvailableAlgorithmsType
#define SOAP_TYPE_om_om__AvailableAlgorithmsType (17)
/* om:AvailableAlgorithmsType */
class SOAP_CMAC om__AvailableAlgorithmsType
{
public:
	class om__AlgorithmsMetadataType *Algorithms;	/* required element of type om:AlgorithmsMetadataType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_om_om__AvailableAlgorithmsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AvailableAlgorithmsType() { om__AvailableAlgorithmsType::soap_default(NULL); }
	virtual ~om__AvailableAlgorithmsType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__AlgorithmsMetadataType
#define SOAP_TYPE_om_om__AlgorithmsMetadataType (18)
/* om:AlgorithmsMetadataType */
class SOAP_CMAC om__AlgorithmsMetadataType
{
public:
	std::vector<class om__AlgorithmMetadataType * >Algorithm;	/* optional element of type om:AlgorithmMetadataType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_om_om__AlgorithmsMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AlgorithmsMetadataType() { om__AlgorithmsMetadataType::soap_default(NULL); }
	virtual ~om__AlgorithmsMetadataType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer (68)
/* om:AlgorithmMetadataType-Designers-Designer */
class SOAP_CMAC _om__AlgorithmMetadataType_Designers_Designer
{
public:
	std::string Name;	/* required attribute */
	std::string *Contact;	/* optional attribute */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Designers_Designer() { _om__AlgorithmMetadataType_Designers_Designer::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Designers_Designer() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Designers
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Designers (67)
/* om:AlgorithmMetadataType-Designers */
class SOAP_CMAC _om__AlgorithmMetadataType_Designers
{
public:
	std::vector<_om__AlgorithmMetadataType_Designers_Designer >Designer;	/* required element of type om:AlgorithmMetadataType-Designers-Designer */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Designers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Designers() { _om__AlgorithmMetadataType_Designers::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Designers() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer (72)
/* om:AlgorithmMetadataType-Developers-Developer */
class SOAP_CMAC _om__AlgorithmMetadataType_Developers_Developer
{
public:
	std::string Name;	/* required attribute */
	std::string *Contact;	/* optional attribute */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Developers_Developer() { _om__AlgorithmMetadataType_Developers_Developer::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Developers_Developer() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Developers
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Developers (71)
/* om:AlgorithmMetadataType-Developers */
class SOAP_CMAC _om__AlgorithmMetadataType_Developers
{
public:
	std::vector<_om__AlgorithmMetadataType_Developers_Developer >Developer;	/* required element of type om:AlgorithmMetadataType-Developers-Developer */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Developers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Developers() { _om__AlgorithmMetadataType_Developers::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Developers() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange (77)
/* om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange
{
public:
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange() { _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues (80)
/* om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues
{
public:
	std::vector<std::string >Value;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues() { _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter (76)
/* om:AlgorithmMetadataType-Parameters-Parameter */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string Type;	/* required element of type xsd:string */
	std::string Overview;	/* required element of type xsd:string */
	std::string Description;	/* required element of type xsd:string */
	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *AcceptedRange;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange */
	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *AcceptedValues;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues */
	std::string *Default;	/* optional element of type xsd:string */
	std::string Id;	/* required attribute */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter() { _om__AlgorithmMetadataType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters
#define SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters (75)
/* om:AlgorithmMetadataType-Parameters */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters
{
public:
	std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*Parameter;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters() { _om__AlgorithmMetadataType_Parameters::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE_om_om__AlgorithmMetadataType
#define SOAP_TYPE_om_om__AlgorithmMetadataType (19)
/* om:AlgorithmMetadataType */
class SOAP_CMAC om__AlgorithmMetadataType
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string Overview;	/* required element of type xsd:string */
	std::string Description;	/* required element of type xsd:string */
	_om__AlgorithmMetadataType_Designers Designers;	/* required element of type om:AlgorithmMetadataType-Designers */
	std::string *Bibliography;	/* optional element of type xsd:string */
	_om__AlgorithmMetadataType_Developers Developers;	/* required element of type om:AlgorithmMetadataType-Developers */
	bool AcceptsCategoricalMaps;	/* required element of type xsd:boolean */
	bool RequiresAbsencePoints;	/* required element of type xsd:boolean */
	_om__AlgorithmMetadataType_Parameters Parameters;	/* required element of type om:AlgorithmMetadataType-Parameters */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_om_om__AlgorithmMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AlgorithmMetadataType() { om__AlgorithmMetadataType::soap_default(NULL); }
	virtual ~om__AlgorithmMetadataType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter
#define SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter (86)
/* om:BasicAlgorithmDefinitionType-Parameters-Parameter */
class SOAP_CMAC _om__BasicAlgorithmDefinitionType_Parameters_Parameter
{
public:
	std::string Id;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__BasicAlgorithmDefinitionType_Parameters_Parameter() { _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__BasicAlgorithmDefinitionType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters
#define SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters (85)
/* om:BasicAlgorithmDefinitionType-Parameters */
class SOAP_CMAC _om__BasicAlgorithmDefinitionType_Parameters
{
public:
	std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*Parameter;	/* optional element of type om:BasicAlgorithmDefinitionType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__BasicAlgorithmDefinitionType_Parameters() { _om__BasicAlgorithmDefinitionType_Parameters::soap_default(NULL); }
	virtual ~_om__BasicAlgorithmDefinitionType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE_om_om__BasicAlgorithmDefinitionType
#define SOAP_TYPE_om_om__BasicAlgorithmDefinitionType (20)
/* om:BasicAlgorithmDefinitionType */
class SOAP_CMAC om__BasicAlgorithmDefinitionType
{
public:
	_om__BasicAlgorithmDefinitionType_Parameters Parameters;	/* required element of type om:BasicAlgorithmDefinitionType-Parameters */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_om_om__BasicAlgorithmDefinitionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__BasicAlgorithmDefinitionType() { om__BasicAlgorithmDefinitionType::soap_default(NULL); }
	virtual ~om__BasicAlgorithmDefinitionType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter
#define SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter (90)
/* om:SerializedAlgorithmType-Parameters-Parameter */
class SOAP_CMAC _om__SerializedAlgorithmType_Parameters_Parameter
{
public:
	std::string Id;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Parameters_Parameter() { _om__SerializedAlgorithmType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters
#define SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters (89)
/* om:SerializedAlgorithmType-Parameters */
class SOAP_CMAC _om__SerializedAlgorithmType_Parameters
{
public:
	std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*Parameter;	/* optional element of type om:SerializedAlgorithmType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Parameters() { _om__SerializedAlgorithmType_Parameters::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE_om__om__SerializedAlgorithmType_Model
#define SOAP_TYPE_om__om__SerializedAlgorithmType_Model (94)
/* om:SerializedAlgorithmType-Model */
class SOAP_CMAC _om__SerializedAlgorithmType_Model
{
public:
	struct soap_dom_element __any;	/* external */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_om__om__SerializedAlgorithmType_Model */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Model() { _om__SerializedAlgorithmType_Model::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Model() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SerializedAlgorithmType
#define SOAP_TYPE_om_om__SerializedAlgorithmType (21)
/* om:SerializedAlgorithmType */
class SOAP_CMAC om__SerializedAlgorithmType
{
public:
	_om__SerializedAlgorithmType_Parameters Parameters;	/* required element of type om:SerializedAlgorithmType-Parameters */
	class om__NormalizationType *Normalization;	/* optional element of type om:NormalizationType */
	_om__SerializedAlgorithmType_Model Model;	/* required element of type om:SerializedAlgorithmType-Model */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_om_om__SerializedAlgorithmType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SerializedAlgorithmType() { om__SerializedAlgorithmType::soap_default(NULL); }
	virtual ~om__SerializedAlgorithmType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__AvailableLayersType
#define SOAP_TYPE_om_om__AvailableLayersType (22)
/* om:AvailableLayersType */
class SOAP_CMAC om__AvailableLayersType
{
public:
	class om__LayersGroupType *LayersGroup;	/* required element of type om:LayersGroupType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_om_om__AvailableLayersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AvailableLayersType() { om__AvailableLayersType::soap_default(NULL); }
	virtual ~om__AvailableLayersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__BasicLayerType
#define SOAP_TYPE_om_om__BasicLayerType (23)
/* om:BasicLayerType */
class SOAP_CMAC om__BasicLayerType
{
public:
	std::string Id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_om_om__BasicLayerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__BasicLayerType() { om__BasicLayerType::soap_default(NULL); }
	virtual ~om__BasicLayerType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__LayersGroupType
#define SOAP_TYPE_om_om__LayersGroupType (26)
/* om:LayersGroupType */
class SOAP_CMAC om__LayersGroupType
{
public:
	std::string Label;	/* required element of type xsd:string */
	std::vector<om__LayersGroupType * >LayersGroup;	/* optional element of type om:LayersGroupType */
	std::vector<class om__LayerMetadataType * >Layer;	/* optional element of type om:LayerMetadataType */
	std::string Id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_om_om__LayersGroupType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__LayersGroupType() { om__LayersGroupType::soap_default(NULL); }
	virtual ~om__LayersGroupType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__EnvironmentType
#define SOAP_TYPE_om_om__EnvironmentType (27)
/* om:EnvironmentType */
class SOAP_CMAC om__EnvironmentType
{
public:
	std::vector<class om__ModellingLayerType * >Map;	/* required element of type om:ModellingLayerType */
	om__BasicLayerType *Mask;	/* required element of type om:BasicLayerType */
	int *NumLayers;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_om_om__EnvironmentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__EnvironmentType() { om__EnvironmentType::soap_default(NULL); }
	virtual ~om__EnvironmentType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__OccurrencesType_Point
#define SOAP_TYPE_om__om__OccurrencesType_Point (103)
/* om:OccurrencesType-Point */
class SOAP_CMAC _om__OccurrencesType_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_om__om__OccurrencesType_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesType_Point() { _om__OccurrencesType_Point::soap_default(NULL); }
	virtual ~_om__OccurrencesType_Point() { }
};
#endif

#ifndef SOAP_TYPE_om_om__OccurrencesType
#define SOAP_TYPE_om_om__OccurrencesType (28)
/* om:OccurrencesType */
class SOAP_CMAC om__OccurrencesType
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__OccurrencesType_Point >Point;	/* required element of type om:OccurrencesType-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_om_om__OccurrencesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__OccurrencesType() { om__OccurrencesType::soap_default(NULL); }
	virtual ~om__OccurrencesType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SamplerType
#define SOAP_TYPE_om_om__SamplerType (29)
/* om:SamplerType */
class SOAP_CMAC om__SamplerType
{
public:
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__OccurrencesType *Presence;	/* optional element of type om:OccurrencesType */
	om__OccurrencesType *Absence;	/* optional element of type om:OccurrencesType */
	om__OccurrencesType *Absence_;	/* optional element of type om:OccurrencesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_om_om__SamplerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplerType() { om__SamplerType::soap_default(NULL); }
	virtual ~om__SamplerType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__NormalizationType
#define SOAP_TYPE_om_om__NormalizationType (30)
/* om:NormalizationType */
class SOAP_CMAC om__NormalizationType
{
public:
	std::string *Class;	/* optional attribute */
	bool *UseLayerAsRef;	/* optional attribute */
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
	std::string *Scales;	/* optional attribute */
	std::string *Offsets;	/* optional attribute */
	std::string *Mean;	/* optional attribute */
	std::string *StdDev;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_om_om__NormalizationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__NormalizationType() { om__NormalizationType::soap_default(NULL); }
	virtual ~om__NormalizationType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix
#define SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix (108)
/* om:TestOptionsType-ConfusionMatrix */
class SOAP_CMAC _om__TestOptionsType_ConfusionMatrix
{
public:
	std::string *Threshold;	/* optional attribute */
	bool *IgnoreAbsences;	/* optional attribute */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestOptionsType_ConfusionMatrix() { _om__TestOptionsType_ConfusionMatrix::soap_default(NULL); }
	virtual ~_om__TestOptionsType_ConfusionMatrix() { }
};
#endif

#ifndef SOAP_TYPE_om__om__TestOptionsType_RocCurve
#define SOAP_TYPE_om__om__TestOptionsType_RocCurve (111)
/* om:TestOptionsType-RocCurve */
class SOAP_CMAC _om__TestOptionsType_RocCurve
{
public:
	int *Resolution;	/* optional attribute */
	int *BackgroundPoints;	/* optional attribute */
	double *MaxOmission;	/* optional attribute */
	bool *UseAbsencesAsBackground;	/* optional attribute */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_om__om__TestOptionsType_RocCurve */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestOptionsType_RocCurve() { _om__TestOptionsType_RocCurve::soap_default(NULL); }
	virtual ~_om__TestOptionsType_RocCurve() { }
};
#endif

#ifndef SOAP_TYPE_om_om__TestOptionsType
#define SOAP_TYPE_om_om__TestOptionsType (31)
/* om:TestOptionsType */
class SOAP_CMAC om__TestOptionsType
{
public:
	_om__TestOptionsType_ConfusionMatrix *ConfusionMatrix;	/* optional element of type om:TestOptionsType-ConfusionMatrix */
	_om__TestOptionsType_RocCurve *RocCurve;	/* optional element of type om:TestOptionsType-RocCurve */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_om_om__TestOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestOptionsType() { om__TestOptionsType::soap_default(NULL); }
	virtual ~om__TestOptionsType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__TestResultType_ConfusionMatrix
#define SOAP_TYPE_om__om__TestResultType_ConfusionMatrix (114)
/* om:TestResultType-ConfusionMatrix */
class SOAP_CMAC _om__TestResultType_ConfusionMatrix
{
public:
	double Threshold;	/* required attribute */
	double Accuracy;	/* required attribute */
	double OmissionError;	/* required attribute */
	double CommissionError;	/* required attribute */
	int TruePositives;	/* required attribute */
	int FalsePositives;	/* required attribute */
	int TrueNegatives;	/* required attribute */
	int FalseNegatives;	/* required attribute */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_om__om__TestResultType_ConfusionMatrix */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestResultType_ConfusionMatrix() { _om__TestResultType_ConfusionMatrix::soap_default(NULL); }
	virtual ~_om__TestResultType_ConfusionMatrix() { }
};
#endif

#ifndef SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio
#define SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio (117)
/* om:TestResultType-RocCurve-Ratio */
class SOAP_CMAC _om__TestResultType_RocCurve_Ratio
{
public:
	double E;	/* required attribute */
	double Value;	/* required attribute */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestResultType_RocCurve_Ratio() { _om__TestResultType_RocCurve_Ratio::soap_default(NULL); }
	virtual ~_om__TestResultType_RocCurve_Ratio() { }
};
#endif

#ifndef SOAP_TYPE_om__om__TestResultType_RocCurve
#define SOAP_TYPE_om__om__TestResultType_RocCurve (116)
/* om:TestResultType-RocCurve */
class SOAP_CMAC _om__TestResultType_RocCurve
{
public:
	_om__TestResultType_RocCurve_Ratio *Ratio;	/* optional element of type om:TestResultType-RocCurve-Ratio */
	double Auc;	/* required attribute */
	std::string Points;	/* required attribute */
	int *NumBackgroundPoints;	/* optional attribute */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_om__om__TestResultType_RocCurve */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestResultType_RocCurve() { _om__TestResultType_RocCurve::soap_default(NULL); }
	virtual ~_om__TestResultType_RocCurve() { }
};
#endif

#ifndef SOAP_TYPE_om_om__TestResultType
#define SOAP_TYPE_om_om__TestResultType (32)
/* om:TestResultType */
class SOAP_CMAC om__TestResultType
{
public:
	_om__TestResultType_ConfusionMatrix *ConfusionMatrix;	/* optional element of type om:TestResultType-ConfusionMatrix */
	_om__TestResultType_RocCurve *RocCurve;	/* optional element of type om:TestResultType-RocCurve */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_om_om__TestResultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestResultType() { om__TestResultType::soap_default(NULL); }
	virtual ~om__TestResultType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics
#define SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics (120)
/* om:ProjectionStatisticsParametersType-AreaStatistics */
class SOAP_CMAC _om__ProjectionStatisticsParametersType_AreaStatistics
{
public:
	std::string PredictionThreshold;	/* required attribute */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ProjectionStatisticsParametersType_AreaStatistics() { _om__ProjectionStatisticsParametersType_AreaStatistics::soap_default(NULL); }
	virtual ~_om__ProjectionStatisticsParametersType_AreaStatistics() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ProjectionStatisticsParametersType
#define SOAP_TYPE_om_om__ProjectionStatisticsParametersType (33)
/* om:ProjectionStatisticsParametersType */
class SOAP_CMAC om__ProjectionStatisticsParametersType
{
public:
	_om__ProjectionStatisticsParametersType_AreaStatistics *AreaStatistics;	/* optional element of type om:ProjectionStatisticsParametersType-AreaStatistics */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_om_om__ProjectionStatisticsParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionStatisticsParametersType() { om__ProjectionStatisticsParametersType::soap_default(NULL); }
	virtual ~om__ProjectionStatisticsParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ProjectionEnvelopeType
#define SOAP_TYPE_om_om__ProjectionEnvelopeType (34)
/* om:ProjectionEnvelopeType */
class SOAP_CMAC om__ProjectionEnvelopeType
{
public:
	class om__AreaStatisticsType *AreaStatistics;	/* required element of type om:AreaStatisticsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_om_om__ProjectionEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionEnvelopeType() { om__ProjectionEnvelopeType::soap_default(NULL); }
	virtual ~om__ProjectionEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__AreaStatisticsType
#define SOAP_TYPE_om_om__AreaStatisticsType (35)
/* om:AreaStatisticsType */
class SOAP_CMAC om__AreaStatisticsType
{
public:
	int TotalCells;	/* required attribute */
	int CellsPredicted;	/* required attribute */
	double PredictionThreshold;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_om_om__AreaStatisticsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AreaStatisticsType() { om__AreaStatisticsType::soap_default(NULL); }
	virtual ~om__AreaStatisticsType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__MapOutputParametersType
#define SOAP_TYPE_om_om__MapOutputParametersType (36)
/* om:MapOutputParametersType */
class SOAP_CMAC om__MapOutputParametersType
{
public:
	om__BasicLayerType *TemplateLayer;	/* required element of type om:BasicLayerType */
	std::string *FileType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_om_om__MapOutputParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__MapOutputParametersType() { om__MapOutputParametersType::soap_default(NULL); }
	virtual ~om__MapOutputParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModelParametersType
#define SOAP_TYPE_om_om__ModelParametersType (37)
/* om:ModelParametersType */
class SOAP_CMAC om__ModelParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__BasicAlgorithmDefinitionType *Algorithm;	/* required element of type om:BasicAlgorithmDefinitionType */
	class om__ModelOptionsType *Options;	/* optional element of type om:ModelOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_om_om__ModelParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelParametersType() { om__ModelParametersType::soap_default(NULL); }
	virtual ~om__ModelParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique
#define SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique (126)
/* om:OccurrencesFilterType-SpatiallyUnique */
class SOAP_CMAC _om__OccurrencesFilterType_SpatiallyUnique
{
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesFilterType_SpatiallyUnique() { _om__OccurrencesFilterType_SpatiallyUnique::soap_default(NULL); }
	virtual ~_om__OccurrencesFilterType_SpatiallyUnique() { }
};
#endif

#ifndef SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique
#define SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique (128)
/* om:OccurrencesFilterType-EnvironmentallyUnique */
class SOAP_CMAC _om__OccurrencesFilterType_EnvironmentallyUnique
{
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesFilterType_EnvironmentallyUnique() { _om__OccurrencesFilterType_EnvironmentallyUnique::soap_default(NULL); }
	virtual ~_om__OccurrencesFilterType_EnvironmentallyUnique() { }
};
#endif

#ifndef SOAP_TYPE_om__om__union_OccurrencesFilterType
#define SOAP_TYPE_om__om__union_OccurrencesFilterType (130)
/* xsd:choice */
union _om__union_OccurrencesFilterType
{
#define SOAP_UNION__om__union_OccurrencesFilterType_SpatiallyUnique	(1)
	_om__OccurrencesFilterType_SpatiallyUnique *SpatiallyUnique;
#define SOAP_UNION__om__union_OccurrencesFilterType_EnvironmentallyUnique	(2)
	_om__OccurrencesFilterType_EnvironmentallyUnique *EnvironmentallyUnique;
};
#endif

#ifndef SOAP_TYPE_om_om__OccurrencesFilterType
#define SOAP_TYPE_om_om__OccurrencesFilterType (38)
/* Choice: */
class SOAP_CMAC om__OccurrencesFilterType
{
public:
	int __union_OccurrencesFilterType;	/* union discriminant (of union defined below) */
	union _om__union_OccurrencesFilterType union_OccurrencesFilterType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_om_om__OccurrencesFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__OccurrencesFilterType() { om__OccurrencesFilterType::soap_default(NULL); }
	virtual ~om__OccurrencesFilterType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModelOptionsType
#define SOAP_TYPE_om_om__ModelOptionsType (39)
/* om:ModelOptionsType */
class SOAP_CMAC om__ModelOptionsType
{
public:
	om__OccurrencesFilterType *OccurrencesFilter;	/* optional element of type om:OccurrencesFilterType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_om_om__ModelOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelOptionsType() { om__ModelOptionsType::soap_default(NULL); }
	virtual ~om__ModelOptionsType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModelEnvelopeType
#define SOAP_TYPE_om_om__ModelEnvelopeType (40)
/* om:ModelEnvelopeType */
class SOAP_CMAC om__ModelEnvelopeType
{
public:
	class om__SerializedModelType *SerializedModel;	/* required element of type om:SerializedModelType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_om_om__ModelEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEnvelopeType() { om__ModelEnvelopeType::soap_default(NULL); }
	virtual ~om__ModelEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SerializedModelType
#define SOAP_TYPE_om_om__SerializedModelType (41)
/* om:SerializedModelType */
class SOAP_CMAC om__SerializedModelType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__TestResultType *Statistics;	/* optional element of type om:TestResultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_om_om__SerializedModelType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SerializedModelType() { om__SerializedModelType::soap_default(NULL); }
	virtual ~om__SerializedModelType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__TestParametersType
#define SOAP_TYPE_om_om__TestParametersType (42)
/* om:TestParametersType */
class SOAP_CMAC om__TestParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__TestOptionsType *Statistics;	/* optional element of type om:TestOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_om_om__TestParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestParametersType() { om__TestParametersType::soap_default(NULL); }
	virtual ~om__TestParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__TestResultEnvelopeType
#define SOAP_TYPE_om_om__TestResultEnvelopeType (43)
/* om:TestResultEnvelopeType */
class SOAP_CMAC om__TestResultEnvelopeType
{
public:
	om__TestResultType *Statistics;	/* optional element of type om:TestResultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_om_om__TestResultEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestResultEnvelopeType() { om__TestResultEnvelopeType::soap_default(NULL); }
	virtual ~om__TestResultEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ProjectionParametersType
#define SOAP_TYPE_om_om__ProjectionParametersType (44)
/* om:ProjectionParametersType */
class SOAP_CMAC om__ProjectionParametersType
{
public:
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__MapOutputParametersType *OutputParameters;	/* optional element of type om:MapOutputParametersType */
	om__ProjectionStatisticsParametersType *Statistics;	/* optional element of type om:ProjectionStatisticsParametersType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_om_om__ProjectionParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionParametersType() { om__ProjectionParametersType::soap_default(NULL); }
	virtual ~om__ProjectionParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModelEvaluationParametersType
#define SOAP_TYPE_om_om__ModelEvaluationParametersType (45)
/* om:ModelEvaluationParametersType */
class SOAP_CMAC om__ModelEvaluationParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_om_om__ModelEvaluationParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEvaluationParametersType() { om__ModelEvaluationParametersType::soap_default(NULL); }
	virtual ~om__ModelEvaluationParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ModelEvaluationResultType_Values
#define SOAP_TYPE_om__om__ModelEvaluationResultType_Values (138)
/* om:ModelEvaluationResultType-Values */
class SOAP_CMAC _om__ModelEvaluationResultType_Values
{
public:
	std::string V;	/* required attribute */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE_om__om__ModelEvaluationResultType_Values */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ModelEvaluationResultType_Values() { _om__ModelEvaluationResultType_Values::soap_default(NULL); }
	virtual ~_om__ModelEvaluationResultType_Values() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModelEvaluationResultType
#define SOAP_TYPE_om_om__ModelEvaluationResultType (46)
/* om:ModelEvaluationResultType */
class SOAP_CMAC om__ModelEvaluationResultType
{
public:
	_om__ModelEvaluationResultType_Values Values;	/* required element of type om:ModelEvaluationResultType-Values */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_om_om__ModelEvaluationResultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEvaluationResultType() { om__ModelEvaluationResultType::soap_default(NULL); }
	virtual ~om__ModelEvaluationResultType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SamplingOptionsType
#define SOAP_TYPE_om_om__SamplingOptionsType (47)
/* om:SamplingOptionsType */
class SOAP_CMAC om__SamplingOptionsType
{
public:
	om__OccurrencesFilterType *OccurrencesFilter;	/* optional element of type om:OccurrencesFilterType */
	int NumPoints;	/* required attribute */
	std::string *Label;	/* optional attribute */
	double *ProportionOfAbsences;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_om_om__SamplingOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingOptionsType() { om__SamplingOptionsType::soap_default(NULL); }
	virtual ~om__SamplingOptionsType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SamplingParametersType
#define SOAP_TYPE_om_om__SamplingParametersType (48)
/* om:SamplingParametersType */
class SOAP_CMAC om__SamplingParametersType
{
public:
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__SamplingOptionsType *Options;	/* required element of type om:SamplingOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_om_om__SamplingParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingParametersType() { om__SamplingParametersType::soap_default(NULL); }
	virtual ~om__SamplingParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Environment
#define SOAP_TYPE_om__om__ExperimentParametersType_Environment (140)
/* om:ExperimentParametersType-Environment */
class SOAP_CMAC _om__ExperimentParametersType_Environment
{
public:
	std::vector<om__ModellingLayerType * >Map;	/* required element of type om:ModellingLayerType */
	om__BasicLayerType *Mask;	/* required element of type om:BasicLayerType */
	int *NumLayers;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Environment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Environment() { _om__ExperimentParametersType_Environment::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Environment() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point
#define SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point (143)
/* om:ExperimentParametersType-Presence-Point */
class SOAP_CMAC _om__ExperimentParametersType_Presence_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Presence_Point() { _om__ExperimentParametersType_Presence_Point::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Presence_Point() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Presence
#define SOAP_TYPE_om__om__ExperimentParametersType_Presence (142)
/* om:ExperimentParametersType-Presence */
class SOAP_CMAC _om__ExperimentParametersType_Presence
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__ExperimentParametersType_Presence_Point >Point;	/* required element of type om:ExperimentParametersType-Presence-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Presence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Presence() { _om__ExperimentParametersType_Presence::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Presence() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point
#define SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point (148)
/* om:ExperimentParametersType-Absence-Point */
class SOAP_CMAC _om__ExperimentParametersType_Absence_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Absence_Point() { _om__ExperimentParametersType_Absence_Point::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Absence_Point() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Absence
#define SOAP_TYPE_om__om__ExperimentParametersType_Absence (147)
/* om:ExperimentParametersType-Absence */
class SOAP_CMAC _om__ExperimentParametersType_Absence
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__ExperimentParametersType_Absence_Point >Point;	/* required element of type om:ExperimentParametersType-Absence-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Absence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Absence() { _om__ExperimentParametersType_Absence::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Absence() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings
#define SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings (152)
/* om:ExperimentParametersType-AlgorithmSettings */
class SOAP_CMAC _om__ExperimentParametersType_AlgorithmSettings
{
public:
	om__BasicAlgorithmDefinitionType *Algorithm;	/* required element of type om:BasicAlgorithmDefinitionType */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_AlgorithmSettings() { _om__ExperimentParametersType_AlgorithmSettings::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_AlgorithmSettings() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm
#define SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm (155)
/* om:ExperimentParametersType-SerializedAlgorithm */
class SOAP_CMAC _om__ExperimentParametersType_SerializedAlgorithm
{
public:
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_SerializedAlgorithm() { _om__ExperimentParametersType_SerializedAlgorithm::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_SerializedAlgorithm() { }
};
#endif

#ifndef SOAP_TYPE_om__om__union_ExperimentParametersType_Jobs
#define SOAP_TYPE_om__om__union_ExperimentParametersType_Jobs (165)
/* xsd:choice */
union _om__union_ExperimentParametersType_Jobs
{
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_SamplingJob	(1)
	class om__SamplingJobType *SamplingJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_CreateModelJob	(2)
	class om__CreateModelJobType *CreateModelJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_TestModelJob	(3)
	class om__TestModelJobType *TestModelJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_ProjectModelJob	(4)
	class om__ProjectModelJobType *ProjectModelJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_EvaluateModelJob	(5)
	class om__EvaluateModelJobType *EvaluateModelJob;
};
#endif

#ifndef SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs
#define SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs (159)
/* Operation wrapper: */
class SOAP_CMAC __om__union_ExperimentParametersType_Jobs
{
public:
	int __unionAbstractJob;	/* union discriminant (of union defined below) */
	union _om__union_ExperimentParametersType_Jobs __union_ExperimentParametersType_Jobs;
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __om__union_ExperimentParametersType_Jobs() { __om__union_ExperimentParametersType_Jobs::soap_default(NULL); }
	virtual ~__om__union_ExperimentParametersType_Jobs() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParametersType_Jobs
#define SOAP_TYPE_om__om__ExperimentParametersType_Jobs (158)
/* om:ExperimentParametersType-Jobs */
class SOAP_CMAC _om__ExperimentParametersType_Jobs
{
public:
	int __sizeAbstractJob;	/* sequence of elements <-union-ExperimentParametersType-Jobs> */
	__om__union_ExperimentParametersType_Jobs *__union_ExperimentParametersType_Jobs;
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE_om__om__ExperimentParametersType_Jobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Jobs() { _om__ExperimentParametersType_Jobs::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Jobs() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ExperimentParametersType
#define SOAP_TYPE_om_om__ExperimentParametersType (49)
/* om:ExperimentParametersType */
class SOAP_CMAC om__ExperimentParametersType
{
public:
	std::vector<_om__ExperimentParametersType_Environment >Environment;	/* required element of type om:ExperimentParametersType-Environment */
	std::vector<_om__ExperimentParametersType_Presence >*Presence;	/* optional element of type om:ExperimentParametersType-Presence */
	std::vector<_om__ExperimentParametersType_Absence >*Absence;	/* optional element of type om:ExperimentParametersType-Absence */
	std::vector<_om__ExperimentParametersType_AlgorithmSettings >*AlgorithmSettings;	/* optional element of type om:ExperimentParametersType-AlgorithmSettings */
	std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*SerializedAlgorithm;	/* optional element of type om:ExperimentParametersType-SerializedAlgorithm */
	_om__ExperimentParametersType_Jobs Jobs;	/* required element of type om:ExperimentParametersType-Jobs */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_om_om__ExperimentParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ExperimentParametersType() { om__ExperimentParametersType::soap_default(NULL); }
	virtual ~om__ExperimentParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ReferenceType
#define SOAP_TYPE_om_om__ReferenceType (50)
/* om:ReferenceType */
class SOAP_CMAC om__ReferenceType
{
public:
	std::string idref;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_om_om__ReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ReferenceType() { om__ReferenceType::soap_default(NULL); }
	virtual ~om__ReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__IdentifiedType
#define SOAP_TYPE_om_om__IdentifiedType (51)
/* om:IdentifiedType */
class SOAP_CMAC om__IdentifiedType
{
public:
	std::string id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_om_om__IdentifiedType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__IdentifiedType() { om__IdentifiedType::soap_default(NULL); }
	virtual ~om__IdentifiedType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__JobTicketsType_Job
#define SOAP_TYPE_om__om__JobTicketsType_Job (167)
/* om:JobTicketsType-Job */
class SOAP_CMAC _om__JobTicketsType_Job
{
public:
	std::string id;	/* required attribute */
	std::string Ticket;	/* required attribute */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE_om__om__JobTicketsType_Job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__JobTicketsType_Job() { _om__JobTicketsType_Job::soap_default(NULL); }
	virtual ~_om__JobTicketsType_Job() { }
};
#endif

#ifndef SOAP_TYPE_om_om__JobTicketsType
#define SOAP_TYPE_om_om__JobTicketsType (57)
/* om:JobTicketsType */
class SOAP_CMAC om__JobTicketsType
{
public:
	std::vector<_om__JobTicketsType_Job >Job;	/* required element of type om:JobTicketsType-Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_om_om__JobTicketsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__JobTicketsType() { om__JobTicketsType::soap_default(NULL); }
	virtual ~om__JobTicketsType() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope
#define SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope (172)
/* om:ResultSetType-Job-ProjectionEnvelope */
class SOAP_CMAC _om__ResultSetType_Job_ProjectionEnvelope
{
public:
	om__ProjectionEnvelopeType *Statistics;	/* optional element of type om:ProjectionEnvelopeType */
	std::string url;	/* required attribute */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ResultSetType_Job_ProjectionEnvelope() { _om__ResultSetType_Job_ProjectionEnvelope::soap_default(NULL); }
	virtual ~_om__ResultSetType_Job_ProjectionEnvelope() { }
};
#endif

#ifndef SOAP_TYPE_om__om__ResultSetType_Job_Values
#define SOAP_TYPE_om__om__ResultSetType_Job_Values (175)
/* om:ResultSetType-Job-Values */
class SOAP_CMAC _om__ResultSetType_Job_Values
{
public:
	std::string V;	/* required attribute */
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_om__om__ResultSetType_Job_Values */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ResultSetType_Job_Values() { _om__ResultSetType_Job_Values::soap_default(NULL); }
	virtual ~_om__ResultSetType_Job_Values() { }
};
#endif

#ifndef SOAP_TYPE_om__om__union_ResultSetType_Job
#define SOAP_TYPE_om__om__union_ResultSetType_Job (177)
/* xsd:choice */
union _om__union_ResultSetType_Job
{
#define SOAP_UNION__om__union_ResultSetType_Job_Sampler	(1)
	om__SamplerType *Sampler;
#define SOAP_UNION__om__union_ResultSetType_Job_ModelEnvelope	(2)
	om__ModelEnvelopeType *ModelEnvelope;
#define SOAP_UNION__om__union_ResultSetType_Job_TestResultEnvelope	(3)
	om__TestResultEnvelopeType *TestResultEnvelope;
#define SOAP_UNION__om__union_ResultSetType_Job_ProjectionEnvelope	(4)
	_om__ResultSetType_Job_ProjectionEnvelope *ProjectionEnvelope;
#define SOAP_UNION__om__union_ResultSetType_Job_Values	(5)
	_om__ResultSetType_Job_Values *Values;
};
#endif

#ifndef SOAP_TYPE_om__om__ResultSetType_Job
#define SOAP_TYPE_om__om__ResultSetType_Job (169)
/* om:ResultSetType-Job */
class SOAP_CMAC _om__ResultSetType_Job
{
public:
	int __union_ResultSetType_Job;	/* union discriminant (of union defined below) */
	union _om__union_ResultSetType_Job union_ResultSetType_Job;	/* required element of type xsd:choice */
	std::string Ticket;	/* required attribute */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE_om__om__ResultSetType_Job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ResultSetType_Job() { _om__ResultSetType_Job::soap_default(NULL); }
	virtual ~_om__ResultSetType_Job() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ResultSetType
#define SOAP_TYPE_om_om__ResultSetType (58)
/* om:ResultSetType */
class SOAP_CMAC om__ResultSetType
{
public:
	std::vector<_om__ResultSetType_Job >Job;	/* required element of type om:ResultSetType-Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_om_om__ResultSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ResultSetType() { om__ResultSetType::soap_default(NULL); }
	virtual ~om__ResultSetType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ModellingLayerType
#define SOAP_TYPE_om_om__ModellingLayerType (24)
/* om:ModellingLayerType */
class SOAP_CMAC om__ModellingLayerType : public om__BasicLayerType
{
public:
	bool *IsCategorical;	/* optional attribute */
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_om_om__ModellingLayerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModellingLayerType() { om__ModellingLayerType::soap_default(NULL); }
	virtual ~om__ModellingLayerType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__SamplingJobType
#define SOAP_TYPE_om_om__SamplingJobType (52)
/* om:SamplingJobType */
class SOAP_CMAC om__SamplingJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__SamplingOptionsType *Options;	/* required element of type om:SamplingOptionsType */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_om_om__SamplingJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingJobType() { om__SamplingJobType::soap_default(NULL); }
	virtual ~om__SamplingJobType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__CreateModelJobType
#define SOAP_TYPE_om_om__CreateModelJobType (53)
/* om:CreateModelJobType */
class SOAP_CMAC om__CreateModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *PresenceRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *AbsenceRef;	/* optional element of type om:ReferenceType */
	om__ReferenceType *AlgorithmRef;	/* required element of type om:ReferenceType */
	om__ModelOptionsType *Options;	/* optional element of type om:ModelOptionsType */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_om_om__CreateModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__CreateModelJobType() { om__CreateModelJobType::soap_default(NULL); }
	virtual ~om__CreateModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__TestModelJobType
#define SOAP_TYPE_om_om__TestModelJobType (54)
/* om:TestModelJobType */
class SOAP_CMAC om__TestModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *PresenceRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *AbsenceRef;	/* optional element of type om:ReferenceType */
	om__ReferenceType *ModelRef;	/* required element of type om:ReferenceType */
	om__TestOptionsType *Statistics;	/* optional element of type om:TestOptionsType */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_om_om__TestModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestModelJobType() { om__TestModelJobType::soap_default(NULL); }
	virtual ~om__TestModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__ProjectModelJobType
#define SOAP_TYPE_om_om__ProjectModelJobType (55)
/* om:ProjectModelJobType */
class SOAP_CMAC om__ProjectModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *ModelRef;	/* required element of type om:ReferenceType */
	om__MapOutputParametersType *OutputParameters;	/* optional element of type om:MapOutputParametersType */
	om__ProjectionStatisticsParametersType *Statistics;	/* optional element of type om:ProjectionStatisticsParametersType */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_om_om__ProjectModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectModelJobType() { om__ProjectModelJobType::soap_default(NULL); }
	virtual ~om__ProjectModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__EvaluateModelJobType
#define SOAP_TYPE_om_om__EvaluateModelJobType (56)
/* om:EvaluateModelJobType */
class SOAP_CMAC om__EvaluateModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *PresenceRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *AbsenceRef;	/* optional element of type om:ReferenceType */
	om__ReferenceType *ModelRef;	/* required element of type om:ReferenceType */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_om_om__EvaluateModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__EvaluateModelJobType() { om__EvaluateModelJobType::soap_default(NULL); }
	virtual ~om__EvaluateModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om_om__LayerMetadataType
#define SOAP_TYPE_om_om__LayerMetadataType (25)
/* om:LayerMetadataType */
class SOAP_CMAC om__LayerMetadataType : public om__ModellingLayerType
{
public:
	std::string *Label;	/* optional element of type xsd:string */
	bool *HasProjection;	/* optional attribute */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_om_om__LayerMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__LayerMetadataType() { om__LayerMetadataType::soap_default(NULL); }
	virtual ~om__LayerMetadataType() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_om_SOAP_ENV__Header
#define SOAP_TYPE_om_SOAP_ENV__Header (202)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 202; } /* = unique id SOAP_TYPE_om_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_om_SOAP_ENV__Code
#define SOAP_TYPE_om_SOAP_ENV__Code (203)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 203; } /* = unique id SOAP_TYPE_om_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_om_SOAP_ENV__Detail
#define SOAP_TYPE_om_SOAP_ENV__Detail (205)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 205; } /* = unique id SOAP_TYPE_om_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_om_SOAP_ENV__Reason
#define SOAP_TYPE_om_SOAP_ENV__Reason (208)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 208; } /* = unique id SOAP_TYPE_om_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_om_SOAP_ENV__Fault
#define SOAP_TYPE_om_SOAP_ENV__Fault (209)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 209; } /* = unique id SOAP_TYPE_om_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_om__QName
#define SOAP_TYPE_om__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_om__XML
#define SOAP_TYPE_om__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_om_xsd__ID
#define SOAP_TYPE_om_xsd__ID (14)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_om_xsd__IDREF
#define SOAP_TYPE_om_xsd__IDREF (15)
typedef std::string xsd__IDREF;
#endif

#ifndef SOAP_TYPE_om_xsd__anyURI
#define SOAP_TYPE_om_xsd__anyURI (16)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_om_om__ThresholdParameterType
#define SOAP_TYPE_om_om__ThresholdParameterType (59)
typedef std::string om__ThresholdParameterType;
#endif

#ifndef SOAP_TYPE_om_om__ZeroOneIntervalType
#define SOAP_TYPE_om_om__ZeroOneIntervalType (61)
typedef double om__ZeroOneIntervalType;
#endif

#ifndef SOAP_TYPE_om__om__AvailableAlgorithms
#define SOAP_TYPE_om__om__AvailableAlgorithms (180)
typedef om__AvailableAlgorithmsType _om__AvailableAlgorithms;
#endif

#ifndef SOAP_TYPE_om__om__Algorithms
#define SOAP_TYPE_om__om__Algorithms (181)
typedef om__AlgorithmsMetadataType _om__Algorithms;
#endif

#ifndef SOAP_TYPE_om__om__AvailableLayers
#define SOAP_TYPE_om__om__AvailableLayers (182)
typedef om__AvailableLayersType _om__AvailableLayers;
#endif

#ifndef SOAP_TYPE_om__om__ModelParameters
#define SOAP_TYPE_om__om__ModelParameters (183)
typedef om__ModelParametersType _om__ModelParameters;
#endif

#ifndef SOAP_TYPE_om__om__ModelEnvelope
#define SOAP_TYPE_om__om__ModelEnvelope (184)
typedef om__ModelEnvelopeType _om__ModelEnvelope;
#endif

#ifndef SOAP_TYPE_om__om__TestParameters
#define SOAP_TYPE_om__om__TestParameters (185)
typedef om__TestParametersType _om__TestParameters;
#endif

#ifndef SOAP_TYPE_om__om__TestResultEnvelope
#define SOAP_TYPE_om__om__TestResultEnvelope (186)
typedef om__TestResultEnvelopeType _om__TestResultEnvelope;
#endif

#ifndef SOAP_TYPE_om__om__SerializedModel
#define SOAP_TYPE_om__om__SerializedModel (187)
typedef om__SerializedModelType _om__SerializedModel;
#endif

#ifndef SOAP_TYPE_om__om__ProjectionParameters
#define SOAP_TYPE_om__om__ProjectionParameters (188)
typedef om__ProjectionParametersType _om__ProjectionParameters;
#endif

#ifndef SOAP_TYPE_om__om__ProjectionEnvelope
#define SOAP_TYPE_om__om__ProjectionEnvelope (189)
typedef om__ProjectionEnvelopeType _om__ProjectionEnvelope;
#endif

#ifndef SOAP_TYPE_om__om__ModelEvaluationParameters
#define SOAP_TYPE_om__om__ModelEvaluationParameters (190)
typedef om__ModelEvaluationParametersType _om__ModelEvaluationParameters;
#endif

#ifndef SOAP_TYPE_om__om__ModelEvaluation
#define SOAP_TYPE_om__om__ModelEvaluation (191)
typedef om__ModelEvaluationResultType _om__ModelEvaluation;
#endif

#ifndef SOAP_TYPE_om__om__SamplingParameters
#define SOAP_TYPE_om__om__SamplingParameters (192)
typedef om__SamplingParametersType _om__SamplingParameters;
#endif

#ifndef SOAP_TYPE_om__om__Sampler
#define SOAP_TYPE_om__om__Sampler (193)
typedef om__SamplerType _om__Sampler;
#endif

#ifndef SOAP_TYPE_om__om__ExperimentParameters
#define SOAP_TYPE_om__om__ExperimentParameters (194)
typedef om__ExperimentParametersType _om__ExperimentParameters;
#endif

#ifndef SOAP_TYPE_om__om__ExperimentTickets
#define SOAP_TYPE_om__om__ExperimentTickets (195)
typedef om__JobTicketsType _om__ExperimentTickets;
#endif

#ifndef SOAP_TYPE_om__om__ResultSet
#define SOAP_TYPE_om__om__ResultSet (196)
typedef om__ResultSetType _om__ResultSet;
#endif

#ifndef SOAP_TYPE_om__om__SamplingJob
#define SOAP_TYPE_om__om__SamplingJob (197)
typedef om__SamplingJobType _om__SamplingJob;
#endif

#ifndef SOAP_TYPE_om__om__CreateModelJob
#define SOAP_TYPE_om__om__CreateModelJob (198)
typedef om__CreateModelJobType _om__CreateModelJob;
#endif

#ifndef SOAP_TYPE_om__om__TestModelJob
#define SOAP_TYPE_om__om__TestModelJob (199)
typedef om__TestModelJobType _om__TestModelJob;
#endif

#ifndef SOAP_TYPE_om__om__ProjectModelJob
#define SOAP_TYPE_om__om__ProjectModelJob (200)
typedef om__ProjectModelJobType _om__ProjectModelJob;
#endif

#ifndef SOAP_TYPE_om__om__EvaluateModelJob
#define SOAP_TYPE_om__om__EvaluateModelJob (201)
typedef om__EvaluateModelJobType _om__EvaluateModelJob;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace om


#endif

/* End of omStub.h */
