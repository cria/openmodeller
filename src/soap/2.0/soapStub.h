/* soapStub.h
   Generated by gSOAP 2.8.15 from merge.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_om	"http://openmodeller.cria.org.br/xml/2.0"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_om__ThresholdCalculationType
#define SOAP_TYPE_om__ThresholdCalculationType (56)
/* om:ThresholdCalculationType */
enum om__ThresholdCalculationType { om__ThresholdCalculationType__lpt = 0 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_om__AvailableAlgorithmsType
#define SOAP_TYPE_om__AvailableAlgorithmsType (12)
/* om:AvailableAlgorithmsType */
class SOAP_CMAC om__AvailableAlgorithmsType
{
public:
	class om__AlgorithmsMetadataType *Algorithms;	/* required element of type om:AlgorithmsMetadataType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_om__AvailableAlgorithmsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AvailableAlgorithmsType() { om__AvailableAlgorithmsType::soap_default(NULL); }
	virtual ~om__AvailableAlgorithmsType() { }
};
#endif

#ifndef SOAP_TYPE_om__AlgorithmsMetadataType
#define SOAP_TYPE_om__AlgorithmsMetadataType (13)
/* om:AlgorithmsMetadataType */
class SOAP_CMAC om__AlgorithmsMetadataType
{
public:
	std::vector<class om__AlgorithmMetadataType * >Algorithm;	/* optional element of type om:AlgorithmMetadataType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_om__AlgorithmsMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AlgorithmsMetadataType() { om__AlgorithmsMetadataType::soap_default(NULL); }
	virtual ~om__AlgorithmsMetadataType() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Designers_Designer
#define SOAP_TYPE__om__AlgorithmMetadataType_Designers_Designer (62)
/* om:AlgorithmMetadataType-Designers-Designer */
class SOAP_CMAC _om__AlgorithmMetadataType_Designers_Designer
{
public:
	std::string Name;	/* required attribute */
	std::string *Contact;	/* optional attribute */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Designers_Designer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Designers_Designer() { _om__AlgorithmMetadataType_Designers_Designer::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Designers_Designer() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Designers
#define SOAP_TYPE__om__AlgorithmMetadataType_Designers (61)
/* om:AlgorithmMetadataType-Designers */
class SOAP_CMAC _om__AlgorithmMetadataType_Designers
{
public:
	std::vector<_om__AlgorithmMetadataType_Designers_Designer >Designer;	/* required element of type om:AlgorithmMetadataType-Designers-Designer */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Designers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Designers() { _om__AlgorithmMetadataType_Designers::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Designers() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Developers_Developer
#define SOAP_TYPE__om__AlgorithmMetadataType_Developers_Developer (66)
/* om:AlgorithmMetadataType-Developers-Developer */
class SOAP_CMAC _om__AlgorithmMetadataType_Developers_Developer
{
public:
	std::string Name;	/* required attribute */
	std::string *Contact;	/* optional attribute */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Developers_Developer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Developers_Developer() { _om__AlgorithmMetadataType_Developers_Developer::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Developers_Developer() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Developers
#define SOAP_TYPE__om__AlgorithmMetadataType_Developers (65)
/* om:AlgorithmMetadataType-Developers */
class SOAP_CMAC _om__AlgorithmMetadataType_Developers
{
public:
	std::vector<_om__AlgorithmMetadataType_Developers_Developer >Developer;	/* required element of type om:AlgorithmMetadataType-Developers-Developer */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Developers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Developers() { _om__AlgorithmMetadataType_Developers::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Developers() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange
#define SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange (71)
/* om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange
{
public:
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange() { _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues
#define SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues (74)
/* om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues
{
public:
	std::vector<std::string >Value;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues() { _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter
#define SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter (70)
/* om:AlgorithmMetadataType-Parameters-Parameter */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters_Parameter
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string Type;	/* required element of type xsd:string */
	std::string Overview;	/* required element of type xsd:string */
	std::string Description;	/* required element of type xsd:string */
	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *AcceptedRange;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange */
	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *AcceptedValues;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues */
	std::string *Default;	/* optional element of type xsd:string */
	std::string Id;	/* required attribute */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters_Parameter() { _om__AlgorithmMetadataType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE__om__AlgorithmMetadataType_Parameters
#define SOAP_TYPE__om__AlgorithmMetadataType_Parameters (69)
/* om:AlgorithmMetadataType-Parameters */
class SOAP_CMAC _om__AlgorithmMetadataType_Parameters
{
public:
	std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*Parameter;	/* optional element of type om:AlgorithmMetadataType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__om__AlgorithmMetadataType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__AlgorithmMetadataType_Parameters() { _om__AlgorithmMetadataType_Parameters::soap_default(NULL); }
	virtual ~_om__AlgorithmMetadataType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE_om__AlgorithmMetadataType
#define SOAP_TYPE_om__AlgorithmMetadataType (14)
/* om:AlgorithmMetadataType */
class SOAP_CMAC om__AlgorithmMetadataType
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::string Overview;	/* required element of type xsd:string */
	std::string Description;	/* required element of type xsd:string */
	_om__AlgorithmMetadataType_Designers Designers;	/* required element of type om:AlgorithmMetadataType-Designers */
	std::string *Bibliography;	/* optional element of type xsd:string */
	_om__AlgorithmMetadataType_Developers Developers;	/* required element of type om:AlgorithmMetadataType-Developers */
	bool AcceptsCategoricalMaps;	/* required element of type xsd:boolean */
	bool RequiresAbsencePoints;	/* required element of type xsd:boolean */
	_om__AlgorithmMetadataType_Parameters Parameters;	/* required element of type om:AlgorithmMetadataType-Parameters */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_om__AlgorithmMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AlgorithmMetadataType() { om__AlgorithmMetadataType::soap_default(NULL); }
	virtual ~om__AlgorithmMetadataType() { }
};
#endif

#ifndef SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters_Parameter
#define SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters_Parameter (80)
/* om:BasicAlgorithmDefinitionType-Parameters-Parameter */
class SOAP_CMAC _om__BasicAlgorithmDefinitionType_Parameters_Parameter
{
public:
	std::string Id;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__BasicAlgorithmDefinitionType_Parameters_Parameter() { _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__BasicAlgorithmDefinitionType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters
#define SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters (79)
/* om:BasicAlgorithmDefinitionType-Parameters */
class SOAP_CMAC _om__BasicAlgorithmDefinitionType_Parameters
{
public:
	std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*Parameter;	/* optional element of type om:BasicAlgorithmDefinitionType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE__om__BasicAlgorithmDefinitionType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__BasicAlgorithmDefinitionType_Parameters() { _om__BasicAlgorithmDefinitionType_Parameters::soap_default(NULL); }
	virtual ~_om__BasicAlgorithmDefinitionType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE_om__BasicAlgorithmDefinitionType
#define SOAP_TYPE_om__BasicAlgorithmDefinitionType (15)
/* om:BasicAlgorithmDefinitionType */
class SOAP_CMAC om__BasicAlgorithmDefinitionType
{
public:
	_om__BasicAlgorithmDefinitionType_Parameters Parameters;	/* required element of type om:BasicAlgorithmDefinitionType-Parameters */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_om__BasicAlgorithmDefinitionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__BasicAlgorithmDefinitionType() { om__BasicAlgorithmDefinitionType::soap_default(NULL); }
	virtual ~om__BasicAlgorithmDefinitionType() { }
};
#endif

#ifndef SOAP_TYPE__om__SerializedAlgorithmType_Parameters_Parameter
#define SOAP_TYPE__om__SerializedAlgorithmType_Parameters_Parameter (84)
/* om:SerializedAlgorithmType-Parameters-Parameter */
class SOAP_CMAC _om__SerializedAlgorithmType_Parameters_Parameter
{
public:
	std::string Id;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE__om__SerializedAlgorithmType_Parameters_Parameter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Parameters_Parameter() { _om__SerializedAlgorithmType_Parameters_Parameter::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Parameters_Parameter() { }
};
#endif

#ifndef SOAP_TYPE__om__SerializedAlgorithmType_Parameters
#define SOAP_TYPE__om__SerializedAlgorithmType_Parameters (83)
/* om:SerializedAlgorithmType-Parameters */
class SOAP_CMAC _om__SerializedAlgorithmType_Parameters
{
public:
	std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*Parameter;	/* optional element of type om:SerializedAlgorithmType-Parameters-Parameter */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE__om__SerializedAlgorithmType_Parameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Parameters() { _om__SerializedAlgorithmType_Parameters::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Parameters() { }
};
#endif

#ifndef SOAP_TYPE__om__SerializedAlgorithmType_Model
#define SOAP_TYPE__om__SerializedAlgorithmType_Model (88)
/* om:SerializedAlgorithmType-Model */
class SOAP_CMAC _om__SerializedAlgorithmType_Model
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__om__SerializedAlgorithmType_Model */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__SerializedAlgorithmType_Model() { _om__SerializedAlgorithmType_Model::soap_default(NULL); }
	virtual ~_om__SerializedAlgorithmType_Model() { }
};
#endif

#ifndef SOAP_TYPE_om__SerializedAlgorithmType
#define SOAP_TYPE_om__SerializedAlgorithmType (16)
/* om:SerializedAlgorithmType */
class SOAP_CMAC om__SerializedAlgorithmType
{
public:
	_om__SerializedAlgorithmType_Parameters Parameters;	/* required element of type om:SerializedAlgorithmType-Parameters */
	class om__NormalizationType *Normalization;	/* optional element of type om:NormalizationType */
	_om__SerializedAlgorithmType_Model Model;	/* required element of type om:SerializedAlgorithmType-Model */
	std::string Id;	/* required attribute */
	std::string Version;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_om__SerializedAlgorithmType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SerializedAlgorithmType() { om__SerializedAlgorithmType::soap_default(NULL); }
	virtual ~om__SerializedAlgorithmType() { }
};
#endif

#ifndef SOAP_TYPE_om__AvailableLayersType
#define SOAP_TYPE_om__AvailableLayersType (17)
/* om:AvailableLayersType */
class SOAP_CMAC om__AvailableLayersType
{
public:
	class om__LayersGroupType *LayersGroup;	/* required element of type om:LayersGroupType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_om__AvailableLayersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AvailableLayersType() { om__AvailableLayersType::soap_default(NULL); }
	virtual ~om__AvailableLayersType() { }
};
#endif

#ifndef SOAP_TYPE_om__BasicLayerType
#define SOAP_TYPE_om__BasicLayerType (18)
/* om:BasicLayerType */
class SOAP_CMAC om__BasicLayerType
{
public:
	std::string Id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_om__BasicLayerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__BasicLayerType() { om__BasicLayerType::soap_default(NULL); }
	virtual ~om__BasicLayerType() { }
};
#endif

#ifndef SOAP_TYPE_om__LayersGroupType
#define SOAP_TYPE_om__LayersGroupType (21)
/* om:LayersGroupType */
class SOAP_CMAC om__LayersGroupType
{
public:
	std::string Label;	/* required element of type xsd:string */
	std::vector<om__LayersGroupType * >LayersGroup;	/* optional element of type om:LayersGroupType */
	std::vector<class om__LayerMetadataType * >Layer;	/* optional element of type om:LayerMetadataType */
	std::string Id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_om__LayersGroupType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__LayersGroupType() { om__LayersGroupType::soap_default(NULL); }
	virtual ~om__LayersGroupType() { }
};
#endif

#ifndef SOAP_TYPE_om__EnvironmentType
#define SOAP_TYPE_om__EnvironmentType (22)
/* om:EnvironmentType */
class SOAP_CMAC om__EnvironmentType
{
public:
	std::vector<class om__ModellingLayerType * >Map;	/* required element of type om:ModellingLayerType */
	om__BasicLayerType *Mask;	/* required element of type om:BasicLayerType */
	int *NumLayers;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_om__EnvironmentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__EnvironmentType() { om__EnvironmentType::soap_default(NULL); }
	virtual ~om__EnvironmentType() { }
};
#endif

#ifndef SOAP_TYPE__om__OccurrencesType_Point
#define SOAP_TYPE__om__OccurrencesType_Point (97)
/* om:OccurrencesType-Point */
class SOAP_CMAC _om__OccurrencesType_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE__om__OccurrencesType_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesType_Point() { _om__OccurrencesType_Point::soap_default(NULL); }
	virtual ~_om__OccurrencesType_Point() { }
};
#endif

#ifndef SOAP_TYPE_om__OccurrencesType
#define SOAP_TYPE_om__OccurrencesType (23)
/* om:OccurrencesType */
class SOAP_CMAC om__OccurrencesType
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__OccurrencesType_Point >Point;	/* required element of type om:OccurrencesType-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_om__OccurrencesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__OccurrencesType() { om__OccurrencesType::soap_default(NULL); }
	virtual ~om__OccurrencesType() { }
};
#endif

#ifndef SOAP_TYPE_om__SamplerType
#define SOAP_TYPE_om__SamplerType (24)
/* om:SamplerType */
class SOAP_CMAC om__SamplerType
{
public:
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__OccurrencesType *Presence;	/* optional element of type om:OccurrencesType */
	om__OccurrencesType *Absence;	/* optional element of type om:OccurrencesType */
	om__OccurrencesType *Absence_;	/* optional element of type om:OccurrencesType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_om__SamplerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplerType() { om__SamplerType::soap_default(NULL); }
	virtual ~om__SamplerType() { }
};
#endif

#ifndef SOAP_TYPE_om__NormalizationType
#define SOAP_TYPE_om__NormalizationType (25)
/* om:NormalizationType */
class SOAP_CMAC om__NormalizationType
{
public:
	std::string *Class;	/* optional attribute */
	bool *UseLayerAsRef;	/* optional attribute */
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
	std::string *Scales;	/* optional attribute */
	std::string *Offsets;	/* optional attribute */
	std::string *Mean;	/* optional attribute */
	std::string *StdDev;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_om__NormalizationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__NormalizationType() { om__NormalizationType::soap_default(NULL); }
	virtual ~om__NormalizationType() { }
};
#endif

#ifndef SOAP_TYPE__om__TestOptionsType_ConfusionMatrix
#define SOAP_TYPE__om__TestOptionsType_ConfusionMatrix (102)
/* om:TestOptionsType-ConfusionMatrix */
class SOAP_CMAC _om__TestOptionsType_ConfusionMatrix
{
public:
	std::string *Threshold;	/* optional attribute */
	bool *IgnoreAbsences;	/* optional attribute */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE__om__TestOptionsType_ConfusionMatrix */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestOptionsType_ConfusionMatrix() { _om__TestOptionsType_ConfusionMatrix::soap_default(NULL); }
	virtual ~_om__TestOptionsType_ConfusionMatrix() { }
};
#endif

#ifndef SOAP_TYPE__om__TestOptionsType_RocCurve
#define SOAP_TYPE__om__TestOptionsType_RocCurve (105)
/* om:TestOptionsType-RocCurve */
class SOAP_CMAC _om__TestOptionsType_RocCurve
{
public:
	int *Resolution;	/* optional attribute */
	int *BackgroundPoints;	/* optional attribute */
	double *MaxOmission;	/* optional attribute */
	bool *UseAbsencesAsBackground;	/* optional attribute */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE__om__TestOptionsType_RocCurve */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestOptionsType_RocCurve() { _om__TestOptionsType_RocCurve::soap_default(NULL); }
	virtual ~_om__TestOptionsType_RocCurve() { }
};
#endif

#ifndef SOAP_TYPE_om__TestOptionsType
#define SOAP_TYPE_om__TestOptionsType (26)
/* om:TestOptionsType */
class SOAP_CMAC om__TestOptionsType
{
public:
	_om__TestOptionsType_ConfusionMatrix *ConfusionMatrix;	/* optional element of type om:TestOptionsType-ConfusionMatrix */
	_om__TestOptionsType_RocCurve *RocCurve;	/* optional element of type om:TestOptionsType-RocCurve */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_om__TestOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestOptionsType() { om__TestOptionsType::soap_default(NULL); }
	virtual ~om__TestOptionsType() { }
};
#endif

#ifndef SOAP_TYPE__om__TestResultType_ConfusionMatrix
#define SOAP_TYPE__om__TestResultType_ConfusionMatrix (108)
/* om:TestResultType-ConfusionMatrix */
class SOAP_CMAC _om__TestResultType_ConfusionMatrix
{
public:
	double Threshold;	/* required attribute */
	double Accuracy;	/* required attribute */
	double OmissionError;	/* required attribute */
	double CommissionError;	/* required attribute */
	int TruePositives;	/* required attribute */
	int FalsePositives;	/* required attribute */
	int TrueNegatives;	/* required attribute */
	int FalseNegatives;	/* required attribute */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE__om__TestResultType_ConfusionMatrix */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestResultType_ConfusionMatrix() { _om__TestResultType_ConfusionMatrix::soap_default(NULL); }
	virtual ~_om__TestResultType_ConfusionMatrix() { }
};
#endif

#ifndef SOAP_TYPE__om__TestResultType_RocCurve
#define SOAP_TYPE__om__TestResultType_RocCurve (110)
/* om:TestResultType-RocCurve */
class SOAP_CMAC _om__TestResultType_RocCurve
{
public:
	double Auc;	/* required attribute */
	std::string Points;	/* required attribute */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE__om__TestResultType_RocCurve */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__TestResultType_RocCurve() { _om__TestResultType_RocCurve::soap_default(NULL); }
	virtual ~_om__TestResultType_RocCurve() { }
};
#endif

#ifndef SOAP_TYPE_om__TestResultType
#define SOAP_TYPE_om__TestResultType (27)
/* om:TestResultType */
class SOAP_CMAC om__TestResultType
{
public:
	_om__TestResultType_ConfusionMatrix *ConfusionMatrix;	/* optional element of type om:TestResultType-ConfusionMatrix */
	_om__TestResultType_RocCurve *RocCurve;	/* optional element of type om:TestResultType-RocCurve */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_om__TestResultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestResultType() { om__TestResultType::soap_default(NULL); }
	virtual ~om__TestResultType() { }
};
#endif

#ifndef SOAP_TYPE__om__ProjectionStatisticsParametersType_AreaStatistics
#define SOAP_TYPE__om__ProjectionStatisticsParametersType_AreaStatistics (112)
/* om:ProjectionStatisticsParametersType-AreaStatistics */
class SOAP_CMAC _om__ProjectionStatisticsParametersType_AreaStatistics
{
public:
	double PredictionThreshold;	/* required attribute */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE__om__ProjectionStatisticsParametersType_AreaStatistics */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ProjectionStatisticsParametersType_AreaStatistics() { _om__ProjectionStatisticsParametersType_AreaStatistics::soap_default(NULL); }
	virtual ~_om__ProjectionStatisticsParametersType_AreaStatistics() { }
};
#endif

#ifndef SOAP_TYPE_om__ProjectionStatisticsParametersType
#define SOAP_TYPE_om__ProjectionStatisticsParametersType (28)
/* om:ProjectionStatisticsParametersType */
class SOAP_CMAC om__ProjectionStatisticsParametersType
{
public:
	_om__ProjectionStatisticsParametersType_AreaStatistics *AreaStatistics;	/* optional element of type om:ProjectionStatisticsParametersType-AreaStatistics */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_om__ProjectionStatisticsParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionStatisticsParametersType() { om__ProjectionStatisticsParametersType::soap_default(NULL); }
	virtual ~om__ProjectionStatisticsParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__ProjectionEnvelopeType
#define SOAP_TYPE_om__ProjectionEnvelopeType (29)
/* om:ProjectionEnvelopeType */
class SOAP_CMAC om__ProjectionEnvelopeType
{
public:
	class om__AreaStatisticsType *AreaStatistics;	/* required element of type om:AreaStatisticsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_om__ProjectionEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionEnvelopeType() { om__ProjectionEnvelopeType::soap_default(NULL); }
	virtual ~om__ProjectionEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om__AreaStatisticsType
#define SOAP_TYPE_om__AreaStatisticsType (30)
/* om:AreaStatisticsType */
class SOAP_CMAC om__AreaStatisticsType
{
public:
	int TotalCells;	/* required attribute */
	int CellsPredicted;	/* required attribute */
	double PredictionThreshold;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_om__AreaStatisticsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__AreaStatisticsType() { om__AreaStatisticsType::soap_default(NULL); }
	virtual ~om__AreaStatisticsType() { }
};
#endif

#ifndef SOAP_TYPE_om__MapOutputParametersType
#define SOAP_TYPE_om__MapOutputParametersType (31)
/* om:MapOutputParametersType */
class SOAP_CMAC om__MapOutputParametersType
{
public:
	om__BasicLayerType *TemplateLayer;	/* required element of type om:BasicLayerType */
	std::string *FileType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_om__MapOutputParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__MapOutputParametersType() { om__MapOutputParametersType::soap_default(NULL); }
	virtual ~om__MapOutputParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__ModelParametersType
#define SOAP_TYPE_om__ModelParametersType (32)
/* om:ModelParametersType */
class SOAP_CMAC om__ModelParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__BasicAlgorithmDefinitionType *Algorithm;	/* required element of type om:BasicAlgorithmDefinitionType */
	class om__ModelOptionsType *Options;	/* optional element of type om:ModelOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_om__ModelParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelParametersType() { om__ModelParametersType::soap_default(NULL); }
	virtual ~om__ModelParametersType() { }
};
#endif

#ifndef SOAP_TYPE__om__OccurrencesFilterType_SpatiallyUnique
#define SOAP_TYPE__om__OccurrencesFilterType_SpatiallyUnique (118)
/* om:OccurrencesFilterType-SpatiallyUnique */
class SOAP_CMAC _om__OccurrencesFilterType_SpatiallyUnique
{
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE__om__OccurrencesFilterType_SpatiallyUnique */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesFilterType_SpatiallyUnique() { _om__OccurrencesFilterType_SpatiallyUnique::soap_default(NULL); }
	virtual ~_om__OccurrencesFilterType_SpatiallyUnique() { }
};
#endif

#ifndef SOAP_TYPE__om__OccurrencesFilterType_EnvironmentallyUnique
#define SOAP_TYPE__om__OccurrencesFilterType_EnvironmentallyUnique (120)
/* om:OccurrencesFilterType-EnvironmentallyUnique */
class SOAP_CMAC _om__OccurrencesFilterType_EnvironmentallyUnique
{
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE__om__OccurrencesFilterType_EnvironmentallyUnique */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__OccurrencesFilterType_EnvironmentallyUnique() { _om__OccurrencesFilterType_EnvironmentallyUnique::soap_default(NULL); }
	virtual ~_om__OccurrencesFilterType_EnvironmentallyUnique() { }
};
#endif

#ifndef SOAP_TYPE__om__union_OccurrencesFilterType
#define SOAP_TYPE__om__union_OccurrencesFilterType (122)
/* xsd:choice */
union _om__union_OccurrencesFilterType
{
#define SOAP_UNION__om__union_OccurrencesFilterType_SpatiallyUnique	(1)
	_om__OccurrencesFilterType_SpatiallyUnique *SpatiallyUnique;
#define SOAP_UNION__om__union_OccurrencesFilterType_EnvironmentallyUnique	(2)
	_om__OccurrencesFilterType_EnvironmentallyUnique *EnvironmentallyUnique;
};
#endif

#ifndef SOAP_TYPE_om__OccurrencesFilterType
#define SOAP_TYPE_om__OccurrencesFilterType (33)
/* Choice: */
class SOAP_CMAC om__OccurrencesFilterType
{
public:
	int __union_OccurrencesFilterType;	/* union discriminant (of union defined below) */
	union _om__union_OccurrencesFilterType union_OccurrencesFilterType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_om__OccurrencesFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__OccurrencesFilterType() { om__OccurrencesFilterType::soap_default(NULL); }
	virtual ~om__OccurrencesFilterType() { }
};
#endif

#ifndef SOAP_TYPE_om__ModelOptionsType
#define SOAP_TYPE_om__ModelOptionsType (34)
/* om:ModelOptionsType */
class SOAP_CMAC om__ModelOptionsType
{
public:
	om__OccurrencesFilterType *OccurrencesFilter;	/* optional element of type om:OccurrencesFilterType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_om__ModelOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelOptionsType() { om__ModelOptionsType::soap_default(NULL); }
	virtual ~om__ModelOptionsType() { }
};
#endif

#ifndef SOAP_TYPE_om__ModelEnvelopeType
#define SOAP_TYPE_om__ModelEnvelopeType (35)
/* om:ModelEnvelopeType */
class SOAP_CMAC om__ModelEnvelopeType
{
public:
	class om__SerializedModelType *SerializedModel;	/* required element of type om:SerializedModelType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_om__ModelEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEnvelopeType() { om__ModelEnvelopeType::soap_default(NULL); }
	virtual ~om__ModelEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om__SerializedModelType
#define SOAP_TYPE_om__SerializedModelType (36)
/* om:SerializedModelType */
class SOAP_CMAC om__SerializedModelType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__TestResultType *Statistics;	/* optional element of type om:TestResultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_om__SerializedModelType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SerializedModelType() { om__SerializedModelType::soap_default(NULL); }
	virtual ~om__SerializedModelType() { }
};
#endif

#ifndef SOAP_TYPE_om__TestParametersType
#define SOAP_TYPE_om__TestParametersType (37)
/* om:TestParametersType */
class SOAP_CMAC om__TestParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__TestOptionsType *Statistics;	/* optional element of type om:TestOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_om__TestParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestParametersType() { om__TestParametersType::soap_default(NULL); }
	virtual ~om__TestParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__TestResultEnvelopeType
#define SOAP_TYPE_om__TestResultEnvelopeType (38)
/* om:TestResultEnvelopeType */
class SOAP_CMAC om__TestResultEnvelopeType
{
public:
	om__TestResultType *Statistics;	/* optional element of type om:TestResultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_om__TestResultEnvelopeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestResultEnvelopeType() { om__TestResultEnvelopeType::soap_default(NULL); }
	virtual ~om__TestResultEnvelopeType() { }
};
#endif

#ifndef SOAP_TYPE_om__ProjectionParametersType
#define SOAP_TYPE_om__ProjectionParametersType (39)
/* om:ProjectionParametersType */
class SOAP_CMAC om__ProjectionParametersType
{
public:
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__MapOutputParametersType *OutputParameters;	/* optional element of type om:MapOutputParametersType */
	om__ProjectionStatisticsParametersType *Statistics;	/* optional element of type om:ProjectionStatisticsParametersType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_om__ProjectionParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectionParametersType() { om__ProjectionParametersType::soap_default(NULL); }
	virtual ~om__ProjectionParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__ModelEvaluationParametersType
#define SOAP_TYPE_om__ModelEvaluationParametersType (40)
/* om:ModelEvaluationParametersType */
class SOAP_CMAC om__ModelEvaluationParametersType
{
public:
	om__SamplerType *Sampler;	/* required element of type om:SamplerType */
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_om__ModelEvaluationParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEvaluationParametersType() { om__ModelEvaluationParametersType::soap_default(NULL); }
	virtual ~om__ModelEvaluationParametersType() { }
};
#endif

#ifndef SOAP_TYPE__om__ModelEvaluationResultType_Values
#define SOAP_TYPE__om__ModelEvaluationResultType_Values (130)
/* om:ModelEvaluationResultType-Values */
class SOAP_CMAC _om__ModelEvaluationResultType_Values
{
public:
	std::string V;	/* required attribute */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE__om__ModelEvaluationResultType_Values */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ModelEvaluationResultType_Values() { _om__ModelEvaluationResultType_Values::soap_default(NULL); }
	virtual ~_om__ModelEvaluationResultType_Values() { }
};
#endif

#ifndef SOAP_TYPE_om__ModelEvaluationResultType
#define SOAP_TYPE_om__ModelEvaluationResultType (41)
/* om:ModelEvaluationResultType */
class SOAP_CMAC om__ModelEvaluationResultType
{
public:
	_om__ModelEvaluationResultType_Values Values;	/* required element of type om:ModelEvaluationResultType-Values */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_om__ModelEvaluationResultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModelEvaluationResultType() { om__ModelEvaluationResultType::soap_default(NULL); }
	virtual ~om__ModelEvaluationResultType() { }
};
#endif

#ifndef SOAP_TYPE_om__SamplingOptionsType
#define SOAP_TYPE_om__SamplingOptionsType (42)
/* om:SamplingOptionsType */
class SOAP_CMAC om__SamplingOptionsType
{
public:
	om__OccurrencesFilterType *OccurrencesFilter;	/* optional element of type om:OccurrencesFilterType */
	int NumPoints;	/* required attribute */
	std::string *Label;	/* optional attribute */
	double *ProportionOfAbsences;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_om__SamplingOptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingOptionsType() { om__SamplingOptionsType::soap_default(NULL); }
	virtual ~om__SamplingOptionsType() { }
};
#endif

#ifndef SOAP_TYPE_om__SamplingParametersType
#define SOAP_TYPE_om__SamplingParametersType (43)
/* om:SamplingParametersType */
class SOAP_CMAC om__SamplingParametersType
{
public:
	om__EnvironmentType *Environment;	/* required element of type om:EnvironmentType */
	om__SamplingOptionsType *Options;	/* required element of type om:SamplingOptionsType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_om__SamplingParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingParametersType() { om__SamplingParametersType::soap_default(NULL); }
	virtual ~om__SamplingParametersType() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Environment
#define SOAP_TYPE__om__ExperimentParametersType_Environment (132)
/* om:ExperimentParametersType-Environment */
class SOAP_CMAC _om__ExperimentParametersType_Environment
{
public:
	std::vector<om__ModellingLayerType * >Map;	/* required element of type om:ModellingLayerType */
	om__BasicLayerType *Mask;	/* required element of type om:BasicLayerType */
	int *NumLayers;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Environment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Environment() { _om__ExperimentParametersType_Environment::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Environment() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Presence_Point
#define SOAP_TYPE__om__ExperimentParametersType_Presence_Point (135)
/* om:ExperimentParametersType-Presence-Point */
class SOAP_CMAC _om__ExperimentParametersType_Presence_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Presence_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Presence_Point() { _om__ExperimentParametersType_Presence_Point::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Presence_Point() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Presence
#define SOAP_TYPE__om__ExperimentParametersType_Presence (134)
/* om:ExperimentParametersType-Presence */
class SOAP_CMAC _om__ExperimentParametersType_Presence
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__ExperimentParametersType_Presence_Point >Point;	/* required element of type om:ExperimentParametersType-Presence-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Presence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Presence() { _om__ExperimentParametersType_Presence::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Presence() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Absence_Point
#define SOAP_TYPE__om__ExperimentParametersType_Absence_Point (140)
/* om:ExperimentParametersType-Absence-Point */
class SOAP_CMAC _om__ExperimentParametersType_Absence_Point
{
public:
	std::string *Id;	/* optional attribute */
	std::string X;	/* required attribute */
	std::string Y;	/* required attribute */
	std::string *Sample;	/* optional attribute */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Absence_Point */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Absence_Point() { _om__ExperimentParametersType_Absence_Point::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Absence_Point() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Absence
#define SOAP_TYPE__om__ExperimentParametersType_Absence (139)
/* om:ExperimentParametersType-Absence */
class SOAP_CMAC _om__ExperimentParametersType_Absence
{
public:
	std::string *CoordinateSystem;	/* optional element of type xsd:string */
	std::vector<_om__ExperimentParametersType_Absence_Point >Point;	/* required element of type om:ExperimentParametersType-Absence-Point */
	int *Count;	/* optional attribute */
	std::string *Label;	/* optional attribute */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Absence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Absence() { _om__ExperimentParametersType_Absence::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Absence() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_AlgorithmSettings
#define SOAP_TYPE__om__ExperimentParametersType_AlgorithmSettings (144)
/* om:ExperimentParametersType-AlgorithmSettings */
class SOAP_CMAC _om__ExperimentParametersType_AlgorithmSettings
{
public:
	om__BasicAlgorithmDefinitionType *Algorithm;	/* required element of type om:BasicAlgorithmDefinitionType */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_AlgorithmSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_AlgorithmSettings() { _om__ExperimentParametersType_AlgorithmSettings::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_AlgorithmSettings() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_SerializedAlgorithm
#define SOAP_TYPE__om__ExperimentParametersType_SerializedAlgorithm (147)
/* om:ExperimentParametersType-SerializedAlgorithm */
class SOAP_CMAC _om__ExperimentParametersType_SerializedAlgorithm
{
public:
	om__SerializedAlgorithmType *Algorithm;	/* required element of type om:SerializedAlgorithmType */
	std::string id;	/* required attribute */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_SerializedAlgorithm */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_SerializedAlgorithm() { _om__ExperimentParametersType_SerializedAlgorithm::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_SerializedAlgorithm() { }
};
#endif

#ifndef SOAP_TYPE__om__union_ExperimentParametersType_Jobs
#define SOAP_TYPE__om__union_ExperimentParametersType_Jobs (156)
/* xsd:choice */
union _om__union_ExperimentParametersType_Jobs
{
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_SamplingJob	(1)
	class om__SamplingJobType *SamplingJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_CreateModelJob	(2)
	class om__CreateModelJobType *CreateModelJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_TestModelJob	(3)
	class om__TestModelJobType *TestModelJob;
#define SOAP_UNION__om__union_ExperimentParametersType_Jobs_ProjectModelJob	(4)
	class om__ProjectModelJobType *ProjectModelJob;
};
#endif

#ifndef SOAP_TYPE___om__union_ExperimentParametersType_Jobs
#define SOAP_TYPE___om__union_ExperimentParametersType_Jobs (151)
/* Operation wrapper: */
class SOAP_CMAC __om__union_ExperimentParametersType_Jobs
{
public:
	int __unionAbstractJob;	/* union discriminant (of union defined below) */
	union _om__union_ExperimentParametersType_Jobs __union_ExperimentParametersType_Jobs;
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE___om__union_ExperimentParametersType_Jobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __om__union_ExperimentParametersType_Jobs() { __om__union_ExperimentParametersType_Jobs::soap_default(NULL); }
	virtual ~__om__union_ExperimentParametersType_Jobs() { }
};
#endif

#ifndef SOAP_TYPE__om__ExperimentParametersType_Jobs
#define SOAP_TYPE__om__ExperimentParametersType_Jobs (150)
/* om:ExperimentParametersType-Jobs */
class SOAP_CMAC _om__ExperimentParametersType_Jobs
{
public:
	std::string id;	/* required attribute */
	int __sizeAbstractJob;	/* sequence of elements <-union-ExperimentParametersType-Jobs> */
	__om__union_ExperimentParametersType_Jobs *__union_ExperimentParametersType_Jobs;
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE__om__ExperimentParametersType_Jobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ExperimentParametersType_Jobs() { _om__ExperimentParametersType_Jobs::soap_default(NULL); }
	virtual ~_om__ExperimentParametersType_Jobs() { }
};
#endif

#ifndef SOAP_TYPE_om__ExperimentParametersType
#define SOAP_TYPE_om__ExperimentParametersType (44)
/* om:ExperimentParametersType */
class SOAP_CMAC om__ExperimentParametersType
{
public:
	std::vector<_om__ExperimentParametersType_Environment >Environment;	/* required element of type om:ExperimentParametersType-Environment */
	std::vector<_om__ExperimentParametersType_Presence >*Presence;	/* optional element of type om:ExperimentParametersType-Presence */
	std::vector<_om__ExperimentParametersType_Absence >*Absence;	/* optional element of type om:ExperimentParametersType-Absence */
	std::vector<_om__ExperimentParametersType_AlgorithmSettings >*AlgorithmSettings;	/* optional element of type om:ExperimentParametersType-AlgorithmSettings */
	std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*SerializedAlgorithm;	/* optional element of type om:ExperimentParametersType-SerializedAlgorithm */
	_om__ExperimentParametersType_Jobs Jobs;	/* required element of type om:ExperimentParametersType-Jobs */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_om__ExperimentParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ExperimentParametersType() { om__ExperimentParametersType::soap_default(NULL); }
	virtual ~om__ExperimentParametersType() { }
};
#endif

#ifndef SOAP_TYPE_om__ReferenceType
#define SOAP_TYPE_om__ReferenceType (45)
/* om:ReferenceType */
class SOAP_CMAC om__ReferenceType
{
public:
	std::string idref;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_om__ReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ReferenceType() { om__ReferenceType::soap_default(NULL); }
	virtual ~om__ReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_om__IdentifiedType
#define SOAP_TYPE_om__IdentifiedType (46)
/* om:IdentifiedType */
class SOAP_CMAC om__IdentifiedType
{
public:
	std::string id;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_om__IdentifiedType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__IdentifiedType() { om__IdentifiedType::soap_default(NULL); }
	virtual ~om__IdentifiedType() { }
};
#endif

#ifndef SOAP_TYPE__om__JobTicketsType_Job
#define SOAP_TYPE__om__JobTicketsType_Job (158)
/* om:JobTicketsType-Job */
class SOAP_CMAC _om__JobTicketsType_Job
{
public:
	std::string id;	/* required attribute */
	std::string Ticket;	/* required attribute */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE__om__JobTicketsType_Job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__JobTicketsType_Job() { _om__JobTicketsType_Job::soap_default(NULL); }
	virtual ~_om__JobTicketsType_Job() { }
};
#endif

#ifndef SOAP_TYPE_om__JobTicketsType
#define SOAP_TYPE_om__JobTicketsType (51)
/* om:JobTicketsType */
class SOAP_CMAC om__JobTicketsType
{
public:
	std::vector<_om__JobTicketsType_Job >Job;	/* required element of type om:JobTicketsType-Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_om__JobTicketsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__JobTicketsType() { om__JobTicketsType::soap_default(NULL); }
	virtual ~om__JobTicketsType() { }
};
#endif

#ifndef SOAP_TYPE__om__ResultSetType_Job_ProjectionEnvelope
#define SOAP_TYPE__om__ResultSetType_Job_ProjectionEnvelope (163)
/* om:ResultSetType-Job-ProjectionEnvelope */
class SOAP_CMAC _om__ResultSetType_Job_ProjectionEnvelope
{
public:
	om__ProjectionEnvelopeType *Statistics;	/* optional element of type om:ProjectionEnvelopeType */
	std::string url;	/* required attribute */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE__om__ResultSetType_Job_ProjectionEnvelope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ResultSetType_Job_ProjectionEnvelope() { _om__ResultSetType_Job_ProjectionEnvelope::soap_default(NULL); }
	virtual ~_om__ResultSetType_Job_ProjectionEnvelope() { }
};
#endif

#ifndef SOAP_TYPE__om__union_ResultSetType_Job
#define SOAP_TYPE__om__union_ResultSetType_Job (166)
/* xsd:choice */
union _om__union_ResultSetType_Job
{
#define SOAP_UNION__om__union_ResultSetType_Job_Sampler	(1)
	om__SamplerType *Sampler;
#define SOAP_UNION__om__union_ResultSetType_Job_ModelEnvelope	(2)
	om__ModelEnvelopeType *ModelEnvelope;
#define SOAP_UNION__om__union_ResultSetType_Job_TestResultEnvelope	(3)
	om__TestResultEnvelopeType *TestResultEnvelope;
#define SOAP_UNION__om__union_ResultSetType_Job_ProjectionEnvelope	(4)
	_om__ResultSetType_Job_ProjectionEnvelope *ProjectionEnvelope;
};
#endif

#ifndef SOAP_TYPE__om__ResultSetType_Job
#define SOAP_TYPE__om__ResultSetType_Job (160)
/* om:ResultSetType-Job */
class SOAP_CMAC _om__ResultSetType_Job
{
public:
	int __union_ResultSetType_Job;	/* union discriminant (of union defined below) */
	union _om__union_ResultSetType_Job union_ResultSetType_Job;	/* required element of type xsd:choice */
	std::string Ticket;	/* required attribute */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE__om__ResultSetType_Job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _om__ResultSetType_Job() { _om__ResultSetType_Job::soap_default(NULL); }
	virtual ~_om__ResultSetType_Job() { }
};
#endif

#ifndef SOAP_TYPE_om__ResultSetType
#define SOAP_TYPE_om__ResultSetType (52)
/* om:ResultSetType */
class SOAP_CMAC om__ResultSetType
{
public:
	std::vector<_om__ResultSetType_Job >Job;	/* required element of type om:ResultSetType-Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_om__ResultSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ResultSetType() { om__ResultSetType::soap_default(NULL); }
	virtual ~om__ResultSetType() { }
};
#endif

#ifndef SOAP_TYPE_om__ModellingLayerType
#define SOAP_TYPE_om__ModellingLayerType (19)
/* om:ModellingLayerType */
class SOAP_CMAC om__ModellingLayerType : public om__BasicLayerType
{
public:
	bool *IsCategorical;	/* optional attribute */
	double *Min;	/* optional attribute */
	double *Max;	/* optional attribute */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_om__ModellingLayerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ModellingLayerType() { om__ModellingLayerType::soap_default(NULL); }
	virtual ~om__ModellingLayerType() { }
};
#endif

#ifndef SOAP_TYPE_om__SamplingJobType
#define SOAP_TYPE_om__SamplingJobType (47)
/* om:SamplingJobType */
class SOAP_CMAC om__SamplingJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__SamplingOptionsType *Options;	/* required element of type om:SamplingOptionsType */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_om__SamplingJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__SamplingJobType() { om__SamplingJobType::soap_default(NULL); }
	virtual ~om__SamplingJobType() { }
};
#endif

#ifndef SOAP_TYPE_om__CreateModelJobType
#define SOAP_TYPE_om__CreateModelJobType (48)
/* om:CreateModelJobType */
class SOAP_CMAC om__CreateModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *PresenceRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *AbsenceRef;	/* optional element of type om:ReferenceType */
	om__ReferenceType *AlgorithmRef;	/* required element of type om:ReferenceType */
	om__ModelOptionsType *Options;	/* optional element of type om:ModelOptionsType */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_om__CreateModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__CreateModelJobType() { om__CreateModelJobType::soap_default(NULL); }
	virtual ~om__CreateModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om__TestModelJobType
#define SOAP_TYPE_om__TestModelJobType (49)
/* om:TestModelJobType */
class SOAP_CMAC om__TestModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *PresenceRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *AbsenceRef;	/* optional element of type om:ReferenceType */
	om__ReferenceType *ModelRef;	/* required element of type om:ReferenceType */
	om__TestOptionsType *Statistics;	/* optional element of type om:TestOptionsType */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_om__TestModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__TestModelJobType() { om__TestModelJobType::soap_default(NULL); }
	virtual ~om__TestModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om__ProjectModelJobType
#define SOAP_TYPE_om__ProjectModelJobType (50)
/* om:ProjectModelJobType */
class SOAP_CMAC om__ProjectModelJobType : public om__IdentifiedType
{
public:
	om__ReferenceType *EnvironmentRef;	/* required element of type om:ReferenceType */
	om__ReferenceType *ModelRef;	/* required element of type om:ReferenceType */
	om__MapOutputParametersType *OutputParameters;	/* optional element of type om:MapOutputParametersType */
	om__ProjectionStatisticsParametersType *Statistics;	/* optional element of type om:ProjectionStatisticsParametersType */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_om__ProjectModelJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__ProjectModelJobType() { om__ProjectModelJobType::soap_default(NULL); }
	virtual ~om__ProjectModelJobType() { }
};
#endif

#ifndef SOAP_TYPE_om__LayerMetadataType
#define SOAP_TYPE_om__LayerMetadataType (20)
/* om:LayerMetadataType */
class SOAP_CMAC om__LayerMetadataType : public om__ModellingLayerType
{
public:
	std::string *Label;	/* optional element of type xsd:string */
	bool *HasProjection;	/* optional attribute */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_om__LayerMetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         om__LayerMetadataType() { om__LayerMetadataType::soap_default(NULL); }
	virtual ~om__LayerMetadataType() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (197)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *omws__version;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 197; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef SOAP_TYPE_omws__pingResponse
#define SOAP_TYPE_omws__pingResponse (202)
/* omws:pingResponse */
struct omws__pingResponse
{
public:
	int status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
public:
	int soap_type() const { return 202; } /* = unique id SOAP_TYPE_omws__pingResponse */
};
#endif

#ifndef SOAP_TYPE_omws__ping
#define SOAP_TYPE_omws__ping (203)
/* omws:ping */
struct omws__ping
{
public:
	void *_;	/* transient */
public:
	int soap_type() const { return 203; } /* = unique id SOAP_TYPE_omws__ping */
};
#endif

#ifndef SOAP_TYPE_omws__getAlgorithmsResponse
#define SOAP_TYPE_omws__getAlgorithmsResponse (204)
/* omws:getAlgorithmsResponse */
struct omws__getAlgorithmsResponse
{
public:
	wchar_t *om__AvailableAlgorithms;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 204; } /* = unique id SOAP_TYPE_omws__getAlgorithmsResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getAlgorithms
#define SOAP_TYPE_omws__getAlgorithms (207)
/* omws:getAlgorithms */
struct omws__getAlgorithms
{
public:
	void *_;	/* transient */
public:
	int soap_type() const { return 207; } /* = unique id SOAP_TYPE_omws__getAlgorithms */
};
#endif

#ifndef SOAP_TYPE_omws__getLayersResponse
#define SOAP_TYPE_omws__getLayersResponse (208)
/* omws:getLayersResponse */
struct omws__getLayersResponse
{
public:
	wchar_t *om__AvailableLayers;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 208; } /* = unique id SOAP_TYPE_omws__getLayersResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getLayers
#define SOAP_TYPE_omws__getLayers (211)
/* omws:getLayers */
struct omws__getLayers
{
public:
	void *_;	/* transient */
public:
	int soap_type() const { return 211; } /* = unique id SOAP_TYPE_omws__getLayers */
};
#endif

#ifndef SOAP_TYPE_omws__createModelResponse
#define SOAP_TYPE_omws__createModelResponse (214)
/* omws:createModelResponse */
struct omws__createModelResponse
{
public:
	std::string ticket;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 214; } /* = unique id SOAP_TYPE_omws__createModelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__createModel
#define SOAP_TYPE_omws__createModel (215)
/* omws:createModel */
struct omws__createModel
{
public:
	wchar_t *om__ModelParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 215; } /* = unique id SOAP_TYPE_omws__createModel */
};
#endif

#ifndef SOAP_TYPE_omws__getModelResponse
#define SOAP_TYPE_omws__getModelResponse (216)
/* omws:getModelResponse */
struct omws__getModelResponse
{
public:
	wchar_t *om__ModelEnvelope;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 216; } /* = unique id SOAP_TYPE_omws__getModelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getModel
#define SOAP_TYPE_omws__getModel (219)
/* omws:getModel */
struct omws__getModel
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 219; } /* = unique id SOAP_TYPE_omws__getModel */
};
#endif

#ifndef SOAP_TYPE_omws__testModelResponse
#define SOAP_TYPE_omws__testModelResponse (221)
/* omws:testModelResponse */
struct omws__testModelResponse
{
public:
	std::string ticket;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 221; } /* = unique id SOAP_TYPE_omws__testModelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__testModel
#define SOAP_TYPE_omws__testModel (222)
/* omws:testModel */
struct omws__testModel
{
public:
	wchar_t *om__TestParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 222; } /* = unique id SOAP_TYPE_omws__testModel */
};
#endif

#ifndef SOAP_TYPE_omws__testResponse
#define SOAP_TYPE_omws__testResponse (223)
/* omws:testResponse */
struct omws__testResponse
{
public:
	wchar_t *om__TestResultEnvelope;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 223; } /* = unique id SOAP_TYPE_omws__testResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getTestResult
#define SOAP_TYPE_omws__getTestResult (226)
/* omws:getTestResult */
struct omws__getTestResult
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 226; } /* = unique id SOAP_TYPE_omws__getTestResult */
};
#endif

#ifndef SOAP_TYPE_omws__projectModelResponse
#define SOAP_TYPE_omws__projectModelResponse (228)
/* omws:projectModelResponse */
struct omws__projectModelResponse
{
public:
	std::string ticket;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 228; } /* = unique id SOAP_TYPE_omws__projectModelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__projectModel
#define SOAP_TYPE_omws__projectModel (229)
/* omws:projectModel */
struct omws__projectModel
{
public:
	wchar_t *om__ProjectionParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 229; } /* = unique id SOAP_TYPE_omws__projectModel */
};
#endif

#ifndef SOAP_TYPE_omws__getProgressResponse
#define SOAP_TYPE_omws__getProgressResponse (231)
/* omws:getProgressResponse */
struct omws__getProgressResponse
{
public:
	std::string progress;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 231; } /* = unique id SOAP_TYPE_omws__getProgressResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getProgress
#define SOAP_TYPE_omws__getProgress (232)
/* omws:getProgress */
struct omws__getProgress
{
public:
	std::string tickets;	/* required element of type xsd:string */
public:
	int soap_type() const { return 232; } /* = unique id SOAP_TYPE_omws__getProgress */
};
#endif

#ifndef SOAP_TYPE_omws__getLogResponse
#define SOAP_TYPE_omws__getLogResponse (234)
/* omws:getLogResponse */
struct omws__getLogResponse
{
public:
	std::string log;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 234; } /* = unique id SOAP_TYPE_omws__getLogResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getLog
#define SOAP_TYPE_omws__getLog (235)
/* omws:getLog */
struct omws__getLog
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 235; } /* = unique id SOAP_TYPE_omws__getLog */
};
#endif

#ifndef SOAP_TYPE_omws__getLayerAsUrlResponse
#define SOAP_TYPE_omws__getLayerAsUrlResponse (237)
/* omws:getLayerAsUrlResponse */
struct omws__getLayerAsUrlResponse
{
public:
	std::string url;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 237; } /* = unique id SOAP_TYPE_omws__getLayerAsUrlResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getLayerAsUrl
#define SOAP_TYPE_omws__getLayerAsUrl (238)
/* omws:getLayerAsUrl */
struct omws__getLayerAsUrl
{
public:
	std::string id;	/* required element of type xsd:string */
public:
	int soap_type() const { return 238; } /* = unique id SOAP_TYPE_omws__getLayerAsUrl */
};
#endif

#ifndef SOAP_TYPE_omws__getProjectionMetadataResponse
#define SOAP_TYPE_omws__getProjectionMetadataResponse (239)
/* omws:getProjectionMetadataResponse */
struct omws__getProjectionMetadataResponse
{
public:
	int FileSize;	/* optional attribute of type xsd:int */
	wchar_t *om__ProjectionEnvelope;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 239; } /* = unique id SOAP_TYPE_omws__getProjectionMetadataResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getProjectionMetadata
#define SOAP_TYPE_omws__getProjectionMetadata (242)
/* omws:getProjectionMetadata */
struct omws__getProjectionMetadata
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 242; } /* = unique id SOAP_TYPE_omws__getProjectionMetadata */
};
#endif

#ifndef SOAP_TYPE_omws__evaluateModelResponse
#define SOAP_TYPE_omws__evaluateModelResponse (244)
/* omws:evaluateModelResponse */
struct omws__evaluateModelResponse
{
public:
	std::string ticket;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 244; } /* = unique id SOAP_TYPE_omws__evaluateModelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__evaluateModel
#define SOAP_TYPE_omws__evaluateModel (245)
/* omws:evaluateModel */
struct omws__evaluateModel
{
public:
	wchar_t *om__ModelEvaluationParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 245; } /* = unique id SOAP_TYPE_omws__evaluateModel */
};
#endif

#ifndef SOAP_TYPE_omws__modelEvaluationResponse
#define SOAP_TYPE_omws__modelEvaluationResponse (246)
/* omws:modelEvaluationResponse */
struct omws__modelEvaluationResponse
{
public:
	wchar_t *om__ModelEvaluation;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 246; } /* = unique id SOAP_TYPE_omws__modelEvaluationResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getModelEvaluation
#define SOAP_TYPE_omws__getModelEvaluation (249)
/* omws:getModelEvaluation */
struct omws__getModelEvaluation
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 249; } /* = unique id SOAP_TYPE_omws__getModelEvaluation */
};
#endif

#ifndef SOAP_TYPE_omws__samplePointsResponse
#define SOAP_TYPE_omws__samplePointsResponse (251)
/* omws:samplePointsResponse */
struct omws__samplePointsResponse
{
public:
	std::string ticket;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 251; } /* = unique id SOAP_TYPE_omws__samplePointsResponse */
};
#endif

#ifndef SOAP_TYPE_omws__samplePoints
#define SOAP_TYPE_omws__samplePoints (252)
/* omws:samplePoints */
struct omws__samplePoints
{
public:
	wchar_t *om__SamplingParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 252; } /* = unique id SOAP_TYPE_omws__samplePoints */
};
#endif

#ifndef SOAP_TYPE_omws__getSamplingResultResponse
#define SOAP_TYPE_omws__getSamplingResultResponse (253)
/* omws:getSamplingResultResponse */
struct omws__getSamplingResultResponse
{
public:
	wchar_t *om__Sampler;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 253; } /* = unique id SOAP_TYPE_omws__getSamplingResultResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getSamplingResult
#define SOAP_TYPE_omws__getSamplingResult (256)
/* omws:getSamplingResult */
struct omws__getSamplingResult
{
public:
	std::string ticket;	/* required element of type xsd:string */
public:
	int soap_type() const { return 256; } /* = unique id SOAP_TYPE_omws__getSamplingResult */
};
#endif

#ifndef SOAP_TYPE_omws__runExperimentResponse
#define SOAP_TYPE_omws__runExperimentResponse (257)
/* omws:runExperimentResponse */
struct omws__runExperimentResponse
{
public:
	wchar_t *om__ExperimentTickets;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 257; } /* = unique id SOAP_TYPE_omws__runExperimentResponse */
};
#endif

#ifndef SOAP_TYPE_omws__runExperiment
#define SOAP_TYPE_omws__runExperiment (260)
/* omws:runExperiment */
struct omws__runExperiment
{
public:
	char *om__ExperimentParameters;	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 260; } /* = unique id SOAP_TYPE_omws__runExperiment */
};
#endif

#ifndef SOAP_TYPE_omws__getResultsResponse
#define SOAP_TYPE_omws__getResultsResponse (261)
/* omws:getResultsResponse */
struct omws__getResultsResponse
{
public:
	wchar_t *om__ResultSet;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:anyType */
public:
	int soap_type() const { return 261; } /* = unique id SOAP_TYPE_omws__getResultsResponse */
};
#endif

#ifndef SOAP_TYPE_omws__getResults
#define SOAP_TYPE_omws__getResults (264)
/* omws:getResults */
struct omws__getResults
{
public:
	std::string tickets;	/* required element of type xsd:string */
public:
	int soap_type() const { return 264; } /* = unique id SOAP_TYPE_omws__getResults */
};
#endif

#ifndef SOAP_TYPE_omws__cancelResponse
#define SOAP_TYPE_omws__cancelResponse (266)
/* omws:cancelResponse */
struct omws__cancelResponse
{
public:
	std::string cancelledTickets;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 266; } /* = unique id SOAP_TYPE_omws__cancelResponse */
};
#endif

#ifndef SOAP_TYPE_omws__cancel
#define SOAP_TYPE_omws__cancel (267)
/* omws:cancel */
struct omws__cancel
{
public:
	std::string tickets;	/* required element of type xsd:string */
public:
	int soap_type() const { return 267; } /* = unique id SOAP_TYPE_omws__cancel */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (268)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 268; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (270)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 270; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (271)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 271; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (272)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 272; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (10)
typedef std::string xsd__IDREF;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (11)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_om__ThresholdParameterType
#define SOAP_TYPE_om__ThresholdParameterType (53)
typedef std::string om__ThresholdParameterType;
#endif

#ifndef SOAP_TYPE_om__ZeroOneIntervalType
#define SOAP_TYPE_om__ZeroOneIntervalType (55)
typedef double om__ZeroOneIntervalType;
#endif

#ifndef SOAP_TYPE__om__AvailableAlgorithms
#define SOAP_TYPE__om__AvailableAlgorithms (169)
typedef om__AvailableAlgorithmsType _om__AvailableAlgorithms;
#endif

#ifndef SOAP_TYPE__om__Algorithms
#define SOAP_TYPE__om__Algorithms (170)
typedef om__AlgorithmsMetadataType _om__Algorithms;
#endif

#ifndef SOAP_TYPE__om__AvailableLayers
#define SOAP_TYPE__om__AvailableLayers (171)
typedef om__AvailableLayersType _om__AvailableLayers;
#endif

#ifndef SOAP_TYPE__om__ModelParameters
#define SOAP_TYPE__om__ModelParameters (172)
typedef om__ModelParametersType _om__ModelParameters;
#endif

#ifndef SOAP_TYPE__om__ModelEnvelope
#define SOAP_TYPE__om__ModelEnvelope (173)
typedef om__ModelEnvelopeType _om__ModelEnvelope;
#endif

#ifndef SOAP_TYPE__om__TestParameters
#define SOAP_TYPE__om__TestParameters (174)
typedef om__TestParametersType _om__TestParameters;
#endif

#ifndef SOAP_TYPE__om__TestResultEnvelope
#define SOAP_TYPE__om__TestResultEnvelope (175)
typedef om__TestResultEnvelopeType _om__TestResultEnvelope;
#endif

#ifndef SOAP_TYPE__om__SerializedModel
#define SOAP_TYPE__om__SerializedModel (176)
typedef om__SerializedModelType _om__SerializedModel;
#endif

#ifndef SOAP_TYPE__om__ProjectionParameters
#define SOAP_TYPE__om__ProjectionParameters (177)
typedef om__ProjectionParametersType _om__ProjectionParameters;
#endif

#ifndef SOAP_TYPE__om__ProjectionEnvelope
#define SOAP_TYPE__om__ProjectionEnvelope (178)
typedef om__ProjectionEnvelopeType _om__ProjectionEnvelope;
#endif

#ifndef SOAP_TYPE__om__ModelEvaluationParameters
#define SOAP_TYPE__om__ModelEvaluationParameters (179)
typedef om__ModelEvaluationParametersType _om__ModelEvaluationParameters;
#endif

#ifndef SOAP_TYPE__om__ModelEvaluation
#define SOAP_TYPE__om__ModelEvaluation (180)
typedef om__ModelEvaluationResultType _om__ModelEvaluation;
#endif

#ifndef SOAP_TYPE__om__SamplingParameters
#define SOAP_TYPE__om__SamplingParameters (181)
typedef om__SamplingParametersType _om__SamplingParameters;
#endif

#ifndef SOAP_TYPE__om__Sampler
#define SOAP_TYPE__om__Sampler (182)
typedef om__SamplerType _om__Sampler;
#endif

#ifndef SOAP_TYPE__om__ExperimentParameters
#define SOAP_TYPE__om__ExperimentParameters (183)
typedef om__ExperimentParametersType _om__ExperimentParameters;
#endif

#ifndef SOAP_TYPE__om__ExperimentTickets
#define SOAP_TYPE__om__ExperimentTickets (184)
typedef om__JobTicketsType _om__ExperimentTickets;
#endif

#ifndef SOAP_TYPE__om__ResultSet
#define SOAP_TYPE__om__ResultSet (185)
typedef om__ResultSetType _om__ResultSet;
#endif

#ifndef SOAP_TYPE__om__SamplingJob
#define SOAP_TYPE__om__SamplingJob (186)
typedef om__SamplingJobType _om__SamplingJob;
#endif

#ifndef SOAP_TYPE__om__CreateModelJob
#define SOAP_TYPE__om__CreateModelJob (187)
typedef om__CreateModelJobType _om__CreateModelJob;
#endif

#ifndef SOAP_TYPE__om__TestModelJob
#define SOAP_TYPE__om__TestModelJob (188)
typedef om__TestModelJobType _om__TestModelJob;
#endif

#ifndef SOAP_TYPE__om__ProjectModelJob
#define SOAP_TYPE__om__ProjectModelJob (189)
typedef om__ProjectModelJobType _om__ProjectModelJob;
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (190)
typedef std::string xsd__string;
#endif

#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (191)
typedef double xsd__double;
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (192)
typedef int xsd__int;
#endif

#ifndef SOAP_TYPE_XML
#define SOAP_TYPE_XML (195)
typedef wchar_t *XML;
#endif

#ifndef SOAP_TYPE_XML_
#define SOAP_TYPE_XML_ (196)
typedef char *XML_;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 omws__ping(struct soap*, void *_, int &status);

SOAP_FMAC5 int SOAP_FMAC6 omws__getAlgorithms(struct soap*, void *_, struct omws__getAlgorithmsResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__getLayers(struct soap*, void *_, struct omws__getLayersResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__createModel(struct soap*, wchar_t *om__ModelParameters, std::string &ticket);

SOAP_FMAC5 int SOAP_FMAC6 omws__getModel(struct soap*, std::string ticket, struct omws__getModelResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__testModel(struct soap*, wchar_t *om__TestParameters, std::string &ticket);

SOAP_FMAC5 int SOAP_FMAC6 omws__getTestResult(struct soap*, std::string ticket, struct omws__testResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__projectModel(struct soap*, wchar_t *om__ProjectionParameters, std::string &ticket);

SOAP_FMAC5 int SOAP_FMAC6 omws__getProgress(struct soap*, std::string tickets, std::string &progress);

SOAP_FMAC5 int SOAP_FMAC6 omws__getLog(struct soap*, std::string ticket, std::string &log);

SOAP_FMAC5 int SOAP_FMAC6 omws__getLayerAsUrl(struct soap*, std::string id, std::string &url);

SOAP_FMAC5 int SOAP_FMAC6 omws__getProjectionMetadata(struct soap*, std::string ticket, struct omws__getProjectionMetadataResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__evaluateModel(struct soap*, wchar_t *om__ModelEvaluationParameters, std::string &ticket);

SOAP_FMAC5 int SOAP_FMAC6 omws__getModelEvaluation(struct soap*, std::string ticket, struct omws__modelEvaluationResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__samplePoints(struct soap*, wchar_t *om__SamplingParameters, std::string &ticket);

SOAP_FMAC5 int SOAP_FMAC6 omws__getSamplingResult(struct soap*, std::string ticket, struct omws__getSamplingResultResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__runExperiment(struct soap*, char *om__ExperimentParameters, struct omws__runExperimentResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__getResults(struct soap*, std::string tickets, struct omws__getResultsResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 omws__cancel(struct soap*, std::string tickets, std::string &cancelledTickets);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__ping(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getAlgorithms(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getLayers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__createModel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getModel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__testModel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getTestResult(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__projectModel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getProgress(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getLayerAsUrl(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getProjectionMetadata(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__evaluateModel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getModelEvaluation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__samplePoints(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getSamplingResult(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__runExperiment(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__getResults(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_omws__cancel(struct soap*);

#endif

/* End of soapStub.h */
