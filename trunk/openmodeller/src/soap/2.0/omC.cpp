/* omC.cpp
   Generated by gSOAP 2.8.15 from openModeller.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "omH.h"

namespace om {

SOAP_SOURCE_STAMP("@(#) omC.cpp ver 2.8.15 2013-08-07 19:58:35 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_om_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_om_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_om_om__ZeroOneIntervalType:
		return soap_in_om__ZeroOneIntervalType(soap, NULL, NULL, "om:ZeroOneIntervalType");
	case SOAP_TYPE_om_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_om_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_om_om__ThresholdCalculationType:
		return soap_in_om__ThresholdCalculationType(soap, NULL, NULL, "om:ThresholdCalculationType");
	case SOAP_TYPE_om_om__ThresholdParameterType:
		return soap_in_om__ThresholdParameterType(soap, NULL, NULL, "om:ThresholdParameterType");
	case SOAP_TYPE_om_om__ResultSetType:
		return soap_in_om__ResultSetType(soap, NULL, NULL, "om:ResultSetType");
	case SOAP_TYPE_om_om__JobTicketsType:
		return soap_in_om__JobTicketsType(soap, NULL, NULL, "om:JobTicketsType");
	case SOAP_TYPE_om_om__ProjectModelJobType:
		return soap_in_om__ProjectModelJobType(soap, NULL, NULL, "om:ProjectModelJobType");
	case SOAP_TYPE_om_om__TestModelJobType:
		return soap_in_om__TestModelJobType(soap, NULL, NULL, "om:TestModelJobType");
	case SOAP_TYPE_om_om__CreateModelJobType:
		return soap_in_om__CreateModelJobType(soap, NULL, NULL, "om:CreateModelJobType");
	case SOAP_TYPE_om_om__SamplingJobType:
		return soap_in_om__SamplingJobType(soap, NULL, NULL, "om:SamplingJobType");
	case SOAP_TYPE_om_om__IdentifiedType:
		return soap_in_om__IdentifiedType(soap, NULL, NULL, "om:IdentifiedType");
	case SOAP_TYPE_om_om__ReferenceType:
		return soap_in_om__ReferenceType(soap, NULL, NULL, "om:ReferenceType");
	case SOAP_TYPE_om_om__ExperimentParametersType:
		return soap_in_om__ExperimentParametersType(soap, NULL, NULL, "om:ExperimentParametersType");
	case SOAP_TYPE_om_om__SamplingParametersType:
		return soap_in_om__SamplingParametersType(soap, NULL, NULL, "om:SamplingParametersType");
	case SOAP_TYPE_om_om__SamplingOptionsType:
		return soap_in_om__SamplingOptionsType(soap, NULL, NULL, "om:SamplingOptionsType");
	case SOAP_TYPE_om_om__ModelEvaluationResultType:
		return soap_in_om__ModelEvaluationResultType(soap, NULL, NULL, "om:ModelEvaluationResultType");
	case SOAP_TYPE_om_om__ModelEvaluationParametersType:
		return soap_in_om__ModelEvaluationParametersType(soap, NULL, NULL, "om:ModelEvaluationParametersType");
	case SOAP_TYPE_om_om__ProjectionParametersType:
		return soap_in_om__ProjectionParametersType(soap, NULL, NULL, "om:ProjectionParametersType");
	case SOAP_TYPE_om_om__TestResultEnvelopeType:
		return soap_in_om__TestResultEnvelopeType(soap, NULL, NULL, "om:TestResultEnvelopeType");
	case SOAP_TYPE_om_om__TestParametersType:
		return soap_in_om__TestParametersType(soap, NULL, NULL, "om:TestParametersType");
	case SOAP_TYPE_om_om__SerializedModelType:
		return soap_in_om__SerializedModelType(soap, NULL, NULL, "om:SerializedModelType");
	case SOAP_TYPE_om_om__ModelEnvelopeType:
		return soap_in_om__ModelEnvelopeType(soap, NULL, NULL, "om:ModelEnvelopeType");
	case SOAP_TYPE_om_om__ModelOptionsType:
		return soap_in_om__ModelOptionsType(soap, NULL, NULL, "om:ModelOptionsType");
	case SOAP_TYPE_om_om__OccurrencesFilterType:
		return soap_in_om__OccurrencesFilterType(soap, NULL, NULL, "om:OccurrencesFilterType");
	case SOAP_TYPE_om_om__ModelParametersType:
		return soap_in_om__ModelParametersType(soap, NULL, NULL, "om:ModelParametersType");
	case SOAP_TYPE_om_om__MapOutputParametersType:
		return soap_in_om__MapOutputParametersType(soap, NULL, NULL, "om:MapOutputParametersType");
	case SOAP_TYPE_om_om__AreaStatisticsType:
		return soap_in_om__AreaStatisticsType(soap, NULL, NULL, "om:AreaStatisticsType");
	case SOAP_TYPE_om_om__ProjectionEnvelopeType:
		return soap_in_om__ProjectionEnvelopeType(soap, NULL, NULL, "om:ProjectionEnvelopeType");
	case SOAP_TYPE_om_om__ProjectionStatisticsParametersType:
		return soap_in_om__ProjectionStatisticsParametersType(soap, NULL, NULL, "om:ProjectionStatisticsParametersType");
	case SOAP_TYPE_om_om__TestResultType:
		return soap_in_om__TestResultType(soap, NULL, NULL, "om:TestResultType");
	case SOAP_TYPE_om_om__TestOptionsType:
		return soap_in_om__TestOptionsType(soap, NULL, NULL, "om:TestOptionsType");
	case SOAP_TYPE_om_om__NormalizationType:
		return soap_in_om__NormalizationType(soap, NULL, NULL, "om:NormalizationType");
	case SOAP_TYPE_om_om__SamplerType:
		return soap_in_om__SamplerType(soap, NULL, NULL, "om:SamplerType");
	case SOAP_TYPE_om_om__OccurrencesType:
		return soap_in_om__OccurrencesType(soap, NULL, NULL, "om:OccurrencesType");
	case SOAP_TYPE_om_om__EnvironmentType:
		return soap_in_om__EnvironmentType(soap, NULL, NULL, "om:EnvironmentType");
	case SOAP_TYPE_om_om__LayersGroupType:
		return soap_in_om__LayersGroupType(soap, NULL, NULL, "om:LayersGroupType");
	case SOAP_TYPE_om_om__LayerMetadataType:
		return soap_in_om__LayerMetadataType(soap, NULL, NULL, "om:LayerMetadataType");
	case SOAP_TYPE_om_om__ModellingLayerType:
		return soap_in_om__ModellingLayerType(soap, NULL, NULL, "om:ModellingLayerType");
	case SOAP_TYPE_om_om__BasicLayerType:
		return soap_in_om__BasicLayerType(soap, NULL, NULL, "om:BasicLayerType");
	case SOAP_TYPE_om_om__AvailableLayersType:
		return soap_in_om__AvailableLayersType(soap, NULL, NULL, "om:AvailableLayersType");
	case SOAP_TYPE_om_om__SerializedAlgorithmType:
		return soap_in_om__SerializedAlgorithmType(soap, NULL, NULL, "om:SerializedAlgorithmType");
	case SOAP_TYPE_om_om__BasicAlgorithmDefinitionType:
		return soap_in_om__BasicAlgorithmDefinitionType(soap, NULL, NULL, "om:BasicAlgorithmDefinitionType");
	case SOAP_TYPE_om_om__AlgorithmMetadataType:
		return soap_in_om__AlgorithmMetadataType(soap, NULL, NULL, "om:AlgorithmMetadataType");
	case SOAP_TYPE_om_om__AlgorithmsMetadataType:
		return soap_in_om__AlgorithmsMetadataType(soap, NULL, NULL, "om:AlgorithmsMetadataType");
	case SOAP_TYPE_om_om__AvailableAlgorithmsType:
		return soap_in_om__AvailableAlgorithmsType(soap, NULL, NULL, "om:AvailableAlgorithmsType");
	case SOAP_TYPE_om_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_om_xsd__IDREF:
		return soap_in_xsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
	case SOAP_TYPE_om_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_om_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_om_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_om_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_om_PointerToom__ReferenceType:
		return soap_in_PointerToom__ReferenceType(soap, NULL, NULL, "om:ReferenceType");
	case SOAP_TYPE_om_PointerTo_om__ResultSetType_Job_ProjectionEnvelope:
		return soap_in_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, NULL, NULL, "om:ResultSetType-Job-ProjectionEnvelope");
	case SOAP_TYPE_om_PointerToom__ProjectionEnvelopeType:
		return soap_in_PointerToom__ProjectionEnvelopeType(soap, NULL, NULL, "om:ProjectionEnvelopeType");
	case SOAP_TYPE_om_PointerToom__TestResultEnvelopeType:
		return soap_in_PointerToom__TestResultEnvelopeType(soap, NULL, NULL, "om:TestResultEnvelopeType");
	case SOAP_TYPE_om_PointerToom__ModelEnvelopeType:
		return soap_in_PointerToom__ModelEnvelopeType(soap, NULL, NULL, "om:ModelEnvelopeType");
	case SOAP_TYPE_om_PointerToom__ProjectModelJobType:
		return soap_in_PointerToom__ProjectModelJobType(soap, NULL, NULL, "om:ProjectModelJobType");
	case SOAP_TYPE_om_PointerToom__TestModelJobType:
		return soap_in_PointerToom__TestModelJobType(soap, NULL, NULL, "om:TestModelJobType");
	case SOAP_TYPE_om_PointerToom__CreateModelJobType:
		return soap_in_PointerToom__CreateModelJobType(soap, NULL, NULL, "om:CreateModelJobType");
	case SOAP_TYPE_om_PointerToom__SamplingJobType:
		return soap_in_PointerToom__SamplingJobType(soap, NULL, NULL, "om:SamplingJobType");
	case SOAP_TYPE_om_PointerToom__SamplingOptionsType:
		return soap_in_PointerToom__SamplingOptionsType(soap, NULL, NULL, "om:SamplingOptionsType");
	case SOAP_TYPE_om_PointerToom__ProjectionStatisticsParametersType:
		return soap_in_PointerToom__ProjectionStatisticsParametersType(soap, NULL, NULL, "om:ProjectionStatisticsParametersType");
	case SOAP_TYPE_om_PointerToom__MapOutputParametersType:
		return soap_in_PointerToom__MapOutputParametersType(soap, NULL, NULL, "om:MapOutputParametersType");
	case SOAP_TYPE_om_PointerToom__TestOptionsType:
		return soap_in_PointerToom__TestOptionsType(soap, NULL, NULL, "om:TestOptionsType");
	case SOAP_TYPE_om_PointerToom__TestResultType:
		return soap_in_PointerToom__TestResultType(soap, NULL, NULL, "om:TestResultType");
	case SOAP_TYPE_om_PointerToom__SerializedAlgorithmType:
		return soap_in_PointerToom__SerializedAlgorithmType(soap, NULL, NULL, "om:SerializedAlgorithmType");
	case SOAP_TYPE_om_PointerToom__SerializedModelType:
		return soap_in_PointerToom__SerializedModelType(soap, NULL, NULL, "om:SerializedModelType");
	case SOAP_TYPE_om_PointerToom__OccurrencesFilterType:
		return soap_in_PointerToom__OccurrencesFilterType(soap, NULL, NULL, "om:OccurrencesFilterType");
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique:
		return soap_in_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, NULL, NULL, "om:OccurrencesFilterType-EnvironmentallyUnique");
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_SpatiallyUnique:
		return soap_in_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, NULL, NULL, "om:OccurrencesFilterType-SpatiallyUnique");
	case SOAP_TYPE_om_PointerToom__ModelOptionsType:
		return soap_in_PointerToom__ModelOptionsType(soap, NULL, NULL, "om:ModelOptionsType");
	case SOAP_TYPE_om_PointerToom__BasicAlgorithmDefinitionType:
		return soap_in_PointerToom__BasicAlgorithmDefinitionType(soap, NULL, NULL, "om:BasicAlgorithmDefinitionType");
	case SOAP_TYPE_om_PointerToom__SamplerType:
		return soap_in_PointerToom__SamplerType(soap, NULL, NULL, "om:SamplerType");
	case SOAP_TYPE_om_PointerToom__AreaStatisticsType:
		return soap_in_PointerToom__AreaStatisticsType(soap, NULL, NULL, "om:AreaStatisticsType");
	case SOAP_TYPE_om_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics:
		return soap_in_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, NULL, NULL, "om:ProjectionStatisticsParametersType-AreaStatistics");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve:
		return soap_in_PointerTo_om__TestResultType_RocCurve(soap, NULL, NULL, "om:TestResultType-RocCurve");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve_Ratio:
		return soap_in_PointerTo_om__TestResultType_RocCurve_Ratio(soap, NULL, NULL, "om:TestResultType-RocCurve-Ratio");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_ConfusionMatrix:
		return soap_in_PointerTo_om__TestResultType_ConfusionMatrix(soap, NULL, NULL, "om:TestResultType-ConfusionMatrix");
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_RocCurve:
		return soap_in_PointerTo_om__TestOptionsType_RocCurve(soap, NULL, NULL, "om:TestOptionsType-RocCurve");
	case SOAP_TYPE_om_PointerToom__ZeroOneIntervalType:
		return soap_in_PointerToom__ZeroOneIntervalType(soap, NULL, NULL, "om:ZeroOneIntervalType");
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_ConfusionMatrix:
		return soap_in_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, NULL, NULL, "om:TestOptionsType-ConfusionMatrix");
	case SOAP_TYPE_om_PointerToom__ThresholdParameterType:
		return soap_in_PointerToom__ThresholdParameterType(soap, NULL, NULL, "om:ThresholdParameterType");
	case SOAP_TYPE_om_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_om_PointerToom__OccurrencesType:
		return soap_in_PointerToom__OccurrencesType(soap, NULL, NULL, "om:OccurrencesType");
	case SOAP_TYPE_om_PointerToom__EnvironmentType:
		return soap_in_PointerToom__EnvironmentType(soap, NULL, NULL, "om:EnvironmentType");
	case SOAP_TYPE_om_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_om_PointerToom__BasicLayerType:
		return soap_in_PointerToom__BasicLayerType(soap, NULL, NULL, "om:BasicLayerType");
	case SOAP_TYPE_om_PointerToom__ModellingLayerType:
		return soap_in_PointerToom__ModellingLayerType(soap, NULL, NULL, "om:ModellingLayerType");
	case SOAP_TYPE_om_PointerToom__LayerMetadataType:
		return soap_in_PointerToom__LayerMetadataType(soap, NULL, NULL, "om:LayerMetadataType");
	case SOAP_TYPE_om_PointerToom__LayersGroupType:
		return soap_in_PointerToom__LayersGroupType(soap, NULL, NULL, "om:LayersGroupType");
	case SOAP_TYPE_om_PointerToom__NormalizationType:
		return soap_in_PointerToom__NormalizationType(soap, NULL, NULL, "om:NormalizationType");
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		return soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, NULL, NULL, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues");
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		return soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, NULL, NULL, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange");
	case SOAP_TYPE_om_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_om_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_om_PointerToom__AlgorithmMetadataType:
		return soap_in_PointerToom__AlgorithmMetadataType(soap, NULL, NULL, "om:AlgorithmMetadataType");
	case SOAP_TYPE_om_PointerToom__AlgorithmsMetadataType:
		return soap_in_PointerToom__AlgorithmsMetadataType(soap, NULL, NULL, "om:AlgorithmsMetadataType");
	case SOAP_TYPE_om__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_om_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "om:ThresholdParameterType"))
		{	*type = SOAP_TYPE_om_om__ThresholdParameterType;
			return soap_in_om__ThresholdParameterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ResultSetType"))
		{	*type = SOAP_TYPE_om_om__ResultSetType;
			return soap_in_om__ResultSetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:JobTicketsType"))
		{	*type = SOAP_TYPE_om_om__JobTicketsType;
			return soap_in_om__JobTicketsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectModelJobType"))
		{	*type = SOAP_TYPE_om_om__ProjectModelJobType;
			return soap_in_om__ProjectModelJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestModelJobType"))
		{	*type = SOAP_TYPE_om_om__TestModelJobType;
			return soap_in_om__TestModelJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:CreateModelJobType"))
		{	*type = SOAP_TYPE_om_om__CreateModelJobType;
			return soap_in_om__CreateModelJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplingJobType"))
		{	*type = SOAP_TYPE_om_om__SamplingJobType;
			return soap_in_om__SamplingJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:IdentifiedType"))
		{	*type = SOAP_TYPE_om_om__IdentifiedType;
			return soap_in_om__IdentifiedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ReferenceType"))
		{	*type = SOAP_TYPE_om_om__ReferenceType;
			return soap_in_om__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType"))
		{	*type = SOAP_TYPE_om_om__ExperimentParametersType;
			return soap_in_om__ExperimentParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplingParametersType"))
		{	*type = SOAP_TYPE_om_om__SamplingParametersType;
			return soap_in_om__SamplingParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplingOptionsType"))
		{	*type = SOAP_TYPE_om_om__SamplingOptionsType;
			return soap_in_om__SamplingOptionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEvaluationResultType"))
		{	*type = SOAP_TYPE_om_om__ModelEvaluationResultType;
			return soap_in_om__ModelEvaluationResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEvaluationParametersType"))
		{	*type = SOAP_TYPE_om_om__ModelEvaluationParametersType;
			return soap_in_om__ModelEvaluationParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionParametersType"))
		{	*type = SOAP_TYPE_om_om__ProjectionParametersType;
			return soap_in_om__ProjectionParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultEnvelopeType"))
		{	*type = SOAP_TYPE_om_om__TestResultEnvelopeType;
			return soap_in_om__TestResultEnvelopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestParametersType"))
		{	*type = SOAP_TYPE_om_om__TestParametersType;
			return soap_in_om__TestParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedModelType"))
		{	*type = SOAP_TYPE_om_om__SerializedModelType;
			return soap_in_om__SerializedModelType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEnvelopeType"))
		{	*type = SOAP_TYPE_om_om__ModelEnvelopeType;
			return soap_in_om__ModelEnvelopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelOptionsType"))
		{	*type = SOAP_TYPE_om_om__ModelOptionsType;
			return soap_in_om__ModelOptionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:OccurrencesFilterType"))
		{	*type = SOAP_TYPE_om_om__OccurrencesFilterType;
			return soap_in_om__OccurrencesFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelParametersType"))
		{	*type = SOAP_TYPE_om_om__ModelParametersType;
			return soap_in_om__ModelParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:MapOutputParametersType"))
		{	*type = SOAP_TYPE_om_om__MapOutputParametersType;
			return soap_in_om__MapOutputParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AreaStatisticsType"))
		{	*type = SOAP_TYPE_om_om__AreaStatisticsType;
			return soap_in_om__AreaStatisticsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionEnvelopeType"))
		{	*type = SOAP_TYPE_om_om__ProjectionEnvelopeType;
			return soap_in_om__ProjectionEnvelopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionStatisticsParametersType"))
		{	*type = SOAP_TYPE_om_om__ProjectionStatisticsParametersType;
			return soap_in_om__ProjectionStatisticsParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultType"))
		{	*type = SOAP_TYPE_om_om__TestResultType;
			return soap_in_om__TestResultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestOptionsType"))
		{	*type = SOAP_TYPE_om_om__TestOptionsType;
			return soap_in_om__TestOptionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:NormalizationType"))
		{	*type = SOAP_TYPE_om_om__NormalizationType;
			return soap_in_om__NormalizationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplerType"))
		{	*type = SOAP_TYPE_om_om__SamplerType;
			return soap_in_om__SamplerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:OccurrencesType"))
		{	*type = SOAP_TYPE_om_om__OccurrencesType;
			return soap_in_om__OccurrencesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:EnvironmentType"))
		{	*type = SOAP_TYPE_om_om__EnvironmentType;
			return soap_in_om__EnvironmentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:LayersGroupType"))
		{	*type = SOAP_TYPE_om_om__LayersGroupType;
			return soap_in_om__LayersGroupType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:LayerMetadataType"))
		{	*type = SOAP_TYPE_om_om__LayerMetadataType;
			return soap_in_om__LayerMetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModellingLayerType"))
		{	*type = SOAP_TYPE_om_om__ModellingLayerType;
			return soap_in_om__ModellingLayerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:BasicLayerType"))
		{	*type = SOAP_TYPE_om_om__BasicLayerType;
			return soap_in_om__BasicLayerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AvailableLayersType"))
		{	*type = SOAP_TYPE_om_om__AvailableLayersType;
			return soap_in_om__AvailableLayersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedAlgorithmType"))
		{	*type = SOAP_TYPE_om_om__SerializedAlgorithmType;
			return soap_in_om__SerializedAlgorithmType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:BasicAlgorithmDefinitionType"))
		{	*type = SOAP_TYPE_om_om__BasicAlgorithmDefinitionType;
			return soap_in_om__BasicAlgorithmDefinitionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType"))
		{	*type = SOAP_TYPE_om_om__AlgorithmMetadataType;
			return soap_in_om__AlgorithmMetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmsMetadataType"))
		{	*type = SOAP_TYPE_om_om__AlgorithmsMetadataType;
			return soap_in_om__AlgorithmsMetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AvailableAlgorithmsType"))
		{	*type = SOAP_TYPE_om_om__AvailableAlgorithmsType;
			return soap_in_om__AvailableAlgorithmsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_om_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_om_xsd__IDREF;
			return soap_in_xsd__IDREF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_om_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_om_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_om_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_om_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ZeroOneIntervalType"))
		{	*type = SOAP_TYPE_om_om__ZeroOneIntervalType;
			return soap_in_om__ZeroOneIntervalType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_om_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_om_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ThresholdCalculationType"))
		{	*type = SOAP_TYPE_om_om__ThresholdCalculationType;
			return soap_in_om__ThresholdCalculationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_om_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_om_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_om__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_om_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "om:ProjectModelJob"))
		{	*type = SOAP_TYPE_om__om__ProjectModelJob;
			return soap_in__om__ProjectModelJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestModelJob"))
		{	*type = SOAP_TYPE_om__om__TestModelJob;
			return soap_in__om__TestModelJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:CreateModelJob"))
		{	*type = SOAP_TYPE_om__om__CreateModelJob;
			return soap_in__om__CreateModelJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplingJob"))
		{	*type = SOAP_TYPE_om__om__SamplingJob;
			return soap_in__om__SamplingJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ResultSet"))
		{	*type = SOAP_TYPE_om__om__ResultSet;
			return soap_in__om__ResultSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentTickets"))
		{	*type = SOAP_TYPE_om__om__ExperimentTickets;
			return soap_in__om__ExperimentTickets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParameters"))
		{	*type = SOAP_TYPE_om__om__ExperimentParameters;
			return soap_in__om__ExperimentParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:Sampler"))
		{	*type = SOAP_TYPE_om__om__Sampler;
			return soap_in__om__Sampler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SamplingParameters"))
		{	*type = SOAP_TYPE_om__om__SamplingParameters;
			return soap_in__om__SamplingParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEvaluation"))
		{	*type = SOAP_TYPE_om__om__ModelEvaluation;
			return soap_in__om__ModelEvaluation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEvaluationParameters"))
		{	*type = SOAP_TYPE_om__om__ModelEvaluationParameters;
			return soap_in__om__ModelEvaluationParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionEnvelope"))
		{	*type = SOAP_TYPE_om__om__ProjectionEnvelope;
			return soap_in__om__ProjectionEnvelope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionParameters"))
		{	*type = SOAP_TYPE_om__om__ProjectionParameters;
			return soap_in__om__ProjectionParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedModel"))
		{	*type = SOAP_TYPE_om__om__SerializedModel;
			return soap_in__om__SerializedModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultEnvelope"))
		{	*type = SOAP_TYPE_om__om__TestResultEnvelope;
			return soap_in__om__TestResultEnvelope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestParameters"))
		{	*type = SOAP_TYPE_om__om__TestParameters;
			return soap_in__om__TestParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEnvelope"))
		{	*type = SOAP_TYPE_om__om__ModelEnvelope;
			return soap_in__om__ModelEnvelope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelParameters"))
		{	*type = SOAP_TYPE_om__om__ModelParameters;
			return soap_in__om__ModelParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AvailableLayers"))
		{	*type = SOAP_TYPE_om__om__AvailableLayers;
			return soap_in__om__AvailableLayers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:Algorithms"))
		{	*type = SOAP_TYPE_om__om__Algorithms;
			return soap_in__om__Algorithms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AvailableAlgorithms"))
		{	*type = SOAP_TYPE_om__om__AvailableAlgorithms;
			return soap_in__om__AvailableAlgorithms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ResultSetType-Job-ProjectionEnvelope"))
		{	*type = SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope;
			return soap_in__om__ResultSetType_Job_ProjectionEnvelope(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ResultSetType-Job"))
		{	*type = SOAP_TYPE_om__om__ResultSetType_Job;
			return soap_in__om__ResultSetType_Job(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:JobTicketsType-Job"))
		{	*type = SOAP_TYPE_om__om__JobTicketsType_Job;
			return soap_in__om__JobTicketsType_Job(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Jobs"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Jobs;
			return soap_in__om__ExperimentParametersType_Jobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-SerializedAlgorithm"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm;
			return soap_in__om__ExperimentParametersType_SerializedAlgorithm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-AlgorithmSettings"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings;
			return soap_in__om__ExperimentParametersType_AlgorithmSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Absence-Point"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point;
			return soap_in__om__ExperimentParametersType_Absence_Point(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Absence"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Absence;
			return soap_in__om__ExperimentParametersType_Absence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Presence-Point"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point;
			return soap_in__om__ExperimentParametersType_Presence_Point(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Presence"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Presence;
			return soap_in__om__ExperimentParametersType_Presence(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ExperimentParametersType-Environment"))
		{	*type = SOAP_TYPE_om__om__ExperimentParametersType_Environment;
			return soap_in__om__ExperimentParametersType_Environment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ModelEvaluationResultType-Values"))
		{	*type = SOAP_TYPE_om__om__ModelEvaluationResultType_Values;
			return soap_in__om__ModelEvaluationResultType_Values(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:OccurrencesFilterType-EnvironmentallyUnique"))
		{	*type = SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique;
			return soap_in__om__OccurrencesFilterType_EnvironmentallyUnique(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:OccurrencesFilterType-SpatiallyUnique"))
		{	*type = SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique;
			return soap_in__om__OccurrencesFilterType_SpatiallyUnique(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:ProjectionStatisticsParametersType-AreaStatistics"))
		{	*type = SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics;
			return soap_in__om__ProjectionStatisticsParametersType_AreaStatistics(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultType-RocCurve-Ratio"))
		{	*type = SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio;
			return soap_in__om__TestResultType_RocCurve_Ratio(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultType-RocCurve"))
		{	*type = SOAP_TYPE_om__om__TestResultType_RocCurve;
			return soap_in__om__TestResultType_RocCurve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestResultType-ConfusionMatrix"))
		{	*type = SOAP_TYPE_om__om__TestResultType_ConfusionMatrix;
			return soap_in__om__TestResultType_ConfusionMatrix(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestOptionsType-RocCurve"))
		{	*type = SOAP_TYPE_om__om__TestOptionsType_RocCurve;
			return soap_in__om__TestOptionsType_RocCurve(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:TestOptionsType-ConfusionMatrix"))
		{	*type = SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix;
			return soap_in__om__TestOptionsType_ConfusionMatrix(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:OccurrencesType-Point"))
		{	*type = SOAP_TYPE_om__om__OccurrencesType_Point;
			return soap_in__om__OccurrencesType_Point(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedAlgorithmType-Model"))
		{	*type = SOAP_TYPE_om__om__SerializedAlgorithmType_Model;
			return soap_in__om__SerializedAlgorithmType_Model(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedAlgorithmType-Parameters-Parameter"))
		{	*type = SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter;
			return soap_in__om__SerializedAlgorithmType_Parameters_Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:SerializedAlgorithmType-Parameters"))
		{	*type = SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters;
			return soap_in__om__SerializedAlgorithmType_Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:BasicAlgorithmDefinitionType-Parameters-Parameter"))
		{	*type = SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter;
			return soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:BasicAlgorithmDefinitionType-Parameters"))
		{	*type = SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters;
			return soap_in__om__BasicAlgorithmDefinitionType_Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues;
			return soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange;
			return soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Parameters-Parameter"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter;
			return soap_in__om__AlgorithmMetadataType_Parameters_Parameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Parameters"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters;
			return soap_in__om__AlgorithmMetadataType_Parameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Developers-Developer"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer;
			return soap_in__om__AlgorithmMetadataType_Developers_Developer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Developers"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Developers;
			return soap_in__om__AlgorithmMetadataType_Developers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Designers-Designer"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer;
			return soap_in__om__AlgorithmMetadataType_Designers_Designer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "om:AlgorithmMetadataType-Designers"))
		{	*type = SOAP_TYPE_om__om__AlgorithmMetadataType_Designers;
			return soap_in__om__AlgorithmMetadataType_Designers(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_om_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_om_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_om_om__ZeroOneIntervalType:
		return soap_out_om__ZeroOneIntervalType(soap, tag, id, (const double *)ptr, "om:ZeroOneIntervalType");
	case SOAP_TYPE_om_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_om_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_om_om__ThresholdCalculationType:
		return soap_out_om__ThresholdCalculationType(soap, tag, id, (const enum om__ThresholdCalculationType *)ptr, "om:ThresholdCalculationType");
	case SOAP_TYPE_om__om__ProjectModelJob:
		return soap_out__om__ProjectModelJob(soap, "om:ProjectModelJob", id, (const om__ProjectModelJobType *)ptr, NULL);
	case SOAP_TYPE_om__om__TestModelJob:
		return soap_out__om__TestModelJob(soap, "om:TestModelJob", id, (const om__TestModelJobType *)ptr, NULL);
	case SOAP_TYPE_om__om__CreateModelJob:
		return soap_out__om__CreateModelJob(soap, "om:CreateModelJob", id, (const om__CreateModelJobType *)ptr, NULL);
	case SOAP_TYPE_om__om__SamplingJob:
		return soap_out__om__SamplingJob(soap, "om:SamplingJob", id, (const om__SamplingJobType *)ptr, NULL);
	case SOAP_TYPE_om__om__ResultSet:
		return soap_out__om__ResultSet(soap, "om:ResultSet", id, (const om__ResultSetType *)ptr, NULL);
	case SOAP_TYPE_om__om__ExperimentTickets:
		return soap_out__om__ExperimentTickets(soap, "om:ExperimentTickets", id, (const om__JobTicketsType *)ptr, NULL);
	case SOAP_TYPE_om__om__ExperimentParameters:
		return soap_out__om__ExperimentParameters(soap, "om:ExperimentParameters", id, (const om__ExperimentParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__Sampler:
		return soap_out__om__Sampler(soap, "om:Sampler", id, (const om__SamplerType *)ptr, NULL);
	case SOAP_TYPE_om__om__SamplingParameters:
		return soap_out__om__SamplingParameters(soap, "om:SamplingParameters", id, (const om__SamplingParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__ModelEvaluation:
		return soap_out__om__ModelEvaluation(soap, "om:ModelEvaluation", id, (const om__ModelEvaluationResultType *)ptr, NULL);
	case SOAP_TYPE_om__om__ModelEvaluationParameters:
		return soap_out__om__ModelEvaluationParameters(soap, "om:ModelEvaluationParameters", id, (const om__ModelEvaluationParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__ProjectionEnvelope:
		return soap_out__om__ProjectionEnvelope(soap, "om:ProjectionEnvelope", id, (const om__ProjectionEnvelopeType *)ptr, NULL);
	case SOAP_TYPE_om__om__ProjectionParameters:
		return soap_out__om__ProjectionParameters(soap, "om:ProjectionParameters", id, (const om__ProjectionParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__SerializedModel:
		return soap_out__om__SerializedModel(soap, "om:SerializedModel", id, (const om__SerializedModelType *)ptr, NULL);
	case SOAP_TYPE_om__om__TestResultEnvelope:
		return soap_out__om__TestResultEnvelope(soap, "om:TestResultEnvelope", id, (const om__TestResultEnvelopeType *)ptr, NULL);
	case SOAP_TYPE_om__om__TestParameters:
		return soap_out__om__TestParameters(soap, "om:TestParameters", id, (const om__TestParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__ModelEnvelope:
		return soap_out__om__ModelEnvelope(soap, "om:ModelEnvelope", id, (const om__ModelEnvelopeType *)ptr, NULL);
	case SOAP_TYPE_om__om__ModelParameters:
		return soap_out__om__ModelParameters(soap, "om:ModelParameters", id, (const om__ModelParametersType *)ptr, NULL);
	case SOAP_TYPE_om__om__AvailableLayers:
		return soap_out__om__AvailableLayers(soap, "om:AvailableLayers", id, (const om__AvailableLayersType *)ptr, NULL);
	case SOAP_TYPE_om__om__Algorithms:
		return soap_out__om__Algorithms(soap, "om:Algorithms", id, (const om__AlgorithmsMetadataType *)ptr, NULL);
	case SOAP_TYPE_om__om__AvailableAlgorithms:
		return soap_out__om__AvailableAlgorithms(soap, "om:AvailableAlgorithms", id, (const om__AvailableAlgorithmsType *)ptr, NULL);
	case SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope:
		return ((_om__ResultSetType_Job_ProjectionEnvelope *)ptr)->soap_out(soap, "om:ResultSetType-Job-ProjectionEnvelope", id, NULL);
	case SOAP_TYPE_om__om__ResultSetType_Job:
		return ((_om__ResultSetType_Job *)ptr)->soap_out(soap, "om:ResultSetType-Job", id, NULL);
	case SOAP_TYPE_om__om__JobTicketsType_Job:
		return ((_om__JobTicketsType_Job *)ptr)->soap_out(soap, "om:JobTicketsType-Job", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Jobs:
		return ((_om__ExperimentParametersType_Jobs *)ptr)->soap_out(soap, "om:ExperimentParametersType-Jobs", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm:
		return ((_om__ExperimentParametersType_SerializedAlgorithm *)ptr)->soap_out(soap, "om:ExperimentParametersType-SerializedAlgorithm", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings:
		return ((_om__ExperimentParametersType_AlgorithmSettings *)ptr)->soap_out(soap, "om:ExperimentParametersType-AlgorithmSettings", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point:
		return ((_om__ExperimentParametersType_Absence_Point *)ptr)->soap_out(soap, "om:ExperimentParametersType-Absence-Point", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence:
		return ((_om__ExperimentParametersType_Absence *)ptr)->soap_out(soap, "om:ExperimentParametersType-Absence", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point:
		return ((_om__ExperimentParametersType_Presence_Point *)ptr)->soap_out(soap, "om:ExperimentParametersType-Presence-Point", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence:
		return ((_om__ExperimentParametersType_Presence *)ptr)->soap_out(soap, "om:ExperimentParametersType-Presence", id, NULL);
	case SOAP_TYPE_om__om__ExperimentParametersType_Environment:
		return ((_om__ExperimentParametersType_Environment *)ptr)->soap_out(soap, "om:ExperimentParametersType-Environment", id, NULL);
	case SOAP_TYPE_om__om__ModelEvaluationResultType_Values:
		return ((_om__ModelEvaluationResultType_Values *)ptr)->soap_out(soap, "om:ModelEvaluationResultType-Values", id, NULL);
	case SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique:
		return ((_om__OccurrencesFilterType_EnvironmentallyUnique *)ptr)->soap_out(soap, "om:OccurrencesFilterType-EnvironmentallyUnique", id, NULL);
	case SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique:
		return ((_om__OccurrencesFilterType_SpatiallyUnique *)ptr)->soap_out(soap, "om:OccurrencesFilterType-SpatiallyUnique", id, NULL);
	case SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics:
		return ((_om__ProjectionStatisticsParametersType_AreaStatistics *)ptr)->soap_out(soap, "om:ProjectionStatisticsParametersType-AreaStatistics", id, NULL);
	case SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio:
		return ((_om__TestResultType_RocCurve_Ratio *)ptr)->soap_out(soap, "om:TestResultType-RocCurve-Ratio", id, NULL);
	case SOAP_TYPE_om__om__TestResultType_RocCurve:
		return ((_om__TestResultType_RocCurve *)ptr)->soap_out(soap, "om:TestResultType-RocCurve", id, NULL);
	case SOAP_TYPE_om__om__TestResultType_ConfusionMatrix:
		return ((_om__TestResultType_ConfusionMatrix *)ptr)->soap_out(soap, "om:TestResultType-ConfusionMatrix", id, NULL);
	case SOAP_TYPE_om__om__TestOptionsType_RocCurve:
		return ((_om__TestOptionsType_RocCurve *)ptr)->soap_out(soap, "om:TestOptionsType-RocCurve", id, NULL);
	case SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix:
		return ((_om__TestOptionsType_ConfusionMatrix *)ptr)->soap_out(soap, "om:TestOptionsType-ConfusionMatrix", id, NULL);
	case SOAP_TYPE_om__om__OccurrencesType_Point:
		return ((_om__OccurrencesType_Point *)ptr)->soap_out(soap, "om:OccurrencesType-Point", id, NULL);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Model:
		return ((_om__SerializedAlgorithmType_Model *)ptr)->soap_out(soap, "om:SerializedAlgorithmType-Model", id, NULL);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter:
		return ((_om__SerializedAlgorithmType_Parameters_Parameter *)ptr)->soap_out(soap, "om:SerializedAlgorithmType-Parameters-Parameter", id, NULL);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters:
		return ((_om__SerializedAlgorithmType_Parameters *)ptr)->soap_out(soap, "om:SerializedAlgorithmType-Parameters", id, NULL);
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		return ((_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)ptr)->soap_out(soap, "om:BasicAlgorithmDefinitionType-Parameters-Parameter", id, NULL);
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters:
		return ((_om__BasicAlgorithmDefinitionType_Parameters *)ptr)->soap_out(soap, "om:BasicAlgorithmDefinitionType-Parameters", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		return ((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		return ((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter:
		return ((_om__AlgorithmMetadataType_Parameters_Parameter *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Parameters-Parameter", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters:
		return ((_om__AlgorithmMetadataType_Parameters *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Parameters", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer:
		return ((_om__AlgorithmMetadataType_Developers_Developer *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Developers-Developer", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers:
		return ((_om__AlgorithmMetadataType_Developers *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Developers", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer:
		return ((_om__AlgorithmMetadataType_Designers_Designer *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Designers-Designer", id, NULL);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers:
		return ((_om__AlgorithmMetadataType_Designers *)ptr)->soap_out(soap, "om:AlgorithmMetadataType-Designers", id, NULL);
	case SOAP_TYPE_om_om__ThresholdParameterType:
		return soap_out_om__ThresholdParameterType(soap, tag, id, (const std::string *)ptr, "om:ThresholdParameterType");
	case SOAP_TYPE_om_om__ResultSetType:
		return ((om__ResultSetType *)ptr)->soap_out(soap, tag, id, "om:ResultSetType");
	case SOAP_TYPE_om_om__JobTicketsType:
		return ((om__JobTicketsType *)ptr)->soap_out(soap, tag, id, "om:JobTicketsType");
	case SOAP_TYPE_om_om__ProjectModelJobType:
		return ((om__ProjectModelJobType *)ptr)->soap_out(soap, tag, id, "om:ProjectModelJobType");
	case SOAP_TYPE_om_om__TestModelJobType:
		return ((om__TestModelJobType *)ptr)->soap_out(soap, tag, id, "om:TestModelJobType");
	case SOAP_TYPE_om_om__CreateModelJobType:
		return ((om__CreateModelJobType *)ptr)->soap_out(soap, tag, id, "om:CreateModelJobType");
	case SOAP_TYPE_om_om__SamplingJobType:
		return ((om__SamplingJobType *)ptr)->soap_out(soap, tag, id, "om:SamplingJobType");
	case SOAP_TYPE_om_om__IdentifiedType:
		return ((om__IdentifiedType *)ptr)->soap_out(soap, tag, id, "om:IdentifiedType");
	case SOAP_TYPE_om_om__ReferenceType:
		return ((om__ReferenceType *)ptr)->soap_out(soap, tag, id, "om:ReferenceType");
	case SOAP_TYPE_om_om__ExperimentParametersType:
		return ((om__ExperimentParametersType *)ptr)->soap_out(soap, tag, id, "om:ExperimentParametersType");
	case SOAP_TYPE_om_om__SamplingParametersType:
		return ((om__SamplingParametersType *)ptr)->soap_out(soap, tag, id, "om:SamplingParametersType");
	case SOAP_TYPE_om_om__SamplingOptionsType:
		return ((om__SamplingOptionsType *)ptr)->soap_out(soap, tag, id, "om:SamplingOptionsType");
	case SOAP_TYPE_om_om__ModelEvaluationResultType:
		return ((om__ModelEvaluationResultType *)ptr)->soap_out(soap, tag, id, "om:ModelEvaluationResultType");
	case SOAP_TYPE_om_om__ModelEvaluationParametersType:
		return ((om__ModelEvaluationParametersType *)ptr)->soap_out(soap, tag, id, "om:ModelEvaluationParametersType");
	case SOAP_TYPE_om_om__ProjectionParametersType:
		return ((om__ProjectionParametersType *)ptr)->soap_out(soap, tag, id, "om:ProjectionParametersType");
	case SOAP_TYPE_om_om__TestResultEnvelopeType:
		return ((om__TestResultEnvelopeType *)ptr)->soap_out(soap, tag, id, "om:TestResultEnvelopeType");
	case SOAP_TYPE_om_om__TestParametersType:
		return ((om__TestParametersType *)ptr)->soap_out(soap, tag, id, "om:TestParametersType");
	case SOAP_TYPE_om_om__SerializedModelType:
		return ((om__SerializedModelType *)ptr)->soap_out(soap, tag, id, "om:SerializedModelType");
	case SOAP_TYPE_om_om__ModelEnvelopeType:
		return ((om__ModelEnvelopeType *)ptr)->soap_out(soap, tag, id, "om:ModelEnvelopeType");
	case SOAP_TYPE_om_om__ModelOptionsType:
		return ((om__ModelOptionsType *)ptr)->soap_out(soap, tag, id, "om:ModelOptionsType");
	case SOAP_TYPE_om_om__OccurrencesFilterType:
		return ((om__OccurrencesFilterType *)ptr)->soap_out(soap, tag, id, "om:OccurrencesFilterType");
	case SOAP_TYPE_om_om__ModelParametersType:
		return ((om__ModelParametersType *)ptr)->soap_out(soap, tag, id, "om:ModelParametersType");
	case SOAP_TYPE_om_om__MapOutputParametersType:
		return ((om__MapOutputParametersType *)ptr)->soap_out(soap, tag, id, "om:MapOutputParametersType");
	case SOAP_TYPE_om_om__AreaStatisticsType:
		return ((om__AreaStatisticsType *)ptr)->soap_out(soap, tag, id, "om:AreaStatisticsType");
	case SOAP_TYPE_om_om__ProjectionEnvelopeType:
		return ((om__ProjectionEnvelopeType *)ptr)->soap_out(soap, tag, id, "om:ProjectionEnvelopeType");
	case SOAP_TYPE_om_om__ProjectionStatisticsParametersType:
		return ((om__ProjectionStatisticsParametersType *)ptr)->soap_out(soap, tag, id, "om:ProjectionStatisticsParametersType");
	case SOAP_TYPE_om_om__TestResultType:
		return ((om__TestResultType *)ptr)->soap_out(soap, tag, id, "om:TestResultType");
	case SOAP_TYPE_om_om__TestOptionsType:
		return ((om__TestOptionsType *)ptr)->soap_out(soap, tag, id, "om:TestOptionsType");
	case SOAP_TYPE_om_om__NormalizationType:
		return ((om__NormalizationType *)ptr)->soap_out(soap, tag, id, "om:NormalizationType");
	case SOAP_TYPE_om_om__SamplerType:
		return ((om__SamplerType *)ptr)->soap_out(soap, tag, id, "om:SamplerType");
	case SOAP_TYPE_om_om__OccurrencesType:
		return ((om__OccurrencesType *)ptr)->soap_out(soap, tag, id, "om:OccurrencesType");
	case SOAP_TYPE_om_om__EnvironmentType:
		return ((om__EnvironmentType *)ptr)->soap_out(soap, tag, id, "om:EnvironmentType");
	case SOAP_TYPE_om_om__LayersGroupType:
		return ((om__LayersGroupType *)ptr)->soap_out(soap, tag, id, "om:LayersGroupType");
	case SOAP_TYPE_om_om__LayerMetadataType:
		return ((om__LayerMetadataType *)ptr)->soap_out(soap, tag, id, "om:LayerMetadataType");
	case SOAP_TYPE_om_om__ModellingLayerType:
		return ((om__ModellingLayerType *)ptr)->soap_out(soap, tag, id, "om:ModellingLayerType");
	case SOAP_TYPE_om_om__BasicLayerType:
		return ((om__BasicLayerType *)ptr)->soap_out(soap, tag, id, "om:BasicLayerType");
	case SOAP_TYPE_om_om__AvailableLayersType:
		return ((om__AvailableLayersType *)ptr)->soap_out(soap, tag, id, "om:AvailableLayersType");
	case SOAP_TYPE_om_om__SerializedAlgorithmType:
		return ((om__SerializedAlgorithmType *)ptr)->soap_out(soap, tag, id, "om:SerializedAlgorithmType");
	case SOAP_TYPE_om_om__BasicAlgorithmDefinitionType:
		return ((om__BasicAlgorithmDefinitionType *)ptr)->soap_out(soap, tag, id, "om:BasicAlgorithmDefinitionType");
	case SOAP_TYPE_om_om__AlgorithmMetadataType:
		return ((om__AlgorithmMetadataType *)ptr)->soap_out(soap, tag, id, "om:AlgorithmMetadataType");
	case SOAP_TYPE_om_om__AlgorithmsMetadataType:
		return ((om__AlgorithmsMetadataType *)ptr)->soap_out(soap, tag, id, "om:AlgorithmsMetadataType");
	case SOAP_TYPE_om_om__AvailableAlgorithmsType:
		return ((om__AvailableAlgorithmsType *)ptr)->soap_out(soap, tag, id, "om:AvailableAlgorithmsType");
	case SOAP_TYPE_om_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_om_xsd__IDREF:
		return soap_out_xsd__IDREF(soap, tag, id, (const std::string *)ptr, "xsd:IDREF");
	case SOAP_TYPE_om_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_om_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_om_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_om_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE_om_PointerToom__ReferenceType:
		return soap_out_PointerToom__ReferenceType(soap, tag, id, (om__ReferenceType *const*)ptr, "om:ReferenceType");
	case SOAP_TYPE_om_PointerTo_om__ResultSetType_Job_ProjectionEnvelope:
		return soap_out_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, tag, id, (_om__ResultSetType_Job_ProjectionEnvelope *const*)ptr, "om:ResultSetType-Job-ProjectionEnvelope");
	case SOAP_TYPE_om_PointerToom__ProjectionEnvelopeType:
		return soap_out_PointerToom__ProjectionEnvelopeType(soap, tag, id, (om__ProjectionEnvelopeType *const*)ptr, "om:ProjectionEnvelopeType");
	case SOAP_TYPE_om_PointerToom__TestResultEnvelopeType:
		return soap_out_PointerToom__TestResultEnvelopeType(soap, tag, id, (om__TestResultEnvelopeType *const*)ptr, "om:TestResultEnvelopeType");
	case SOAP_TYPE_om_PointerToom__ModelEnvelopeType:
		return soap_out_PointerToom__ModelEnvelopeType(soap, tag, id, (om__ModelEnvelopeType *const*)ptr, "om:ModelEnvelopeType");
	case SOAP_TYPE_om_PointerToom__ProjectModelJobType:
		return soap_out_PointerToom__ProjectModelJobType(soap, tag, id, (om__ProjectModelJobType *const*)ptr, "om:ProjectModelJobType");
	case SOAP_TYPE_om_PointerToom__TestModelJobType:
		return soap_out_PointerToom__TestModelJobType(soap, tag, id, (om__TestModelJobType *const*)ptr, "om:TestModelJobType");
	case SOAP_TYPE_om_PointerToom__CreateModelJobType:
		return soap_out_PointerToom__CreateModelJobType(soap, tag, id, (om__CreateModelJobType *const*)ptr, "om:CreateModelJobType");
	case SOAP_TYPE_om_PointerToom__SamplingJobType:
		return soap_out_PointerToom__SamplingJobType(soap, tag, id, (om__SamplingJobType *const*)ptr, "om:SamplingJobType");
	case SOAP_TYPE_om_PointerToom__SamplingOptionsType:
		return soap_out_PointerToom__SamplingOptionsType(soap, tag, id, (om__SamplingOptionsType *const*)ptr, "om:SamplingOptionsType");
	case SOAP_TYPE_om_PointerToom__ProjectionStatisticsParametersType:
		return soap_out_PointerToom__ProjectionStatisticsParametersType(soap, tag, id, (om__ProjectionStatisticsParametersType *const*)ptr, "om:ProjectionStatisticsParametersType");
	case SOAP_TYPE_om_PointerToom__MapOutputParametersType:
		return soap_out_PointerToom__MapOutputParametersType(soap, tag, id, (om__MapOutputParametersType *const*)ptr, "om:MapOutputParametersType");
	case SOAP_TYPE_om_PointerToom__TestOptionsType:
		return soap_out_PointerToom__TestOptionsType(soap, tag, id, (om__TestOptionsType *const*)ptr, "om:TestOptionsType");
	case SOAP_TYPE_om_PointerToom__TestResultType:
		return soap_out_PointerToom__TestResultType(soap, tag, id, (om__TestResultType *const*)ptr, "om:TestResultType");
	case SOAP_TYPE_om_PointerToom__SerializedAlgorithmType:
		return soap_out_PointerToom__SerializedAlgorithmType(soap, tag, id, (om__SerializedAlgorithmType *const*)ptr, "om:SerializedAlgorithmType");
	case SOAP_TYPE_om_PointerToom__SerializedModelType:
		return soap_out_PointerToom__SerializedModelType(soap, tag, id, (om__SerializedModelType *const*)ptr, "om:SerializedModelType");
	case SOAP_TYPE_om_PointerToom__OccurrencesFilterType:
		return soap_out_PointerToom__OccurrencesFilterType(soap, tag, id, (om__OccurrencesFilterType *const*)ptr, "om:OccurrencesFilterType");
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique:
		return soap_out_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag, id, (_om__OccurrencesFilterType_EnvironmentallyUnique *const*)ptr, "om:OccurrencesFilterType-EnvironmentallyUnique");
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_SpatiallyUnique:
		return soap_out_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, tag, id, (_om__OccurrencesFilterType_SpatiallyUnique *const*)ptr, "om:OccurrencesFilterType-SpatiallyUnique");
	case SOAP_TYPE_om_PointerToom__ModelOptionsType:
		return soap_out_PointerToom__ModelOptionsType(soap, tag, id, (om__ModelOptionsType *const*)ptr, "om:ModelOptionsType");
	case SOAP_TYPE_om_PointerToom__BasicAlgorithmDefinitionType:
		return soap_out_PointerToom__BasicAlgorithmDefinitionType(soap, tag, id, (om__BasicAlgorithmDefinitionType *const*)ptr, "om:BasicAlgorithmDefinitionType");
	case SOAP_TYPE_om_PointerToom__SamplerType:
		return soap_out_PointerToom__SamplerType(soap, tag, id, (om__SamplerType *const*)ptr, "om:SamplerType");
	case SOAP_TYPE_om_PointerToom__AreaStatisticsType:
		return soap_out_PointerToom__AreaStatisticsType(soap, tag, id, (om__AreaStatisticsType *const*)ptr, "om:AreaStatisticsType");
	case SOAP_TYPE_om_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics:
		return soap_out_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag, id, (_om__ProjectionStatisticsParametersType_AreaStatistics *const*)ptr, "om:ProjectionStatisticsParametersType-AreaStatistics");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve:
		return soap_out_PointerTo_om__TestResultType_RocCurve(soap, tag, id, (_om__TestResultType_RocCurve *const*)ptr, "om:TestResultType-RocCurve");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve_Ratio:
		return soap_out_PointerTo_om__TestResultType_RocCurve_Ratio(soap, tag, id, (_om__TestResultType_RocCurve_Ratio *const*)ptr, "om:TestResultType-RocCurve-Ratio");
	case SOAP_TYPE_om_PointerTo_om__TestResultType_ConfusionMatrix:
		return soap_out_PointerTo_om__TestResultType_ConfusionMatrix(soap, tag, id, (_om__TestResultType_ConfusionMatrix *const*)ptr, "om:TestResultType-ConfusionMatrix");
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_RocCurve:
		return soap_out_PointerTo_om__TestOptionsType_RocCurve(soap, tag, id, (_om__TestOptionsType_RocCurve *const*)ptr, "om:TestOptionsType-RocCurve");
	case SOAP_TYPE_om_PointerToom__ZeroOneIntervalType:
		return soap_out_PointerToom__ZeroOneIntervalType(soap, tag, id, (double *const*)ptr, "om:ZeroOneIntervalType");
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_ConfusionMatrix:
		return soap_out_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, tag, id, (_om__TestOptionsType_ConfusionMatrix *const*)ptr, "om:TestOptionsType-ConfusionMatrix");
	case SOAP_TYPE_om_PointerToom__ThresholdParameterType:
		return soap_out_PointerToom__ThresholdParameterType(soap, tag, id, (std::string *const*)ptr, "om:ThresholdParameterType");
	case SOAP_TYPE_om_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_om_PointerToom__OccurrencesType:
		return soap_out_PointerToom__OccurrencesType(soap, tag, id, (om__OccurrencesType *const*)ptr, "om:OccurrencesType");
	case SOAP_TYPE_om_PointerToom__EnvironmentType:
		return soap_out_PointerToom__EnvironmentType(soap, tag, id, (om__EnvironmentType *const*)ptr, "om:EnvironmentType");
	case SOAP_TYPE_om_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_om_PointerToom__BasicLayerType:
		return soap_out_PointerToom__BasicLayerType(soap, tag, id, (om__BasicLayerType *const*)ptr, "om:BasicLayerType");
	case SOAP_TYPE_om_PointerToom__ModellingLayerType:
		return soap_out_PointerToom__ModellingLayerType(soap, tag, id, (om__ModellingLayerType *const*)ptr, "om:ModellingLayerType");
	case SOAP_TYPE_om_PointerToom__LayerMetadataType:
		return soap_out_PointerToom__LayerMetadataType(soap, tag, id, (om__LayerMetadataType *const*)ptr, "om:LayerMetadataType");
	case SOAP_TYPE_om_PointerToom__LayersGroupType:
		return soap_out_PointerToom__LayersGroupType(soap, tag, id, (om__LayersGroupType *const*)ptr, "om:LayersGroupType");
	case SOAP_TYPE_om_PointerToom__NormalizationType:
		return soap_out_PointerToom__NormalizationType(soap, tag, id, (om__NormalizationType *const*)ptr, "om:NormalizationType");
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		return soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag, id, (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *const*)ptr, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues");
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		return soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag, id, (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *const*)ptr, "om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange");
	case SOAP_TYPE_om_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_om_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_om_PointerToom__AlgorithmMetadataType:
		return soap_out_PointerToom__AlgorithmMetadataType(soap, tag, id, (om__AlgorithmMetadataType *const*)ptr, "om:AlgorithmMetadataType");
	case SOAP_TYPE_om_PointerToom__AlgorithmsMetadataType:
		return soap_out_PointerToom__AlgorithmsMetadataType(soap, tag, id, (om__AlgorithmsMetadataType *const*)ptr, "om:AlgorithmsMetadataType");
	case SOAP_TYPE_om__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_om_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_om__om__ProjectModelJob:
		soap_serialize__om__ProjectModelJob(soap, (const om__ProjectModelJobType *)ptr);
		break;
	case SOAP_TYPE_om__om__TestModelJob:
		soap_serialize__om__TestModelJob(soap, (const om__TestModelJobType *)ptr);
		break;
	case SOAP_TYPE_om__om__CreateModelJob:
		soap_serialize__om__CreateModelJob(soap, (const om__CreateModelJobType *)ptr);
		break;
	case SOAP_TYPE_om__om__SamplingJob:
		soap_serialize__om__SamplingJob(soap, (const om__SamplingJobType *)ptr);
		break;
	case SOAP_TYPE_om__om__ResultSet:
		soap_serialize__om__ResultSet(soap, (const om__ResultSetType *)ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentTickets:
		soap_serialize__om__ExperimentTickets(soap, (const om__JobTicketsType *)ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParameters:
		soap_serialize__om__ExperimentParameters(soap, (const om__ExperimentParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__Sampler:
		soap_serialize__om__Sampler(soap, (const om__SamplerType *)ptr);
		break;
	case SOAP_TYPE_om__om__SamplingParameters:
		soap_serialize__om__SamplingParameters(soap, (const om__SamplingParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__ModelEvaluation:
		soap_serialize__om__ModelEvaluation(soap, (const om__ModelEvaluationResultType *)ptr);
		break;
	case SOAP_TYPE_om__om__ModelEvaluationParameters:
		soap_serialize__om__ModelEvaluationParameters(soap, (const om__ModelEvaluationParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__ProjectionEnvelope:
		soap_serialize__om__ProjectionEnvelope(soap, (const om__ProjectionEnvelopeType *)ptr);
		break;
	case SOAP_TYPE_om__om__ProjectionParameters:
		soap_serialize__om__ProjectionParameters(soap, (const om__ProjectionParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__SerializedModel:
		soap_serialize__om__SerializedModel(soap, (const om__SerializedModelType *)ptr);
		break;
	case SOAP_TYPE_om__om__TestResultEnvelope:
		soap_serialize__om__TestResultEnvelope(soap, (const om__TestResultEnvelopeType *)ptr);
		break;
	case SOAP_TYPE_om__om__TestParameters:
		soap_serialize__om__TestParameters(soap, (const om__TestParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__ModelEnvelope:
		soap_serialize__om__ModelEnvelope(soap, (const om__ModelEnvelopeType *)ptr);
		break;
	case SOAP_TYPE_om__om__ModelParameters:
		soap_serialize__om__ModelParameters(soap, (const om__ModelParametersType *)ptr);
		break;
	case SOAP_TYPE_om__om__AvailableLayers:
		soap_serialize__om__AvailableLayers(soap, (const om__AvailableLayersType *)ptr);
		break;
	case SOAP_TYPE_om__om__Algorithms:
		soap_serialize__om__Algorithms(soap, (const om__AlgorithmsMetadataType *)ptr);
		break;
	case SOAP_TYPE_om__om__AvailableAlgorithms:
		soap_serialize__om__AvailableAlgorithms(soap, (const om__AvailableAlgorithmsType *)ptr);
		break;
	case SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope:
		((_om__ResultSetType_Job_ProjectionEnvelope *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ResultSetType_Job:
		((_om__ResultSetType_Job *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__JobTicketsType_Job:
		((_om__JobTicketsType_Job *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs:
		((__om__union_ExperimentParametersType_Jobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Jobs:
		((_om__ExperimentParametersType_Jobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm:
		((_om__ExperimentParametersType_SerializedAlgorithm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings:
		((_om__ExperimentParametersType_AlgorithmSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point:
		((_om__ExperimentParametersType_Absence_Point *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence:
		((_om__ExperimentParametersType_Absence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point:
		((_om__ExperimentParametersType_Presence_Point *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence:
		((_om__ExperimentParametersType_Presence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Environment:
		((_om__ExperimentParametersType_Environment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ModelEvaluationResultType_Values:
		((_om__ModelEvaluationResultType_Values *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique:
		((_om__OccurrencesFilterType_EnvironmentallyUnique *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique:
		((_om__OccurrencesFilterType_SpatiallyUnique *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics:
		((_om__ProjectionStatisticsParametersType_AreaStatistics *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio:
		((_om__TestResultType_RocCurve_Ratio *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__TestResultType_RocCurve:
		((_om__TestResultType_RocCurve *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__TestResultType_ConfusionMatrix:
		((_om__TestResultType_ConfusionMatrix *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__TestOptionsType_RocCurve:
		((_om__TestOptionsType_RocCurve *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix:
		((_om__TestOptionsType_ConfusionMatrix *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__OccurrencesType_Point:
		((_om__OccurrencesType_Point *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Model:
		((_om__SerializedAlgorithmType_Model *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter:
		((_om__SerializedAlgorithmType_Parameters_Parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters:
		((_om__SerializedAlgorithmType_Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		((_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters:
		((_om__BasicAlgorithmDefinitionType_Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter:
		((_om__AlgorithmMetadataType_Parameters_Parameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters:
		((_om__AlgorithmMetadataType_Parameters *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer:
		((_om__AlgorithmMetadataType_Developers_Developer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers:
		((_om__AlgorithmMetadataType_Developers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer:
		((_om__AlgorithmMetadataType_Designers_Designer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers:
		((_om__AlgorithmMetadataType_Designers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ThresholdParameterType:
		soap_serialize_om__ThresholdParameterType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_om_om__ResultSetType:
		((om__ResultSetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__JobTicketsType:
		((om__JobTicketsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ProjectModelJobType:
		((om__ProjectModelJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__TestModelJobType:
		((om__TestModelJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__CreateModelJobType:
		((om__CreateModelJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SamplingJobType:
		((om__SamplingJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__IdentifiedType:
		((om__IdentifiedType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ReferenceType:
		((om__ReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ExperimentParametersType:
		((om__ExperimentParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SamplingParametersType:
		((om__SamplingParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SamplingOptionsType:
		((om__SamplingOptionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModelEvaluationResultType:
		((om__ModelEvaluationResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModelEvaluationParametersType:
		((om__ModelEvaluationParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ProjectionParametersType:
		((om__ProjectionParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__TestResultEnvelopeType:
		((om__TestResultEnvelopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__TestParametersType:
		((om__TestParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SerializedModelType:
		((om__SerializedModelType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModelEnvelopeType:
		((om__ModelEnvelopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModelOptionsType:
		((om__ModelOptionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__OccurrencesFilterType:
		((om__OccurrencesFilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModelParametersType:
		((om__ModelParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__MapOutputParametersType:
		((om__MapOutputParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__AreaStatisticsType:
		((om__AreaStatisticsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ProjectionEnvelopeType:
		((om__ProjectionEnvelopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ProjectionStatisticsParametersType:
		((om__ProjectionStatisticsParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__TestResultType:
		((om__TestResultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__TestOptionsType:
		((om__TestOptionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__NormalizationType:
		((om__NormalizationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SamplerType:
		((om__SamplerType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__OccurrencesType:
		((om__OccurrencesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__EnvironmentType:
		((om__EnvironmentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__LayersGroupType:
		((om__LayersGroupType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__LayerMetadataType:
		((om__LayerMetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__ModellingLayerType:
		((om__ModellingLayerType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__BasicLayerType:
		((om__BasicLayerType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__AvailableLayersType:
		((om__AvailableLayersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__SerializedAlgorithmType:
		((om__SerializedAlgorithmType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__BasicAlgorithmDefinitionType:
		((om__BasicAlgorithmDefinitionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__AlgorithmMetadataType:
		((om__AlgorithmMetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__AlgorithmsMetadataType:
		((om__AlgorithmsMetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_om__AvailableAlgorithmsType:
		((om__AvailableAlgorithmsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_om_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_om_xsd__IDREF:
		soap_serialize_xsd__IDREF(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_om_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_om_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_om_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_om_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ReferenceType:
		soap_serialize_PointerToom__ReferenceType(soap, (om__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__ResultSetType_Job_ProjectionEnvelope:
		soap_serialize_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, (_om__ResultSetType_Job_ProjectionEnvelope *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ProjectionEnvelopeType:
		soap_serialize_PointerToom__ProjectionEnvelopeType(soap, (om__ProjectionEnvelopeType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__TestResultEnvelopeType:
		soap_serialize_PointerToom__TestResultEnvelopeType(soap, (om__TestResultEnvelopeType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ModelEnvelopeType:
		soap_serialize_PointerToom__ModelEnvelopeType(soap, (om__ModelEnvelopeType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo__om__union_ExperimentParametersType_Jobs:
		soap_serialize_PointerTo__om__union_ExperimentParametersType_Jobs(soap, (__om__union_ExperimentParametersType_Jobs *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ProjectModelJobType:
		soap_serialize_PointerToom__ProjectModelJobType(soap, (om__ProjectModelJobType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__TestModelJobType:
		soap_serialize_PointerToom__TestModelJobType(soap, (om__TestModelJobType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__CreateModelJobType:
		soap_serialize_PointerToom__CreateModelJobType(soap, (om__CreateModelJobType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__SamplingJobType:
		soap_serialize_PointerToom__SamplingJobType(soap, (om__SamplingJobType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__SamplingOptionsType:
		soap_serialize_PointerToom__SamplingOptionsType(soap, (om__SamplingOptionsType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ProjectionStatisticsParametersType:
		soap_serialize_PointerToom__ProjectionStatisticsParametersType(soap, (om__ProjectionStatisticsParametersType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__MapOutputParametersType:
		soap_serialize_PointerToom__MapOutputParametersType(soap, (om__MapOutputParametersType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__TestOptionsType:
		soap_serialize_PointerToom__TestOptionsType(soap, (om__TestOptionsType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__TestResultType:
		soap_serialize_PointerToom__TestResultType(soap, (om__TestResultType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__SerializedAlgorithmType:
		soap_serialize_PointerToom__SerializedAlgorithmType(soap, (om__SerializedAlgorithmType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__SerializedModelType:
		soap_serialize_PointerToom__SerializedModelType(soap, (om__SerializedModelType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__OccurrencesFilterType:
		soap_serialize_PointerToom__OccurrencesFilterType(soap, (om__OccurrencesFilterType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique:
		soap_serialize_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, (_om__OccurrencesFilterType_EnvironmentallyUnique *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_SpatiallyUnique:
		soap_serialize_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, (_om__OccurrencesFilterType_SpatiallyUnique *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ModelOptionsType:
		soap_serialize_PointerToom__ModelOptionsType(soap, (om__ModelOptionsType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__BasicAlgorithmDefinitionType:
		soap_serialize_PointerToom__BasicAlgorithmDefinitionType(soap, (om__BasicAlgorithmDefinitionType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__SamplerType:
		soap_serialize_PointerToom__SamplerType(soap, (om__SamplerType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__AreaStatisticsType:
		soap_serialize_PointerToom__AreaStatisticsType(soap, (om__AreaStatisticsType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics:
		soap_serialize_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, (_om__ProjectionStatisticsParametersType_AreaStatistics *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve:
		soap_serialize_PointerTo_om__TestResultType_RocCurve(soap, (_om__TestResultType_RocCurve *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve_Ratio:
		soap_serialize_PointerTo_om__TestResultType_RocCurve_Ratio(soap, (_om__TestResultType_RocCurve_Ratio *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__TestResultType_ConfusionMatrix:
		soap_serialize_PointerTo_om__TestResultType_ConfusionMatrix(soap, (_om__TestResultType_ConfusionMatrix *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_RocCurve:
		soap_serialize_PointerTo_om__TestOptionsType_RocCurve(soap, (_om__TestOptionsType_RocCurve *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ZeroOneIntervalType:
		soap_serialize_PointerToom__ZeroOneIntervalType(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__TestOptionsType_ConfusionMatrix:
		soap_serialize_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, (_om__TestOptionsType_ConfusionMatrix *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ThresholdParameterType:
		soap_serialize_PointerToom__ThresholdParameterType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__OccurrencesType:
		soap_serialize_PointerToom__OccurrencesType(soap, (om__OccurrencesType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__EnvironmentType:
		soap_serialize_PointerToom__EnvironmentType(soap, (om__EnvironmentType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__BasicLayerType:
		soap_serialize_PointerToom__BasicLayerType(soap, (om__BasicLayerType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__ModellingLayerType:
		soap_serialize_PointerToom__ModellingLayerType(soap, (om__ModellingLayerType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__LayerMetadataType:
		soap_serialize_PointerToom__LayerMetadataType(soap, (om__LayerMetadataType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__LayersGroupType:
		soap_serialize_PointerToom__LayersGroupType(soap, (om__LayersGroupType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__NormalizationType:
		soap_serialize_PointerToom__NormalizationType(soap, (om__NormalizationType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__AlgorithmMetadataType:
		soap_serialize_PointerToom__AlgorithmMetadataType(soap, (om__AlgorithmMetadataType *const*)ptr);
		break;
	case SOAP_TYPE_om_PointerToom__AlgorithmsMetadataType:
		soap_serialize_PointerToom__AlgorithmsMetadataType(soap, (om__AlgorithmsMetadataType *const*)ptr);
		break;
	case SOAP_TYPE_om__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_om_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 om_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_om_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__AvailableAlgorithmsType:
		return (void*)soap_instantiate_om__AvailableAlgorithmsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__AlgorithmsMetadataType:
		return (void*)soap_instantiate_om__AlgorithmsMetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Designers_Designer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Designers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Developers_Developer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Developers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters:
		return (void*)soap_instantiate__om__AlgorithmMetadataType_Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__AlgorithmMetadataType:
		return (void*)soap_instantiate_om__AlgorithmMetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		return (void*)soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters:
		return (void*)soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__BasicAlgorithmDefinitionType:
		return (void*)soap_instantiate_om__BasicAlgorithmDefinitionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter:
		return (void*)soap_instantiate__om__SerializedAlgorithmType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters:
		return (void*)soap_instantiate__om__SerializedAlgorithmType_Parameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Model:
		return (void*)soap_instantiate__om__SerializedAlgorithmType_Model(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SerializedAlgorithmType:
		return (void*)soap_instantiate_om__SerializedAlgorithmType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__AvailableLayersType:
		return (void*)soap_instantiate_om__AvailableLayersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__BasicLayerType:
		return (void*)soap_instantiate_om__BasicLayerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__LayersGroupType:
		return (void*)soap_instantiate_om__LayersGroupType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__EnvironmentType:
		return (void*)soap_instantiate_om__EnvironmentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__OccurrencesType_Point:
		return (void*)soap_instantiate__om__OccurrencesType_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__OccurrencesType:
		return (void*)soap_instantiate_om__OccurrencesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SamplerType:
		return (void*)soap_instantiate_om__SamplerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__NormalizationType:
		return (void*)soap_instantiate_om__NormalizationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix:
		return (void*)soap_instantiate__om__TestOptionsType_ConfusionMatrix(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestOptionsType_RocCurve:
		return (void*)soap_instantiate__om__TestOptionsType_RocCurve(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__TestOptionsType:
		return (void*)soap_instantiate_om__TestOptionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestResultType_ConfusionMatrix:
		return (void*)soap_instantiate__om__TestResultType_ConfusionMatrix(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio:
		return (void*)soap_instantiate__om__TestResultType_RocCurve_Ratio(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestResultType_RocCurve:
		return (void*)soap_instantiate__om__TestResultType_RocCurve(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__TestResultType:
		return (void*)soap_instantiate_om__TestResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics:
		return (void*)soap_instantiate__om__ProjectionStatisticsParametersType_AreaStatistics(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ProjectionStatisticsParametersType:
		return (void*)soap_instantiate_om__ProjectionStatisticsParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ProjectionEnvelopeType:
		return (void*)soap_instantiate_om__ProjectionEnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__AreaStatisticsType:
		return (void*)soap_instantiate_om__AreaStatisticsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__MapOutputParametersType:
		return (void*)soap_instantiate_om__MapOutputParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModelParametersType:
		return (void*)soap_instantiate_om__ModelParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique:
		return (void*)soap_instantiate__om__OccurrencesFilterType_SpatiallyUnique(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique:
		return (void*)soap_instantiate__om__OccurrencesFilterType_EnvironmentallyUnique(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__OccurrencesFilterType:
		return (void*)soap_instantiate_om__OccurrencesFilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModelOptionsType:
		return (void*)soap_instantiate_om__ModelOptionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModelEnvelopeType:
		return (void*)soap_instantiate_om__ModelEnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SerializedModelType:
		return (void*)soap_instantiate_om__SerializedModelType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__TestParametersType:
		return (void*)soap_instantiate_om__TestParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__TestResultEnvelopeType:
		return (void*)soap_instantiate_om__TestResultEnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ProjectionParametersType:
		return (void*)soap_instantiate_om__ProjectionParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModelEvaluationParametersType:
		return (void*)soap_instantiate_om__ModelEvaluationParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ModelEvaluationResultType_Values:
		return (void*)soap_instantiate__om__ModelEvaluationResultType_Values(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModelEvaluationResultType:
		return (void*)soap_instantiate_om__ModelEvaluationResultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SamplingOptionsType:
		return (void*)soap_instantiate_om__SamplingOptionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SamplingParametersType:
		return (void*)soap_instantiate_om__SamplingParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Environment:
		return (void*)soap_instantiate__om__ExperimentParametersType_Environment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point:
		return (void*)soap_instantiate__om__ExperimentParametersType_Presence_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence:
		return (void*)soap_instantiate__om__ExperimentParametersType_Presence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point:
		return (void*)soap_instantiate__om__ExperimentParametersType_Absence_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence:
		return (void*)soap_instantiate__om__ExperimentParametersType_Absence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings:
		return (void*)soap_instantiate__om__ExperimentParametersType_AlgorithmSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm:
		return (void*)soap_instantiate__om__ExperimentParametersType_SerializedAlgorithm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs:
		return (void*)soap_instantiate___om__union_ExperimentParametersType_Jobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParametersType_Jobs:
		return (void*)soap_instantiate__om__ExperimentParametersType_Jobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ExperimentParametersType:
		return (void*)soap_instantiate_om__ExperimentParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ReferenceType:
		return (void*)soap_instantiate_om__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__IdentifiedType:
		return (void*)soap_instantiate_om__IdentifiedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__JobTicketsType_Job:
		return (void*)soap_instantiate__om__JobTicketsType_Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__JobTicketsType:
		return (void*)soap_instantiate_om__JobTicketsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope:
		return (void*)soap_instantiate__om__ResultSetType_Job_ProjectionEnvelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ResultSetType_Job:
		return (void*)soap_instantiate__om__ResultSetType_Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ResultSetType:
		return (void*)soap_instantiate_om__ResultSetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ModellingLayerType:
		return (void*)soap_instantiate_om__ModellingLayerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__SamplingJobType:
		return (void*)soap_instantiate_om__SamplingJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__CreateModelJobType:
		return (void*)soap_instantiate_om__CreateModelJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__TestModelJobType:
		return (void*)soap_instantiate_om__TestModelJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ProjectModelJobType:
		return (void*)soap_instantiate_om__ProjectModelJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__LayerMetadataType:
		return (void*)soap_instantiate_om__LayerMetadataType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_om_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_xsd__anyAttribute:
		return (void*)soap_instantiate_xsd__anyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_xsd__IDREF:
		return (void*)soap_instantiate_xsd__IDREF(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_om__ThresholdParameterType:
		return (void*)soap_instantiate_om__ThresholdParameterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AvailableAlgorithms:
		return (void*)soap_instantiate__om__AvailableAlgorithms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__Algorithms:
		return (void*)soap_instantiate__om__Algorithms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__AvailableLayers:
		return (void*)soap_instantiate__om__AvailableLayers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ModelParameters:
		return (void*)soap_instantiate__om__ModelParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ModelEnvelope:
		return (void*)soap_instantiate__om__ModelEnvelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestParameters:
		return (void*)soap_instantiate__om__TestParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestResultEnvelope:
		return (void*)soap_instantiate__om__TestResultEnvelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SerializedModel:
		return (void*)soap_instantiate__om__SerializedModel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ProjectionParameters:
		return (void*)soap_instantiate__om__ProjectionParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ProjectionEnvelope:
		return (void*)soap_instantiate__om__ProjectionEnvelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ModelEvaluationParameters:
		return (void*)soap_instantiate__om__ModelEvaluationParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ModelEvaluation:
		return (void*)soap_instantiate__om__ModelEvaluation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SamplingParameters:
		return (void*)soap_instantiate__om__SamplingParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__Sampler:
		return (void*)soap_instantiate__om__Sampler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentParameters:
		return (void*)soap_instantiate__om__ExperimentParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ExperimentTickets:
		return (void*)soap_instantiate__om__ExperimentTickets(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ResultSet:
		return (void*)soap_instantiate__om__ResultSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__SamplingJob:
		return (void*)soap_instantiate__om__SamplingJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__CreateModelJob:
		return (void*)soap_instantiate__om__CreateModelJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__TestModelJob:
		return (void*)soap_instantiate__om__TestModelJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om__om__ProjectModelJob:
		return (void*)soap_instantiate__om__ProjectModelJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ResultSetType_Job:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ResultSetType_Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__JobTicketsType_Job:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__JobTicketsType_Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Environment:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__OccurrencesType_Point:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__OccurrencesType_Point(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__ModellingLayerType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayerMetadataType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayersGroupType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToom__LayersGroupType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer:
		return (void*)soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__AlgorithmMetadataType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 om_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_om_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_om_om__AvailableAlgorithmsType:
		if (p->size < 0)
			SOAP_DELETE((om__AvailableAlgorithmsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AvailableAlgorithmsType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__AlgorithmsMetadataType:
		if (p->size < 0)
			SOAP_DELETE((om__AlgorithmsMetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AlgorithmsMetadataType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Designers_Designer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Designers_Designer*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Designers:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Designers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Designers*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Developers_Developer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Developers_Developer*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Developers:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Developers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Developers*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Parameters_Parameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Parameters_Parameter*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters:
		if (p->size < 0)
			SOAP_DELETE((_om__AlgorithmMetadataType_Parameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__AlgorithmMetadataType_Parameters*)p->ptr);
		break;
	case SOAP_TYPE_om_om__AlgorithmMetadataType:
		if (p->size < 0)
			SOAP_DELETE((om__AlgorithmMetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AlgorithmMetadataType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)p->ptr);
		break;
	case SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters:
		if (p->size < 0)
			SOAP_DELETE((_om__BasicAlgorithmDefinitionType_Parameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__BasicAlgorithmDefinitionType_Parameters*)p->ptr);
		break;
	case SOAP_TYPE_om_om__BasicAlgorithmDefinitionType:
		if (p->size < 0)
			SOAP_DELETE((om__BasicAlgorithmDefinitionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__BasicAlgorithmDefinitionType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((_om__SerializedAlgorithmType_Parameters_Parameter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__SerializedAlgorithmType_Parameters_Parameter*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters:
		if (p->size < 0)
			SOAP_DELETE((_om__SerializedAlgorithmType_Parameters*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__SerializedAlgorithmType_Parameters*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SerializedAlgorithmType_Model:
		if (p->size < 0)
			SOAP_DELETE((_om__SerializedAlgorithmType_Model*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__SerializedAlgorithmType_Model*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SerializedAlgorithmType:
		if (p->size < 0)
			SOAP_DELETE((om__SerializedAlgorithmType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SerializedAlgorithmType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__AvailableLayersType:
		if (p->size < 0)
			SOAP_DELETE((om__AvailableLayersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AvailableLayersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__BasicLayerType:
		if (p->size < 0)
			SOAP_DELETE((om__BasicLayerType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__BasicLayerType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__LayersGroupType:
		if (p->size < 0)
			SOAP_DELETE((om__LayersGroupType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__LayersGroupType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__EnvironmentType:
		if (p->size < 0)
			SOAP_DELETE((om__EnvironmentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__EnvironmentType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__OccurrencesType_Point:
		if (p->size < 0)
			SOAP_DELETE((_om__OccurrencesType_Point*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__OccurrencesType_Point*)p->ptr);
		break;
	case SOAP_TYPE_om_om__OccurrencesType:
		if (p->size < 0)
			SOAP_DELETE((om__OccurrencesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__OccurrencesType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SamplerType:
		if (p->size < 0)
			SOAP_DELETE((om__SamplerType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplerType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__NormalizationType:
		if (p->size < 0)
			SOAP_DELETE((om__NormalizationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__NormalizationType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix:
		if (p->size < 0)
			SOAP_DELETE((_om__TestOptionsType_ConfusionMatrix*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__TestOptionsType_ConfusionMatrix*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestOptionsType_RocCurve:
		if (p->size < 0)
			SOAP_DELETE((_om__TestOptionsType_RocCurve*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__TestOptionsType_RocCurve*)p->ptr);
		break;
	case SOAP_TYPE_om_om__TestOptionsType:
		if (p->size < 0)
			SOAP_DELETE((om__TestOptionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestOptionsType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestResultType_ConfusionMatrix:
		if (p->size < 0)
			SOAP_DELETE((_om__TestResultType_ConfusionMatrix*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__TestResultType_ConfusionMatrix*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio:
		if (p->size < 0)
			SOAP_DELETE((_om__TestResultType_RocCurve_Ratio*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__TestResultType_RocCurve_Ratio*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestResultType_RocCurve:
		if (p->size < 0)
			SOAP_DELETE((_om__TestResultType_RocCurve*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__TestResultType_RocCurve*)p->ptr);
		break;
	case SOAP_TYPE_om_om__TestResultType:
		if (p->size < 0)
			SOAP_DELETE((om__TestResultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestResultType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics:
		if (p->size < 0)
			SOAP_DELETE((_om__ProjectionStatisticsParametersType_AreaStatistics*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ProjectionStatisticsParametersType_AreaStatistics*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ProjectionStatisticsParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectionStatisticsParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectionStatisticsParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ProjectionEnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectionEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectionEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__AreaStatisticsType:
		if (p->size < 0)
			SOAP_DELETE((om__AreaStatisticsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AreaStatisticsType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__MapOutputParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__MapOutputParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__MapOutputParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModelParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__ModelParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique:
		if (p->size < 0)
			SOAP_DELETE((_om__OccurrencesFilterType_SpatiallyUnique*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__OccurrencesFilterType_SpatiallyUnique*)p->ptr);
		break;
	case SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique:
		if (p->size < 0)
			SOAP_DELETE((_om__OccurrencesFilterType_EnvironmentallyUnique*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__OccurrencesFilterType_EnvironmentallyUnique*)p->ptr);
		break;
	case SOAP_TYPE_om_om__OccurrencesFilterType:
		if (p->size < 0)
			SOAP_DELETE((om__OccurrencesFilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__OccurrencesFilterType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModelOptionsType:
		if (p->size < 0)
			SOAP_DELETE((om__ModelOptionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelOptionsType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModelEnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SerializedModelType:
		if (p->size < 0)
			SOAP_DELETE((om__SerializedModelType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SerializedModelType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__TestParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__TestParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__TestResultEnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((om__TestResultEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestResultEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ProjectionParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectionParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectionParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModelEvaluationParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEvaluationParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEvaluationParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ModelEvaluationResultType_Values:
		if (p->size < 0)
			SOAP_DELETE((_om__ModelEvaluationResultType_Values*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ModelEvaluationResultType_Values*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModelEvaluationResultType:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEvaluationResultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEvaluationResultType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SamplingOptionsType:
		if (p->size < 0)
			SOAP_DELETE((om__SamplingOptionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplingOptionsType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SamplingParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__SamplingParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplingParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Environment:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Environment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Environment*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Presence_Point*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Presence_Point*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Presence:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Presence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Presence*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Absence_Point*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Absence_Point*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Absence:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Absence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Absence*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_AlgorithmSettings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_AlgorithmSettings*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_SerializedAlgorithm*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_SerializedAlgorithm*)p->ptr);
		break;
	case SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs:
		if (p->size < 0)
			SOAP_DELETE((__om__union_ExperimentParametersType_Jobs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__om__union_ExperimentParametersType_Jobs*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParametersType_Jobs:
		if (p->size < 0)
			SOAP_DELETE((_om__ExperimentParametersType_Jobs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ExperimentParametersType_Jobs*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ExperimentParametersType:
		if (p->size < 0)
			SOAP_DELETE((om__ExperimentParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ExperimentParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE((om__ReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__IdentifiedType:
		if (p->size < 0)
			SOAP_DELETE((om__IdentifiedType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__IdentifiedType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__JobTicketsType_Job:
		if (p->size < 0)
			SOAP_DELETE((_om__JobTicketsType_Job*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__JobTicketsType_Job*)p->ptr);
		break;
	case SOAP_TYPE_om_om__JobTicketsType:
		if (p->size < 0)
			SOAP_DELETE((om__JobTicketsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__JobTicketsType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope:
		if (p->size < 0)
			SOAP_DELETE((_om__ResultSetType_Job_ProjectionEnvelope*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ResultSetType_Job_ProjectionEnvelope*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ResultSetType_Job:
		if (p->size < 0)
			SOAP_DELETE((_om__ResultSetType_Job*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_om__ResultSetType_Job*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ResultSetType:
		if (p->size < 0)
			SOAP_DELETE((om__ResultSetType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ResultSetType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ModellingLayerType:
		if (p->size < 0)
			SOAP_DELETE((om__ModellingLayerType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModellingLayerType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__SamplingJobType:
		if (p->size < 0)
			SOAP_DELETE((om__SamplingJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplingJobType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__CreateModelJobType:
		if (p->size < 0)
			SOAP_DELETE((om__CreateModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__CreateModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__TestModelJobType:
		if (p->size < 0)
			SOAP_DELETE((om__TestModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ProjectModelJobType:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om_om__LayerMetadataType:
		if (p->size < 0)
			SOAP_DELETE((om__LayerMetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__LayerMetadataType*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_om_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_om_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_element*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_element*)p->ptr);
		break;
	case SOAP_TYPE_om_xsd__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_attribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_attribute*)p->ptr);
		break;
	case SOAP_TYPE_om_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_om_xsd__IDREF:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_om_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_om_om__ThresholdParameterType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AvailableAlgorithms:
		if (p->size < 0)
			SOAP_DELETE((om__AvailableAlgorithmsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AvailableAlgorithmsType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__Algorithms:
		if (p->size < 0)
			SOAP_DELETE((om__AlgorithmsMetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AlgorithmsMetadataType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__AvailableLayers:
		if (p->size < 0)
			SOAP_DELETE((om__AvailableLayersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__AvailableLayersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ModelParameters:
		if (p->size < 0)
			SOAP_DELETE((om__ModelParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ModelEnvelope:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestParameters:
		if (p->size < 0)
			SOAP_DELETE((om__TestParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestResultEnvelope:
		if (p->size < 0)
			SOAP_DELETE((om__TestResultEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestResultEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SerializedModel:
		if (p->size < 0)
			SOAP_DELETE((om__SerializedModelType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SerializedModelType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ProjectionParameters:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectionParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectionParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ProjectionEnvelope:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectionEnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectionEnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ModelEvaluationParameters:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEvaluationParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEvaluationParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ModelEvaluation:
		if (p->size < 0)
			SOAP_DELETE((om__ModelEvaluationResultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ModelEvaluationResultType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SamplingParameters:
		if (p->size < 0)
			SOAP_DELETE((om__SamplingParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplingParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__Sampler:
		if (p->size < 0)
			SOAP_DELETE((om__SamplerType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplerType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentParameters:
		if (p->size < 0)
			SOAP_DELETE((om__ExperimentParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ExperimentParametersType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ExperimentTickets:
		if (p->size < 0)
			SOAP_DELETE((om__JobTicketsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__JobTicketsType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ResultSet:
		if (p->size < 0)
			SOAP_DELETE((om__ResultSetType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ResultSetType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__SamplingJob:
		if (p->size < 0)
			SOAP_DELETE((om__SamplingJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__SamplingJobType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__CreateModelJob:
		if (p->size < 0)
			SOAP_DELETE((om__CreateModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__CreateModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__TestModelJob:
		if (p->size < 0)
			SOAP_DELETE((om__TestModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__TestModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om__om__ProjectModelJob:
		if (p->size < 0)
			SOAP_DELETE((om__ProjectModelJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((om__ProjectModelJobType*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ResultSetType_Job:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ResultSetType_Job >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ResultSetType_Job >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__JobTicketsType_Job:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__JobTicketsType_Job >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__JobTicketsType_Job >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_Absence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_Absence >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_Absence_Point >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_Absence_Point >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_Presence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_Presence >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_Presence_Point >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_Presence_Point >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Environment:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__ExperimentParametersType_Environment >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__ExperimentParametersType_Environment >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__OccurrencesType_Point:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__OccurrencesType_Point >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__OccurrencesType_Point >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__ModellingLayerType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<om__ModellingLayerType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<om__ModellingLayerType * >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayerMetadataType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<om__LayerMetadataType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<om__LayerMetadataType * >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayersGroupType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<om__LayersGroupType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<om__LayersGroupType * >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)p->ptr);
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__AlgorithmMetadataType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<om__AlgorithmMetadataType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<om__AlgorithmMetadataType * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, om_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, om_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 om_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ResultSetType_Job:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ResultSetType_Job >*)p)[len] = *(_om__ResultSetType_Job *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__JobTicketsType_Job:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__JobTicketsType_Job >*)p)[len] = *(_om__JobTicketsType_Job *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)p)[len] = *(_om__ExperimentParametersType_SerializedAlgorithm *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)p)[len] = *(_om__ExperimentParametersType_AlgorithmSettings *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_Absence >*)p)[len] = *(_om__ExperimentParametersType_Absence *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_Absence_Point >*)p)[len] = *(_om__ExperimentParametersType_Absence_Point *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_Presence >*)p)[len] = *(_om__ExperimentParametersType_Presence *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_Presence_Point >*)p)[len] = *(_om__ExperimentParametersType_Presence_Point *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Environment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__ExperimentParametersType_Environment >*)p)[len] = *(_om__ExperimentParametersType_Environment *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__OccurrencesType_Point:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__OccurrencesType_Point >*)p)[len] = *(_om__OccurrencesType_Point *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__ModellingLayerType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<om__ModellingLayerType * >*)p)[len] = *(om__ModellingLayerType **)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayerMetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<om__LayerMetadataType * >*)p)[len] = *(om__LayerMetadataType **)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayersGroupType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<om__LayersGroupType * >*)p)[len] = *(om__LayersGroupType **)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)p)[len] = *(_om__SerializedAlgorithmType_Parameters_Parameter *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)p)[len] = *(_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)p)[len] = *(_om__AlgorithmMetadataType_Parameters_Parameter *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)p)[len] = *(_om__AlgorithmMetadataType_Developers_Developer *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)p)[len] = *(_om__AlgorithmMetadataType_Designers_Designer *)q;
		break;
	case SOAP_TYPE_om_std__vectorTemplateOfPointerToom__AlgorithmMetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container om_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<om__AlgorithmMetadataType * >*)p)[len] = *(om__AlgorithmMetadataType **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_om_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_om_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_om_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_om_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ZeroOneIntervalType(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_om_om__ZeroOneIntervalType);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_om__ZeroOneIntervalType(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_om_om__ZeroOneIntervalType);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_om__ZeroOneIntervalType(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_om__ZeroOneIntervalType);
	if (soap_out_om__ZeroOneIntervalType(soap, tag?tag:"om:ZeroOneIntervalType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_om__ZeroOneIntervalType(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ZeroOneIntervalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_om_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_om_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_om__ThresholdCalculationType(struct soap *soap, enum om__ThresholdCalculationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_om__ThresholdCalculationType
	*a = SOAP_DEFAULT_om__ThresholdCalculationType;
#else
	*a = (enum om__ThresholdCalculationType)0;
#endif
}

static const struct soap_code_map soap_codes_om__ThresholdCalculationType[] =
{	{ (long)om__ThresholdCalculationType__lpt, "lpt" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_om__ThresholdCalculationType2s(struct soap *soap, enum om__ThresholdCalculationType n)
{	const char *s = soap_code_str(soap_codes_om__ThresholdCalculationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ThresholdCalculationType(struct soap *soap, const char *tag, int id, const enum om__ThresholdCalculationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ThresholdCalculationType), type) || soap_send(soap, soap_om__ThresholdCalculationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2om__ThresholdCalculationType(struct soap *soap, const char *s, enum om__ThresholdCalculationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_om__ThresholdCalculationType, s);
	if (map)
		*a = (enum om__ThresholdCalculationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum om__ThresholdCalculationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum om__ThresholdCalculationType * SOAP_FMAC4 soap_in_om__ThresholdCalculationType(struct soap *soap, const char *tag, enum om__ThresholdCalculationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum om__ThresholdCalculationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ThresholdCalculationType, sizeof(enum om__ThresholdCalculationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2om__ThresholdCalculationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum om__ThresholdCalculationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ThresholdCalculationType, 0, sizeof(enum om__ThresholdCalculationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_om__ThresholdCalculationType(struct soap *soap, const enum om__ThresholdCalculationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_om__ThresholdCalculationType);
	if (soap_out_om__ThresholdCalculationType(soap, tag?tag:"om:ThresholdCalculationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum om__ThresholdCalculationType * SOAP_FMAC4 soap_get_om__ThresholdCalculationType(struct soap *soap, enum om__ThresholdCalculationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ThresholdCalculationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _om__ResultSetType_Job_ProjectionEnvelope::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ResultSetType_Job_ProjectionEnvelope::Statistics = NULL;
	soap_default_xsd__anyURI(soap, &this->_om__ResultSetType_Job_ProjectionEnvelope::url);
}

void _om__ResultSetType_Job_ProjectionEnvelope::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__ProjectionEnvelopeType(soap, &this->_om__ResultSetType_Job_ProjectionEnvelope::Statistics);
#endif
}

int _om__ResultSetType_Job_ProjectionEnvelope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ResultSetType_Job_ProjectionEnvelope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, const char *tag, int id, const _om__ResultSetType_Job_ProjectionEnvelope *a, const char *type)
{
	soap_set_attr(soap, "url", ((_om__ResultSetType_Job_ProjectionEnvelope*)a)->url.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope), type))
		return soap->error;
	if (soap_out_PointerToom__ProjectionEnvelopeType(soap, "om:Statistics", -1, &(a->_om__ResultSetType_Job_ProjectionEnvelope::Statistics), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ResultSetType_Job_ProjectionEnvelope::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ResultSetType_Job_ProjectionEnvelope(soap, tag, this, type);
}

SOAP_FMAC3 _om__ResultSetType_Job_ProjectionEnvelope * SOAP_FMAC4 soap_in__om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, const char *tag, _om__ResultSetType_Job_ProjectionEnvelope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ResultSetType_Job_ProjectionEnvelope *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope, sizeof(_om__ResultSetType_Job_ProjectionEnvelope), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ResultSetType_Job_ProjectionEnvelope *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "url", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ResultSetType_Job_ProjectionEnvelope*)a)->url.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ProjectionEnvelopeType(soap, "om:Statistics", &(a->_om__ResultSetType_Job_ProjectionEnvelope::Statistics), "om:ProjectionEnvelopeType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ResultSetType_Job_ProjectionEnvelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope, 0, sizeof(_om__ResultSetType_Job_ProjectionEnvelope), 0, soap_copy__om__ResultSetType_Job_ProjectionEnvelope);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ResultSetType_Job_ProjectionEnvelope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope);
	if (this->soap_out(soap, tag?tag:"om:ResultSetType-Job-ProjectionEnvelope", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ResultSetType_Job_ProjectionEnvelope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ResultSetType_Job_ProjectionEnvelope(soap, this, tag, type);
}

SOAP_FMAC3 _om__ResultSetType_Job_ProjectionEnvelope * SOAP_FMAC4 soap_get__om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, _om__ResultSetType_Job_ProjectionEnvelope *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ResultSetType_Job_ProjectionEnvelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ResultSetType_Job_ProjectionEnvelope * SOAP_FMAC2 soap_instantiate__om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ResultSetType_Job_ProjectionEnvelope(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ResultSetType_Job_ProjectionEnvelope);
		if (size)
			*size = sizeof(_om__ResultSetType_Job_ProjectionEnvelope);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ResultSetType_Job_ProjectionEnvelope, n);
		if (size)
			*size = n * sizeof(_om__ResultSetType_Job_ProjectionEnvelope);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ResultSetType_Job_ProjectionEnvelope*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ResultSetType_Job_ProjectionEnvelope %p -> %p\n", q, p));
	*(_om__ResultSetType_Job_ProjectionEnvelope*)p = *(_om__ResultSetType_Job_ProjectionEnvelope*)q;
}

void _om__ResultSetType_Job::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ResultSetType_Job::__union_ResultSetType_Job = 0;
	soap_default_std__string(soap, &this->_om__ResultSetType_Job::Ticket);
}

void _om__ResultSetType_Job::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__om__union_ResultSetType_Job(soap, this->_om__ResultSetType_Job::__union_ResultSetType_Job, &this->_om__ResultSetType_Job::union_ResultSetType_Job);
#endif
}

int _om__ResultSetType_Job::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ResultSetType_Job(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ResultSetType_Job(struct soap *soap, const char *tag, int id, const _om__ResultSetType_Job *a, const char *type)
{
	soap_set_attr(soap, "Ticket", ((_om__ResultSetType_Job*)a)->Ticket.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ResultSetType_Job), type))
		return soap->error;
	if (soap_out__om__union_ResultSetType_Job(soap, a->_om__ResultSetType_Job::__union_ResultSetType_Job, &a->_om__ResultSetType_Job::union_ResultSetType_Job))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ResultSetType_Job::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ResultSetType_Job(soap, tag, this, type);
}

SOAP_FMAC3 _om__ResultSetType_Job * SOAP_FMAC4 soap_in__om__ResultSetType_Job(struct soap *soap, const char *tag, _om__ResultSetType_Job *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ResultSetType_Job *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ResultSetType_Job, sizeof(_om__ResultSetType_Job), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ResultSetType_Job)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ResultSetType_Job *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Ticket", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ResultSetType_Job*)a)->Ticket.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_union_ResultSetType_Job1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_ResultSetType_Job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__om__union_ResultSetType_Job(soap, &a->_om__ResultSetType_Job::__union_ResultSetType_Job, &a->_om__ResultSetType_Job::union_ResultSetType_Job))
				{	soap_flag_union_ResultSetType_Job1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ResultSetType_Job *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ResultSetType_Job, 0, sizeof(_om__ResultSetType_Job), 0, soap_copy__om__ResultSetType_Job);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_ResultSetType_Job1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ResultSetType_Job::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ResultSetType_Job);
	if (this->soap_out(soap, tag?tag:"om:ResultSetType-Job", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ResultSetType_Job::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ResultSetType_Job(soap, this, tag, type);
}

SOAP_FMAC3 _om__ResultSetType_Job * SOAP_FMAC4 soap_get__om__ResultSetType_Job(struct soap *soap, _om__ResultSetType_Job *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ResultSetType_Job(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ResultSetType_Job * SOAP_FMAC2 soap_instantiate__om__ResultSetType_Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ResultSetType_Job(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ResultSetType_Job, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ResultSetType_Job);
		if (size)
			*size = sizeof(_om__ResultSetType_Job);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ResultSetType_Job, n);
		if (size)
			*size = n * sizeof(_om__ResultSetType_Job);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ResultSetType_Job*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ResultSetType_Job(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ResultSetType_Job %p -> %p\n", q, p));
	*(_om__ResultSetType_Job*)p = *(_om__ResultSetType_Job*)q;
}

void _om__JobTicketsType_Job::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__ID(soap, &this->_om__JobTicketsType_Job::id);
	soap_default_std__string(soap, &this->_om__JobTicketsType_Job::Ticket);
}

void _om__JobTicketsType_Job::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__JobTicketsType_Job::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__JobTicketsType_Job(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__JobTicketsType_Job(struct soap *soap, const char *tag, int id, const _om__JobTicketsType_Job *a, const char *type)
{
	soap_set_attr(soap, "id", ((_om__JobTicketsType_Job*)a)->id.c_str(), 1);
	soap_set_attr(soap, "Ticket", ((_om__JobTicketsType_Job*)a)->Ticket.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__JobTicketsType_Job), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__JobTicketsType_Job::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__JobTicketsType_Job(soap, tag, this, type);
}

SOAP_FMAC3 _om__JobTicketsType_Job * SOAP_FMAC4 soap_in__om__JobTicketsType_Job(struct soap *soap, const char *tag, _om__JobTicketsType_Job *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__JobTicketsType_Job *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__JobTicketsType_Job, sizeof(_om__JobTicketsType_Job), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__JobTicketsType_Job)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__JobTicketsType_Job *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__JobTicketsType_Job*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Ticket", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__JobTicketsType_Job*)a)->Ticket.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__JobTicketsType_Job *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__JobTicketsType_Job, 0, sizeof(_om__JobTicketsType_Job), 0, soap_copy__om__JobTicketsType_Job);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__JobTicketsType_Job::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__JobTicketsType_Job);
	if (this->soap_out(soap, tag?tag:"om:JobTicketsType-Job", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__JobTicketsType_Job::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__JobTicketsType_Job(soap, this, tag, type);
}

SOAP_FMAC3 _om__JobTicketsType_Job * SOAP_FMAC4 soap_get__om__JobTicketsType_Job(struct soap *soap, _om__JobTicketsType_Job *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__JobTicketsType_Job(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__JobTicketsType_Job * SOAP_FMAC2 soap_instantiate__om__JobTicketsType_Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__JobTicketsType_Job(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__JobTicketsType_Job, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__JobTicketsType_Job);
		if (size)
			*size = sizeof(_om__JobTicketsType_Job);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__JobTicketsType_Job, n);
		if (size)
			*size = n * sizeof(_om__JobTicketsType_Job);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__JobTicketsType_Job*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__JobTicketsType_Job(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__JobTicketsType_Job %p -> %p\n", q, p));
	*(_om__JobTicketsType_Job*)p = *(_om__JobTicketsType_Job*)q;
}

void __om__union_ExperimentParametersType_Jobs::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__om__union_ExperimentParametersType_Jobs::__unionAbstractJob = 0;
}

void __om__union_ExperimentParametersType_Jobs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__om__union_ExperimentParametersType_Jobs(soap, this->__om__union_ExperimentParametersType_Jobs::__unionAbstractJob, &this->__om__union_ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs);
#endif
}

int __om__union_ExperimentParametersType_Jobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___om__union_ExperimentParametersType_Jobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___om__union_ExperimentParametersType_Jobs(struct soap *soap, const char *tag, int id, const __om__union_ExperimentParametersType_Jobs *a, const char *type)
{
	if (soap_out__om__union_ExperimentParametersType_Jobs(soap, a->__om__union_ExperimentParametersType_Jobs::__unionAbstractJob, &a->__om__union_ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs))
		return soap->error;
	return SOAP_OK;
}

void *__om__union_ExperimentParametersType_Jobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___om__union_ExperimentParametersType_Jobs(soap, tag, this, type);
}

SOAP_FMAC3 __om__union_ExperimentParametersType_Jobs * SOAP_FMAC4 soap_in___om__union_ExperimentParametersType_Jobs(struct soap *soap, const char *tag, __om__union_ExperimentParametersType_Jobs *a, const char *type)
{
	a = (__om__union_ExperimentParametersType_Jobs *)soap_class_id_enter(soap, "", a, SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs, sizeof(__om__union_ExperimentParametersType_Jobs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
		if (!soap_in__om__union_ExperimentParametersType_Jobs(soap, &a->__unionAbstractJob, &a->__union_ExperimentParametersType_Jobs))
			return NULL;
	return a;
}

int __om__union_ExperimentParametersType_Jobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-om:union-ExperimentParametersType-Jobs", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__om__union_ExperimentParametersType_Jobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___om__union_ExperimentParametersType_Jobs(soap, this, tag, type);
}

SOAP_FMAC3 __om__union_ExperimentParametersType_Jobs * SOAP_FMAC4 soap_get___om__union_ExperimentParametersType_Jobs(struct soap *soap, __om__union_ExperimentParametersType_Jobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___om__union_ExperimentParametersType_Jobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __om__union_ExperimentParametersType_Jobs * SOAP_FMAC2 soap_instantiate___om__union_ExperimentParametersType_Jobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___om__union_ExperimentParametersType_Jobs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__om__union_ExperimentParametersType_Jobs);
		if (size)
			*size = sizeof(__om__union_ExperimentParametersType_Jobs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__om__union_ExperimentParametersType_Jobs, n);
		if (size)
			*size = n * sizeof(__om__union_ExperimentParametersType_Jobs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__om__union_ExperimentParametersType_Jobs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___om__union_ExperimentParametersType_Jobs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __om__union_ExperimentParametersType_Jobs %p -> %p\n", q, p));
	*(__om__union_ExperimentParametersType_Jobs*)p = *(__om__union_ExperimentParametersType_Jobs*)q;
}

void _om__ExperimentParametersType_Jobs::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_Jobs::__sizeAbstractJob = 0;
	this->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs = NULL;
}

void _om__ExperimentParametersType_Jobs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs)
	{	int i;
		for (i = 0; i < this->_om__ExperimentParametersType_Jobs::__sizeAbstractJob; i++)
		{
			this->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs[i].soap_serialize(soap);
		}
	}
#endif
}

int _om__ExperimentParametersType_Jobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Jobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Jobs(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Jobs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Jobs), type))
		return soap->error;
	if (a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs)
	{	int i;
		for (i = 0; i < a->_om__ExperimentParametersType_Jobs::__sizeAbstractJob; i++)
			if (a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs[i].soap_out(soap, "-union-ExperimentParametersType-Jobs", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Jobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Jobs(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Jobs * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Jobs(struct soap *soap, const char *tag, _om__ExperimentParametersType_Jobs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Jobs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Jobs, sizeof(_om__ExperimentParametersType_Jobs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Jobs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Jobs *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_ExperimentParametersType_Jobs1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs == NULL)
				{	if (soap_blist___union_ExperimentParametersType_Jobs1 == NULL)
						soap_blist___union_ExperimentParametersType_Jobs1 = soap_new_block(soap);
					a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs = (__om__union_ExperimentParametersType_Jobs *)soap_push_block(soap, soap_blist___union_ExperimentParametersType_Jobs1, sizeof(__om__union_ExperimentParametersType_Jobs));
					if (a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs, __om__union_ExperimentParametersType_Jobs);
					a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs->soap_default(soap);
				}
				if (soap_in___om__union_ExperimentParametersType_Jobs(soap, "-union-ExperimentParametersType-Jobs", a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs, "-om:union-ExperimentParametersType-Jobs"))
				{	a->_om__ExperimentParametersType_Jobs::__sizeAbstractJob++;
					a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs)
			soap_pop_block(soap, soap_blist___union_ExperimentParametersType_Jobs1);
		if (a->_om__ExperimentParametersType_Jobs::__sizeAbstractJob)
			a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs = (__om__union_ExperimentParametersType_Jobs *)soap_save_block(soap, soap_blist___union_ExperimentParametersType_Jobs1, NULL, 1);
		else
		{	a->_om__ExperimentParametersType_Jobs::__union_ExperimentParametersType_Jobs = NULL;
			if (soap_blist___union_ExperimentParametersType_Jobs1)
				soap_end_block(soap, soap_blist___union_ExperimentParametersType_Jobs1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Jobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Jobs, 0, sizeof(_om__ExperimentParametersType_Jobs), 0, soap_copy__om__ExperimentParametersType_Jobs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Jobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Jobs);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Jobs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Jobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Jobs(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Jobs * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Jobs(struct soap *soap, _om__ExperimentParametersType_Jobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Jobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Jobs * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Jobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Jobs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Jobs, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Jobs);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Jobs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Jobs, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Jobs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Jobs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Jobs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Jobs %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Jobs*)p = *(_om__ExperimentParametersType_Jobs*)q;
}

void _om__ExperimentParametersType_SerializedAlgorithm::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_SerializedAlgorithm::Algorithm = NULL;
	soap_default_xsd__ID(soap, &this->_om__ExperimentParametersType_SerializedAlgorithm::id);
}

void _om__ExperimentParametersType_SerializedAlgorithm::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SerializedAlgorithmType(soap, &this->_om__ExperimentParametersType_SerializedAlgorithm::Algorithm);
#endif
}

int _om__ExperimentParametersType_SerializedAlgorithm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_SerializedAlgorithm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_SerializedAlgorithm *a, const char *type)
{
	soap_set_attr(soap, "id", ((_om__ExperimentParametersType_SerializedAlgorithm*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm), type))
		return soap->error;
	if (a->_om__ExperimentParametersType_SerializedAlgorithm::Algorithm)
	{	if (soap_out_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", -1, &a->_om__ExperimentParametersType_SerializedAlgorithm::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_SerializedAlgorithm::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_SerializedAlgorithm(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_SerializedAlgorithm * SOAP_FMAC4 soap_in__om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, _om__ExperimentParametersType_SerializedAlgorithm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_SerializedAlgorithm *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm, sizeof(_om__ExperimentParametersType_SerializedAlgorithm), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_SerializedAlgorithm *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_SerializedAlgorithm*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Algorithm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", &(a->_om__ExperimentParametersType_SerializedAlgorithm::Algorithm), "om:SerializedAlgorithmType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_SerializedAlgorithm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm, 0, sizeof(_om__ExperimentParametersType_SerializedAlgorithm), 0, soap_copy__om__ExperimentParametersType_SerializedAlgorithm);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_SerializedAlgorithm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-SerializedAlgorithm", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_SerializedAlgorithm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_SerializedAlgorithm(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_SerializedAlgorithm * SOAP_FMAC4 soap_get__om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, _om__ExperimentParametersType_SerializedAlgorithm *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_SerializedAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_SerializedAlgorithm * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_SerializedAlgorithm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_SerializedAlgorithm);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_SerializedAlgorithm);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_SerializedAlgorithm, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_SerializedAlgorithm);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_SerializedAlgorithm*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_SerializedAlgorithm %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_SerializedAlgorithm*)p = *(_om__ExperimentParametersType_SerializedAlgorithm*)q;
}

void _om__ExperimentParametersType_AlgorithmSettings::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_AlgorithmSettings::Algorithm = NULL;
	soap_default_xsd__ID(soap, &this->_om__ExperimentParametersType_AlgorithmSettings::id);
}

void _om__ExperimentParametersType_AlgorithmSettings::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__BasicAlgorithmDefinitionType(soap, &this->_om__ExperimentParametersType_AlgorithmSettings::Algorithm);
#endif
}

int _om__ExperimentParametersType_AlgorithmSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_AlgorithmSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_AlgorithmSettings *a, const char *type)
{
	soap_set_attr(soap, "id", ((_om__ExperimentParametersType_AlgorithmSettings*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings), type))
		return soap->error;
	if (a->_om__ExperimentParametersType_AlgorithmSettings::Algorithm)
	{	if (soap_out_PointerToom__BasicAlgorithmDefinitionType(soap, "om:Algorithm", -1, &a->_om__ExperimentParametersType_AlgorithmSettings::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_AlgorithmSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_AlgorithmSettings(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_AlgorithmSettings * SOAP_FMAC4 soap_in__om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, _om__ExperimentParametersType_AlgorithmSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_AlgorithmSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings, sizeof(_om__ExperimentParametersType_AlgorithmSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_AlgorithmSettings *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_AlgorithmSettings*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Algorithm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__BasicAlgorithmDefinitionType(soap, "om:Algorithm", &(a->_om__ExperimentParametersType_AlgorithmSettings::Algorithm), "om:BasicAlgorithmDefinitionType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_AlgorithmSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings, 0, sizeof(_om__ExperimentParametersType_AlgorithmSettings), 0, soap_copy__om__ExperimentParametersType_AlgorithmSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_AlgorithmSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-AlgorithmSettings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_AlgorithmSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_AlgorithmSettings(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_AlgorithmSettings * SOAP_FMAC4 soap_get__om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, _om__ExperimentParametersType_AlgorithmSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_AlgorithmSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_AlgorithmSettings * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_AlgorithmSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_AlgorithmSettings);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_AlgorithmSettings);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_AlgorithmSettings, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_AlgorithmSettings);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_AlgorithmSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_AlgorithmSettings %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_AlgorithmSettings*)p = *(_om__ExperimentParametersType_AlgorithmSettings*)q;
}

void _om__ExperimentParametersType_Absence_Point::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_Absence_Point::Id = NULL;
	soap_default_std__string(soap, &this->_om__ExperimentParametersType_Absence_Point::X);
	soap_default_std__string(soap, &this->_om__ExperimentParametersType_Absence_Point::Y);
	this->_om__ExperimentParametersType_Absence_Point::Sample = NULL;
}

void _om__ExperimentParametersType_Absence_Point::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__ExperimentParametersType_Absence_Point::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Absence_Point(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Absence_Point(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Absence_Point *a, const char *type)
{
	if (((_om__ExperimentParametersType_Absence_Point*)a)->Id)
		soap_set_attr(soap, "Id", ((_om__ExperimentParametersType_Absence_Point*)a)->Id->c_str(), 1);
	soap_set_attr(soap, "X", ((_om__ExperimentParametersType_Absence_Point*)a)->X.c_str(), 1);
	soap_set_attr(soap, "Y", ((_om__ExperimentParametersType_Absence_Point*)a)->Y.c_str(), 1);
	if (((_om__ExperimentParametersType_Absence_Point*)a)->Sample)
		soap_set_attr(soap, "Sample", ((_om__ExperimentParametersType_Absence_Point*)a)->Sample->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Absence_Point::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Absence_Point(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Absence_Point * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Absence_Point(struct soap *soap, const char *tag, _om__ExperimentParametersType_Absence_Point *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Absence_Point *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point, sizeof(_om__ExperimentParametersType_Absence_Point), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Absence_Point *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Absence_Point*)a)->Id = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Absence_Point*)a)->Id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "X", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Absence_Point*)a)->X.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Absence_Point*)a)->Y.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Sample", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Absence_Point*)a)->Sample = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Absence_Point*)a)->Sample->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Absence_Point *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point, 0, sizeof(_om__ExperimentParametersType_Absence_Point), 0, soap_copy__om__ExperimentParametersType_Absence_Point);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Absence_Point::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Absence-Point", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Absence_Point::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Absence_Point(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Absence_Point * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Absence_Point(struct soap *soap, _om__ExperimentParametersType_Absence_Point *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Absence_Point(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Absence_Point * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Absence_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Absence_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Absence_Point);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Absence_Point);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Absence_Point, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Absence_Point);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Absence_Point*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Absence_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Absence_Point %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Absence_Point*)p = *(_om__ExperimentParametersType_Absence_Point*)q;
}

void _om__ExperimentParametersType_Absence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_Absence::CoordinateSystem = NULL;
	soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, &this->_om__ExperimentParametersType_Absence::Point);
	this->_om__ExperimentParametersType_Absence::Count = NULL;
	this->_om__ExperimentParametersType_Absence::Label = NULL;
	soap_default_xsd__ID(soap, &this->_om__ExperimentParametersType_Absence::id);
}

void _om__ExperimentParametersType_Absence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_om__ExperimentParametersType_Absence::CoordinateSystem);
	soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, &this->_om__ExperimentParametersType_Absence::Point);
#endif
}

int _om__ExperimentParametersType_Absence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Absence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Absence *a, const char *type)
{
	if (((_om__ExperimentParametersType_Absence*)a)->Count)
		soap_set_attr(soap, "Count", soap_int2s(soap, *((_om__ExperimentParametersType_Absence*)a)->Count), 1);
	if (((_om__ExperimentParametersType_Absence*)a)->Label)
		soap_set_attr(soap, "Label", ((_om__ExperimentParametersType_Absence*)a)->Label->c_str(), 1);
	soap_set_attr(soap, "id", ((_om__ExperimentParametersType_Absence*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Absence), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "om:CoordinateSystem", -1, &(a->_om__ExperimentParametersType_Absence::CoordinateSystem), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, "om:Point", -1, &(a->_om__ExperimentParametersType_Absence::Point), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Absence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Absence(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Absence * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, _om__ExperimentParametersType_Absence *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Absence *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Absence, sizeof(_om__ExperimentParametersType_Absence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Absence)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Absence *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Count", 0);
		if (t)
		{
			if (!(((_om__ExperimentParametersType_Absence*)a)->Count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__ExperimentParametersType_Absence*)a)->Count))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Label", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Absence*)a)->Label = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Absence*)a)->Label->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Absence*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_CoordinateSystem1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CoordinateSystem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:CoordinateSystem", &(a->_om__ExperimentParametersType_Absence::CoordinateSystem), "xsd:string"))
				{	soap_flag_CoordinateSystem1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, "om:Point", &(a->_om__ExperimentParametersType_Absence::Point), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Absence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Absence, 0, sizeof(_om__ExperimentParametersType_Absence), 0, soap_copy__om__ExperimentParametersType_Absence);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__ExperimentParametersType_Absence::Point.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Absence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Absence);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Absence", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Absence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Absence(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Absence * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Absence(struct soap *soap, _om__ExperimentParametersType_Absence *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Absence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Absence * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Absence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Absence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Absence, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Absence);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Absence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Absence, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Absence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Absence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Absence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Absence %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Absence*)p = *(_om__ExperimentParametersType_Absence*)q;
}

void _om__ExperimentParametersType_Presence_Point::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_Presence_Point::Id = NULL;
	soap_default_std__string(soap, &this->_om__ExperimentParametersType_Presence_Point::X);
	soap_default_std__string(soap, &this->_om__ExperimentParametersType_Presence_Point::Y);
	this->_om__ExperimentParametersType_Presence_Point::Sample = NULL;
}

void _om__ExperimentParametersType_Presence_Point::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__ExperimentParametersType_Presence_Point::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Presence_Point(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Presence_Point(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Presence_Point *a, const char *type)
{
	if (((_om__ExperimentParametersType_Presence_Point*)a)->Id)
		soap_set_attr(soap, "Id", ((_om__ExperimentParametersType_Presence_Point*)a)->Id->c_str(), 1);
	soap_set_attr(soap, "X", ((_om__ExperimentParametersType_Presence_Point*)a)->X.c_str(), 1);
	soap_set_attr(soap, "Y", ((_om__ExperimentParametersType_Presence_Point*)a)->Y.c_str(), 1);
	if (((_om__ExperimentParametersType_Presence_Point*)a)->Sample)
		soap_set_attr(soap, "Sample", ((_om__ExperimentParametersType_Presence_Point*)a)->Sample->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Presence_Point::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Presence_Point(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Presence_Point * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Presence_Point(struct soap *soap, const char *tag, _om__ExperimentParametersType_Presence_Point *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Presence_Point *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point, sizeof(_om__ExperimentParametersType_Presence_Point), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Presence_Point *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Presence_Point*)a)->Id = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Presence_Point*)a)->Id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "X", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Presence_Point*)a)->X.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Presence_Point*)a)->Y.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Sample", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Presence_Point*)a)->Sample = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Presence_Point*)a)->Sample->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Presence_Point *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point, 0, sizeof(_om__ExperimentParametersType_Presence_Point), 0, soap_copy__om__ExperimentParametersType_Presence_Point);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Presence_Point::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Presence-Point", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Presence_Point::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Presence_Point(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Presence_Point * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Presence_Point(struct soap *soap, _om__ExperimentParametersType_Presence_Point *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Presence_Point(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Presence_Point * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Presence_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Presence_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Presence_Point);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Presence_Point);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Presence_Point, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Presence_Point);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Presence_Point*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Presence_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Presence_Point %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Presence_Point*)p = *(_om__ExperimentParametersType_Presence_Point*)q;
}

void _om__ExperimentParametersType_Presence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__ExperimentParametersType_Presence::CoordinateSystem = NULL;
	soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, &this->_om__ExperimentParametersType_Presence::Point);
	this->_om__ExperimentParametersType_Presence::Count = NULL;
	this->_om__ExperimentParametersType_Presence::Label = NULL;
	soap_default_xsd__ID(soap, &this->_om__ExperimentParametersType_Presence::id);
}

void _om__ExperimentParametersType_Presence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_om__ExperimentParametersType_Presence::CoordinateSystem);
	soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, &this->_om__ExperimentParametersType_Presence::Point);
#endif
}

int _om__ExperimentParametersType_Presence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Presence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Presence *a, const char *type)
{
	if (((_om__ExperimentParametersType_Presence*)a)->Count)
		soap_set_attr(soap, "Count", soap_int2s(soap, *((_om__ExperimentParametersType_Presence*)a)->Count), 1);
	if (((_om__ExperimentParametersType_Presence*)a)->Label)
		soap_set_attr(soap, "Label", ((_om__ExperimentParametersType_Presence*)a)->Label->c_str(), 1);
	soap_set_attr(soap, "id", ((_om__ExperimentParametersType_Presence*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Presence), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "om:CoordinateSystem", -1, &(a->_om__ExperimentParametersType_Presence::CoordinateSystem), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, "om:Point", -1, &(a->_om__ExperimentParametersType_Presence::Point), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Presence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Presence(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Presence * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, _om__ExperimentParametersType_Presence *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Presence *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Presence, sizeof(_om__ExperimentParametersType_Presence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Presence)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Presence *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Count", 0);
		if (t)
		{
			if (!(((_om__ExperimentParametersType_Presence*)a)->Count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__ExperimentParametersType_Presence*)a)->Count))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Label", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__ExperimentParametersType_Presence*)a)->Label = soap_new_std__string(soap, -1);
				((_om__ExperimentParametersType_Presence*)a)->Label->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Presence*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_CoordinateSystem1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CoordinateSystem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:CoordinateSystem", &(a->_om__ExperimentParametersType_Presence::CoordinateSystem), "xsd:string"))
				{	soap_flag_CoordinateSystem1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, "om:Point", &(a->_om__ExperimentParametersType_Presence::Point), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Presence *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Presence, 0, sizeof(_om__ExperimentParametersType_Presence), 0, soap_copy__om__ExperimentParametersType_Presence);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__ExperimentParametersType_Presence::Point.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Presence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Presence);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Presence", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Presence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Presence(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Presence * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Presence(struct soap *soap, _om__ExperimentParametersType_Presence *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Presence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Presence * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Presence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Presence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Presence, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Presence);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Presence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Presence, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Presence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Presence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Presence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Presence %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Presence*)p = *(_om__ExperimentParametersType_Presence*)q;
}

void _om__ExperimentParametersType_Environment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, &this->_om__ExperimentParametersType_Environment::Map);
	this->_om__ExperimentParametersType_Environment::Mask = NULL;
	this->_om__ExperimentParametersType_Environment::NumLayers = NULL;
	soap_default_xsd__ID(soap, &this->_om__ExperimentParametersType_Environment::id);
}

void _om__ExperimentParametersType_Environment::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, &this->_om__ExperimentParametersType_Environment::Map);
	soap_serialize_PointerToom__BasicLayerType(soap, &this->_om__ExperimentParametersType_Environment::Mask);
#endif
}

int _om__ExperimentParametersType_Environment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ExperimentParametersType_Environment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ExperimentParametersType_Environment(struct soap *soap, const char *tag, int id, const _om__ExperimentParametersType_Environment *a, const char *type)
{
	if (((_om__ExperimentParametersType_Environment*)a)->NumLayers)
		soap_set_attr(soap, "NumLayers", soap_int2s(soap, *((_om__ExperimentParametersType_Environment*)a)->NumLayers), 1);
	soap_set_attr(soap, "id", ((_om__ExperimentParametersType_Environment*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ExperimentParametersType_Environment), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, "om:Map", -1, &(a->_om__ExperimentParametersType_Environment::Map), ""))
		return soap->error;
	if (a->_om__ExperimentParametersType_Environment::Mask)
	{	if (soap_out_PointerToom__BasicLayerType(soap, "om:Mask", -1, &a->_om__ExperimentParametersType_Environment::Mask, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Mask"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ExperimentParametersType_Environment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ExperimentParametersType_Environment(soap, tag, this, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Environment * SOAP_FMAC4 soap_in__om__ExperimentParametersType_Environment(struct soap *soap, const char *tag, _om__ExperimentParametersType_Environment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ExperimentParametersType_Environment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ExperimentParametersType_Environment, sizeof(_om__ExperimentParametersType_Environment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ExperimentParametersType_Environment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ExperimentParametersType_Environment *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "NumLayers", 0);
		if (t)
		{
			if (!(((_om__ExperimentParametersType_Environment*)a)->NumLayers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__ExperimentParametersType_Environment*)a)->NumLayers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ExperimentParametersType_Environment*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Mask1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, "om:Map", &(a->_om__ExperimentParametersType_Environment::Map), "om:ModellingLayerType"))
					continue;
			if (soap_flag_Mask1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__BasicLayerType(soap, "om:Mask", &(a->_om__ExperimentParametersType_Environment::Mask), "om:BasicLayerType"))
				{	soap_flag_Mask1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ExperimentParametersType_Environment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ExperimentParametersType_Environment, 0, sizeof(_om__ExperimentParametersType_Environment), 0, soap_copy__om__ExperimentParametersType_Environment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__ExperimentParametersType_Environment::Map.size() < 1 || soap_flag_Mask1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__ExperimentParametersType_Environment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ExperimentParametersType_Environment);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType-Environment", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ExperimentParametersType_Environment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ExperimentParametersType_Environment(soap, this, tag, type);
}

SOAP_FMAC3 _om__ExperimentParametersType_Environment * SOAP_FMAC4 soap_get__om__ExperimentParametersType_Environment(struct soap *soap, _om__ExperimentParametersType_Environment *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ExperimentParametersType_Environment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ExperimentParametersType_Environment * SOAP_FMAC2 soap_instantiate__om__ExperimentParametersType_Environment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ExperimentParametersType_Environment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ExperimentParametersType_Environment, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ExperimentParametersType_Environment);
		if (size)
			*size = sizeof(_om__ExperimentParametersType_Environment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ExperimentParametersType_Environment, n);
		if (size)
			*size = n * sizeof(_om__ExperimentParametersType_Environment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ExperimentParametersType_Environment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ExperimentParametersType_Environment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ExperimentParametersType_Environment %p -> %p\n", q, p));
	*(_om__ExperimentParametersType_Environment*)p = *(_om__ExperimentParametersType_Environment*)q;
}

void _om__ModelEvaluationResultType_Values::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__ModelEvaluationResultType_Values::V);
}

void _om__ModelEvaluationResultType_Values::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__ModelEvaluationResultType_Values::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ModelEvaluationResultType_Values(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ModelEvaluationResultType_Values(struct soap *soap, const char *tag, int id, const _om__ModelEvaluationResultType_Values *a, const char *type)
{
	soap_set_attr(soap, "V", ((_om__ModelEvaluationResultType_Values*)a)->V.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ModelEvaluationResultType_Values), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ModelEvaluationResultType_Values::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ModelEvaluationResultType_Values(soap, tag, this, type);
}

SOAP_FMAC3 _om__ModelEvaluationResultType_Values * SOAP_FMAC4 soap_in__om__ModelEvaluationResultType_Values(struct soap *soap, const char *tag, _om__ModelEvaluationResultType_Values *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ModelEvaluationResultType_Values *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ModelEvaluationResultType_Values, sizeof(_om__ModelEvaluationResultType_Values), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ModelEvaluationResultType_Values)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ModelEvaluationResultType_Values *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "V", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__ModelEvaluationResultType_Values*)a)->V.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ModelEvaluationResultType_Values *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ModelEvaluationResultType_Values, 0, sizeof(_om__ModelEvaluationResultType_Values), 0, soap_copy__om__ModelEvaluationResultType_Values);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ModelEvaluationResultType_Values::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ModelEvaluationResultType_Values);
	if (this->soap_out(soap, tag?tag:"om:ModelEvaluationResultType-Values", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ModelEvaluationResultType_Values::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ModelEvaluationResultType_Values(soap, this, tag, type);
}

SOAP_FMAC3 _om__ModelEvaluationResultType_Values * SOAP_FMAC4 soap_get__om__ModelEvaluationResultType_Values(struct soap *soap, _om__ModelEvaluationResultType_Values *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ModelEvaluationResultType_Values(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ModelEvaluationResultType_Values * SOAP_FMAC2 soap_instantiate__om__ModelEvaluationResultType_Values(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ModelEvaluationResultType_Values(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ModelEvaluationResultType_Values, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ModelEvaluationResultType_Values);
		if (size)
			*size = sizeof(_om__ModelEvaluationResultType_Values);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ModelEvaluationResultType_Values, n);
		if (size)
			*size = n * sizeof(_om__ModelEvaluationResultType_Values);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ModelEvaluationResultType_Values*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ModelEvaluationResultType_Values(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ModelEvaluationResultType_Values %p -> %p\n", q, p));
	*(_om__ModelEvaluationResultType_Values*)p = *(_om__ModelEvaluationResultType_Values*)q;
}

void _om__OccurrencesFilterType_EnvironmentallyUnique::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _om__OccurrencesFilterType_EnvironmentallyUnique::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__OccurrencesFilterType_EnvironmentallyUnique::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, const char *tag, int id, const _om__OccurrencesFilterType_EnvironmentallyUnique *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__OccurrencesFilterType_EnvironmentallyUnique::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag, this, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_EnvironmentallyUnique * SOAP_FMAC4 soap_in__om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, const char *tag, _om__OccurrencesFilterType_EnvironmentallyUnique *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__OccurrencesFilterType_EnvironmentallyUnique *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique, sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__OccurrencesFilterType_EnvironmentallyUnique *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__OccurrencesFilterType_EnvironmentallyUnique *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique, 0, sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique), 0, soap_copy__om__OccurrencesFilterType_EnvironmentallyUnique);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__OccurrencesFilterType_EnvironmentallyUnique::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique);
	if (this->soap_out(soap, tag?tag:"om:OccurrencesFilterType-EnvironmentallyUnique", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__OccurrencesFilterType_EnvironmentallyUnique::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__OccurrencesFilterType_EnvironmentallyUnique(soap, this, tag, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_EnvironmentallyUnique * SOAP_FMAC4 soap_get__om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, _om__OccurrencesFilterType_EnvironmentallyUnique *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__OccurrencesFilterType_EnvironmentallyUnique * SOAP_FMAC2 soap_instantiate__om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__OccurrencesFilterType_EnvironmentallyUnique(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__OccurrencesFilterType_EnvironmentallyUnique);
		if (size)
			*size = sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__OccurrencesFilterType_EnvironmentallyUnique, n);
		if (size)
			*size = n * sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__OccurrencesFilterType_EnvironmentallyUnique*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__OccurrencesFilterType_EnvironmentallyUnique %p -> %p\n", q, p));
	*(_om__OccurrencesFilterType_EnvironmentallyUnique*)p = *(_om__OccurrencesFilterType_EnvironmentallyUnique*)q;
}

void _om__OccurrencesFilterType_SpatiallyUnique::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _om__OccurrencesFilterType_SpatiallyUnique::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__OccurrencesFilterType_SpatiallyUnique::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__OccurrencesFilterType_SpatiallyUnique(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, const char *tag, int id, const _om__OccurrencesFilterType_SpatiallyUnique *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__OccurrencesFilterType_SpatiallyUnique::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__OccurrencesFilterType_SpatiallyUnique(soap, tag, this, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_SpatiallyUnique * SOAP_FMAC4 soap_in__om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, const char *tag, _om__OccurrencesFilterType_SpatiallyUnique *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__OccurrencesFilterType_SpatiallyUnique *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique, sizeof(_om__OccurrencesFilterType_SpatiallyUnique), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__OccurrencesFilterType_SpatiallyUnique *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__OccurrencesFilterType_SpatiallyUnique *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique, 0, sizeof(_om__OccurrencesFilterType_SpatiallyUnique), 0, soap_copy__om__OccurrencesFilterType_SpatiallyUnique);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__OccurrencesFilterType_SpatiallyUnique::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique);
	if (this->soap_out(soap, tag?tag:"om:OccurrencesFilterType-SpatiallyUnique", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__OccurrencesFilterType_SpatiallyUnique::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__OccurrencesFilterType_SpatiallyUnique(soap, this, tag, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_SpatiallyUnique * SOAP_FMAC4 soap_get__om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, _om__OccurrencesFilterType_SpatiallyUnique *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__OccurrencesFilterType_SpatiallyUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__OccurrencesFilterType_SpatiallyUnique * SOAP_FMAC2 soap_instantiate__om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__OccurrencesFilterType_SpatiallyUnique(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__OccurrencesFilterType_SpatiallyUnique);
		if (size)
			*size = sizeof(_om__OccurrencesFilterType_SpatiallyUnique);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__OccurrencesFilterType_SpatiallyUnique, n);
		if (size)
			*size = n * sizeof(_om__OccurrencesFilterType_SpatiallyUnique);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__OccurrencesFilterType_SpatiallyUnique*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__OccurrencesFilterType_SpatiallyUnique %p -> %p\n", q, p));
	*(_om__OccurrencesFilterType_SpatiallyUnique*)p = *(_om__OccurrencesFilterType_SpatiallyUnique*)q;
}

void _om__ProjectionStatisticsParametersType_AreaStatistics::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_om__ZeroOneIntervalType(soap, &this->_om__ProjectionStatisticsParametersType_AreaStatistics::PredictionThreshold);
}

void _om__ProjectionStatisticsParametersType_AreaStatistics::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__ProjectionStatisticsParametersType_AreaStatistics::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, const char *tag, int id, const _om__ProjectionStatisticsParametersType_AreaStatistics *a, const char *type)
{
	soap_set_attr(soap, "PredictionThreshold", soap_double2s(soap, ((_om__ProjectionStatisticsParametersType_AreaStatistics*)a)->PredictionThreshold), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__ProjectionStatisticsParametersType_AreaStatistics::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag, this, type);
}

SOAP_FMAC3 _om__ProjectionStatisticsParametersType_AreaStatistics * SOAP_FMAC4 soap_in__om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, const char *tag, _om__ProjectionStatisticsParametersType_AreaStatistics *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__ProjectionStatisticsParametersType_AreaStatistics *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics, sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__ProjectionStatisticsParametersType_AreaStatistics *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2double(soap, soap_attr_value(soap, "PredictionThreshold", 1), &((_om__ProjectionStatisticsParametersType_AreaStatistics*)a)->PredictionThreshold))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__ProjectionStatisticsParametersType_AreaStatistics *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics, 0, sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics), 0, soap_copy__om__ProjectionStatisticsParametersType_AreaStatistics);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__ProjectionStatisticsParametersType_AreaStatistics::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics);
	if (this->soap_out(soap, tag?tag:"om:ProjectionStatisticsParametersType-AreaStatistics", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__ProjectionStatisticsParametersType_AreaStatistics::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__ProjectionStatisticsParametersType_AreaStatistics(soap, this, tag, type);
}

SOAP_FMAC3 _om__ProjectionStatisticsParametersType_AreaStatistics * SOAP_FMAC4 soap_get__om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, _om__ProjectionStatisticsParametersType_AreaStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__ProjectionStatisticsParametersType_AreaStatistics * SOAP_FMAC2 soap_instantiate__om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__ProjectionStatisticsParametersType_AreaStatistics(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__ProjectionStatisticsParametersType_AreaStatistics);
		if (size)
			*size = sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__ProjectionStatisticsParametersType_AreaStatistics, n);
		if (size)
			*size = n * sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__ProjectionStatisticsParametersType_AreaStatistics*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__ProjectionStatisticsParametersType_AreaStatistics %p -> %p\n", q, p));
	*(_om__ProjectionStatisticsParametersType_AreaStatistics*)p = *(_om__ProjectionStatisticsParametersType_AreaStatistics*)q;
}

void _om__TestResultType_RocCurve_Ratio::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_double(soap, &this->_om__TestResultType_RocCurve_Ratio::E);
	soap_default_double(soap, &this->_om__TestResultType_RocCurve_Ratio::Value);
}

void _om__TestResultType_RocCurve_Ratio::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__TestResultType_RocCurve_Ratio::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__TestResultType_RocCurve_Ratio(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__TestResultType_RocCurve_Ratio(struct soap *soap, const char *tag, int id, const _om__TestResultType_RocCurve_Ratio *a, const char *type)
{
	soap_set_attr(soap, "E", soap_double2s(soap, ((_om__TestResultType_RocCurve_Ratio*)a)->E), 1);
	soap_set_attr(soap, "Value", soap_double2s(soap, ((_om__TestResultType_RocCurve_Ratio*)a)->Value), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__TestResultType_RocCurve_Ratio::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__TestResultType_RocCurve_Ratio(soap, tag, this, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve_Ratio * SOAP_FMAC4 soap_in__om__TestResultType_RocCurve_Ratio(struct soap *soap, const char *tag, _om__TestResultType_RocCurve_Ratio *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__TestResultType_RocCurve_Ratio *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio, sizeof(_om__TestResultType_RocCurve_Ratio), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__TestResultType_RocCurve_Ratio *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2double(soap, soap_attr_value(soap, "E", 1), &((_om__TestResultType_RocCurve_Ratio*)a)->E))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Value", 1), &((_om__TestResultType_RocCurve_Ratio*)a)->Value))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__TestResultType_RocCurve_Ratio *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio, 0, sizeof(_om__TestResultType_RocCurve_Ratio), 0, soap_copy__om__TestResultType_RocCurve_Ratio);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__TestResultType_RocCurve_Ratio::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio);
	if (this->soap_out(soap, tag?tag:"om:TestResultType-RocCurve-Ratio", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__TestResultType_RocCurve_Ratio::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__TestResultType_RocCurve_Ratio(soap, this, tag, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve_Ratio * SOAP_FMAC4 soap_get__om__TestResultType_RocCurve_Ratio(struct soap *soap, _om__TestResultType_RocCurve_Ratio *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__TestResultType_RocCurve_Ratio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__TestResultType_RocCurve_Ratio * SOAP_FMAC2 soap_instantiate__om__TestResultType_RocCurve_Ratio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__TestResultType_RocCurve_Ratio(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__TestResultType_RocCurve_Ratio);
		if (size)
			*size = sizeof(_om__TestResultType_RocCurve_Ratio);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__TestResultType_RocCurve_Ratio, n);
		if (size)
			*size = n * sizeof(_om__TestResultType_RocCurve_Ratio);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__TestResultType_RocCurve_Ratio*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__TestResultType_RocCurve_Ratio(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__TestResultType_RocCurve_Ratio %p -> %p\n", q, p));
	*(_om__TestResultType_RocCurve_Ratio*)p = *(_om__TestResultType_RocCurve_Ratio*)q;
}

void _om__TestResultType_RocCurve::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__TestResultType_RocCurve::Ratio = NULL;
	soap_default_om__ZeroOneIntervalType(soap, &this->_om__TestResultType_RocCurve::Auc);
	soap_default_std__string(soap, &this->_om__TestResultType_RocCurve::Points);
	this->_om__TestResultType_RocCurve::NumBackgroundPoints = NULL;
}

void _om__TestResultType_RocCurve::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_om__TestResultType_RocCurve_Ratio(soap, &this->_om__TestResultType_RocCurve::Ratio);
#endif
}

int _om__TestResultType_RocCurve::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__TestResultType_RocCurve(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__TestResultType_RocCurve(struct soap *soap, const char *tag, int id, const _om__TestResultType_RocCurve *a, const char *type)
{
	soap_set_attr(soap, "Auc", soap_double2s(soap, ((_om__TestResultType_RocCurve*)a)->Auc), 1);
	soap_set_attr(soap, "Points", ((_om__TestResultType_RocCurve*)a)->Points.c_str(), 1);
	if (((_om__TestResultType_RocCurve*)a)->NumBackgroundPoints)
		soap_set_attr(soap, "NumBackgroundPoints", soap_int2s(soap, *((_om__TestResultType_RocCurve*)a)->NumBackgroundPoints), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__TestResultType_RocCurve), type))
		return soap->error;
	if (soap_out_PointerTo_om__TestResultType_RocCurve_Ratio(soap, "om:Ratio", -1, &(a->_om__TestResultType_RocCurve::Ratio), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__TestResultType_RocCurve::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__TestResultType_RocCurve(soap, tag, this, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve * SOAP_FMAC4 soap_in__om__TestResultType_RocCurve(struct soap *soap, const char *tag, _om__TestResultType_RocCurve *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__TestResultType_RocCurve *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__TestResultType_RocCurve, sizeof(_om__TestResultType_RocCurve), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__TestResultType_RocCurve)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__TestResultType_RocCurve *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2double(soap, soap_attr_value(soap, "Auc", 1), &((_om__TestResultType_RocCurve*)a)->Auc))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Points", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__TestResultType_RocCurve*)a)->Points.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NumBackgroundPoints", 0);
		if (t)
		{
			if (!(((_om__TestResultType_RocCurve*)a)->NumBackgroundPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__TestResultType_RocCurve*)a)->NumBackgroundPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Ratio1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Ratio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__TestResultType_RocCurve_Ratio(soap, "om:Ratio", &(a->_om__TestResultType_RocCurve::Ratio), ""))
				{	soap_flag_Ratio1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__TestResultType_RocCurve *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__TestResultType_RocCurve, 0, sizeof(_om__TestResultType_RocCurve), 0, soap_copy__om__TestResultType_RocCurve);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__TestResultType_RocCurve::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__TestResultType_RocCurve);
	if (this->soap_out(soap, tag?tag:"om:TestResultType-RocCurve", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__TestResultType_RocCurve::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__TestResultType_RocCurve(soap, this, tag, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve * SOAP_FMAC4 soap_get__om__TestResultType_RocCurve(struct soap *soap, _om__TestResultType_RocCurve *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__TestResultType_RocCurve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__TestResultType_RocCurve * SOAP_FMAC2 soap_instantiate__om__TestResultType_RocCurve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__TestResultType_RocCurve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__TestResultType_RocCurve, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__TestResultType_RocCurve);
		if (size)
			*size = sizeof(_om__TestResultType_RocCurve);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__TestResultType_RocCurve, n);
		if (size)
			*size = n * sizeof(_om__TestResultType_RocCurve);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__TestResultType_RocCurve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__TestResultType_RocCurve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__TestResultType_RocCurve %p -> %p\n", q, p));
	*(_om__TestResultType_RocCurve*)p = *(_om__TestResultType_RocCurve*)q;
}

void _om__TestResultType_ConfusionMatrix::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_om__ZeroOneIntervalType(soap, &this->_om__TestResultType_ConfusionMatrix::Threshold);
	soap_default_double(soap, &this->_om__TestResultType_ConfusionMatrix::Accuracy);
	soap_default_double(soap, &this->_om__TestResultType_ConfusionMatrix::OmissionError);
	soap_default_double(soap, &this->_om__TestResultType_ConfusionMatrix::CommissionError);
	soap_default_int(soap, &this->_om__TestResultType_ConfusionMatrix::TruePositives);
	soap_default_int(soap, &this->_om__TestResultType_ConfusionMatrix::FalsePositives);
	soap_default_int(soap, &this->_om__TestResultType_ConfusionMatrix::TrueNegatives);
	soap_default_int(soap, &this->_om__TestResultType_ConfusionMatrix::FalseNegatives);
}

void _om__TestResultType_ConfusionMatrix::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__TestResultType_ConfusionMatrix::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__TestResultType_ConfusionMatrix(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__TestResultType_ConfusionMatrix(struct soap *soap, const char *tag, int id, const _om__TestResultType_ConfusionMatrix *a, const char *type)
{
	soap_set_attr(soap, "Threshold", soap_double2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->Threshold), 1);
	soap_set_attr(soap, "Accuracy", soap_double2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->Accuracy), 1);
	soap_set_attr(soap, "OmissionError", soap_double2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->OmissionError), 1);
	soap_set_attr(soap, "CommissionError", soap_double2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->CommissionError), 1);
	soap_set_attr(soap, "TruePositives", soap_int2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->TruePositives), 1);
	soap_set_attr(soap, "FalsePositives", soap_int2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->FalsePositives), 1);
	soap_set_attr(soap, "TrueNegatives", soap_int2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->TrueNegatives), 1);
	soap_set_attr(soap, "FalseNegatives", soap_int2s(soap, ((_om__TestResultType_ConfusionMatrix*)a)->FalseNegatives), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__TestResultType_ConfusionMatrix::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__TestResultType_ConfusionMatrix(soap, tag, this, type);
}

SOAP_FMAC3 _om__TestResultType_ConfusionMatrix * SOAP_FMAC4 soap_in__om__TestResultType_ConfusionMatrix(struct soap *soap, const char *tag, _om__TestResultType_ConfusionMatrix *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__TestResultType_ConfusionMatrix *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix, sizeof(_om__TestResultType_ConfusionMatrix), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__TestResultType_ConfusionMatrix)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__TestResultType_ConfusionMatrix *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2double(soap, soap_attr_value(soap, "Threshold", 1), &((_om__TestResultType_ConfusionMatrix*)a)->Threshold))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "Accuracy", 1), &((_om__TestResultType_ConfusionMatrix*)a)->Accuracy))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "OmissionError", 1), &((_om__TestResultType_ConfusionMatrix*)a)->OmissionError))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "CommissionError", 1), &((_om__TestResultType_ConfusionMatrix*)a)->CommissionError))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "TruePositives", 1), &((_om__TestResultType_ConfusionMatrix*)a)->TruePositives))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "FalsePositives", 1), &((_om__TestResultType_ConfusionMatrix*)a)->FalsePositives))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "TrueNegatives", 1), &((_om__TestResultType_ConfusionMatrix*)a)->TrueNegatives))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "FalseNegatives", 1), &((_om__TestResultType_ConfusionMatrix*)a)->FalseNegatives))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__TestResultType_ConfusionMatrix *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix, 0, sizeof(_om__TestResultType_ConfusionMatrix), 0, soap_copy__om__TestResultType_ConfusionMatrix);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__TestResultType_ConfusionMatrix::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix);
	if (this->soap_out(soap, tag?tag:"om:TestResultType-ConfusionMatrix", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__TestResultType_ConfusionMatrix::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__TestResultType_ConfusionMatrix(soap, this, tag, type);
}

SOAP_FMAC3 _om__TestResultType_ConfusionMatrix * SOAP_FMAC4 soap_get__om__TestResultType_ConfusionMatrix(struct soap *soap, _om__TestResultType_ConfusionMatrix *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__TestResultType_ConfusionMatrix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__TestResultType_ConfusionMatrix * SOAP_FMAC2 soap_instantiate__om__TestResultType_ConfusionMatrix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__TestResultType_ConfusionMatrix(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__TestResultType_ConfusionMatrix);
		if (size)
			*size = sizeof(_om__TestResultType_ConfusionMatrix);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__TestResultType_ConfusionMatrix, n);
		if (size)
			*size = n * sizeof(_om__TestResultType_ConfusionMatrix);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__TestResultType_ConfusionMatrix*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__TestResultType_ConfusionMatrix(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__TestResultType_ConfusionMatrix %p -> %p\n", q, p));
	*(_om__TestResultType_ConfusionMatrix*)p = *(_om__TestResultType_ConfusionMatrix*)q;
}

void _om__TestOptionsType_RocCurve::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__TestOptionsType_RocCurve::Resolution = NULL;
	this->_om__TestOptionsType_RocCurve::BackgroundPoints = NULL;
	this->_om__TestOptionsType_RocCurve::MaxOmission = NULL;
	this->_om__TestOptionsType_RocCurve::UseAbsencesAsBackground = NULL;
}

void _om__TestOptionsType_RocCurve::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__TestOptionsType_RocCurve::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__TestOptionsType_RocCurve(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__TestOptionsType_RocCurve(struct soap *soap, const char *tag, int id, const _om__TestOptionsType_RocCurve *a, const char *type)
{
	if (((_om__TestOptionsType_RocCurve*)a)->Resolution)
		soap_set_attr(soap, "Resolution", soap_int2s(soap, *((_om__TestOptionsType_RocCurve*)a)->Resolution), 1);
	if (((_om__TestOptionsType_RocCurve*)a)->BackgroundPoints)
		soap_set_attr(soap, "BackgroundPoints", soap_int2s(soap, *((_om__TestOptionsType_RocCurve*)a)->BackgroundPoints), 1);
	if (((_om__TestOptionsType_RocCurve*)a)->MaxOmission)
		soap_set_attr(soap, "MaxOmission", soap_double2s(soap, *((_om__TestOptionsType_RocCurve*)a)->MaxOmission), 1);
	if (((_om__TestOptionsType_RocCurve*)a)->UseAbsencesAsBackground)
		soap_set_attr(soap, "UseAbsencesAsBackground", soap_bool2s(soap, *((_om__TestOptionsType_RocCurve*)a)->UseAbsencesAsBackground), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__TestOptionsType_RocCurve), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__TestOptionsType_RocCurve::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__TestOptionsType_RocCurve(soap, tag, this, type);
}

SOAP_FMAC3 _om__TestOptionsType_RocCurve * SOAP_FMAC4 soap_in__om__TestOptionsType_RocCurve(struct soap *soap, const char *tag, _om__TestOptionsType_RocCurve *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__TestOptionsType_RocCurve *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__TestOptionsType_RocCurve, sizeof(_om__TestOptionsType_RocCurve), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__TestOptionsType_RocCurve)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__TestOptionsType_RocCurve *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Resolution", 0);
		if (t)
		{
			if (!(((_om__TestOptionsType_RocCurve*)a)->Resolution = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__TestOptionsType_RocCurve*)a)->Resolution))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "BackgroundPoints", 0);
		if (t)
		{
			if (!(((_om__TestOptionsType_RocCurve*)a)->BackgroundPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((_om__TestOptionsType_RocCurve*)a)->BackgroundPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxOmission", 0);
		if (t)
		{
			if (!(((_om__TestOptionsType_RocCurve*)a)->MaxOmission = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((_om__TestOptionsType_RocCurve*)a)->MaxOmission))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "UseAbsencesAsBackground", 0);
		if (t)
		{
			if (!(((_om__TestOptionsType_RocCurve*)a)->UseAbsencesAsBackground = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((_om__TestOptionsType_RocCurve*)a)->UseAbsencesAsBackground))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__TestOptionsType_RocCurve *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__TestOptionsType_RocCurve, 0, sizeof(_om__TestOptionsType_RocCurve), 0, soap_copy__om__TestOptionsType_RocCurve);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__TestOptionsType_RocCurve::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__TestOptionsType_RocCurve);
	if (this->soap_out(soap, tag?tag:"om:TestOptionsType-RocCurve", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__TestOptionsType_RocCurve::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__TestOptionsType_RocCurve(soap, this, tag, type);
}

SOAP_FMAC3 _om__TestOptionsType_RocCurve * SOAP_FMAC4 soap_get__om__TestOptionsType_RocCurve(struct soap *soap, _om__TestOptionsType_RocCurve *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__TestOptionsType_RocCurve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__TestOptionsType_RocCurve * SOAP_FMAC2 soap_instantiate__om__TestOptionsType_RocCurve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__TestOptionsType_RocCurve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__TestOptionsType_RocCurve, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__TestOptionsType_RocCurve);
		if (size)
			*size = sizeof(_om__TestOptionsType_RocCurve);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__TestOptionsType_RocCurve, n);
		if (size)
			*size = n * sizeof(_om__TestOptionsType_RocCurve);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__TestOptionsType_RocCurve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__TestOptionsType_RocCurve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__TestOptionsType_RocCurve %p -> %p\n", q, p));
	*(_om__TestOptionsType_RocCurve*)p = *(_om__TestOptionsType_RocCurve*)q;
}

void _om__TestOptionsType_ConfusionMatrix::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__TestOptionsType_ConfusionMatrix::Threshold = NULL;
	this->_om__TestOptionsType_ConfusionMatrix::IgnoreAbsences = NULL;
}

void _om__TestOptionsType_ConfusionMatrix::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__TestOptionsType_ConfusionMatrix::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__TestOptionsType_ConfusionMatrix(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__TestOptionsType_ConfusionMatrix(struct soap *soap, const char *tag, int id, const _om__TestOptionsType_ConfusionMatrix *a, const char *type)
{
	if (((_om__TestOptionsType_ConfusionMatrix*)a)->Threshold)
		soap_set_attr(soap, "Threshold", ((_om__TestOptionsType_ConfusionMatrix*)a)->Threshold->c_str(), 1);
	if (((_om__TestOptionsType_ConfusionMatrix*)a)->IgnoreAbsences)
		soap_set_attr(soap, "IgnoreAbsences", soap_bool2s(soap, *((_om__TestOptionsType_ConfusionMatrix*)a)->IgnoreAbsences), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__TestOptionsType_ConfusionMatrix::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__TestOptionsType_ConfusionMatrix(soap, tag, this, type);
}

SOAP_FMAC3 _om__TestOptionsType_ConfusionMatrix * SOAP_FMAC4 soap_in__om__TestOptionsType_ConfusionMatrix(struct soap *soap, const char *tag, _om__TestOptionsType_ConfusionMatrix *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__TestOptionsType_ConfusionMatrix *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix, sizeof(_om__TestOptionsType_ConfusionMatrix), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__TestOptionsType_ConfusionMatrix *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Threshold", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__TestOptionsType_ConfusionMatrix*)a)->Threshold = soap_new_std__string(soap, -1);
				((_om__TestOptionsType_ConfusionMatrix*)a)->Threshold->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "IgnoreAbsences", 0);
		if (t)
		{
			if (!(((_om__TestOptionsType_ConfusionMatrix*)a)->IgnoreAbsences = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((_om__TestOptionsType_ConfusionMatrix*)a)->IgnoreAbsences))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__TestOptionsType_ConfusionMatrix *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix, 0, sizeof(_om__TestOptionsType_ConfusionMatrix), 0, soap_copy__om__TestOptionsType_ConfusionMatrix);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__TestOptionsType_ConfusionMatrix::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix);
	if (this->soap_out(soap, tag?tag:"om:TestOptionsType-ConfusionMatrix", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__TestOptionsType_ConfusionMatrix::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__TestOptionsType_ConfusionMatrix(soap, this, tag, type);
}

SOAP_FMAC3 _om__TestOptionsType_ConfusionMatrix * SOAP_FMAC4 soap_get__om__TestOptionsType_ConfusionMatrix(struct soap *soap, _om__TestOptionsType_ConfusionMatrix *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__TestOptionsType_ConfusionMatrix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__TestOptionsType_ConfusionMatrix * SOAP_FMAC2 soap_instantiate__om__TestOptionsType_ConfusionMatrix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__TestOptionsType_ConfusionMatrix(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__TestOptionsType_ConfusionMatrix);
		if (size)
			*size = sizeof(_om__TestOptionsType_ConfusionMatrix);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__TestOptionsType_ConfusionMatrix, n);
		if (size)
			*size = n * sizeof(_om__TestOptionsType_ConfusionMatrix);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__TestOptionsType_ConfusionMatrix*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__TestOptionsType_ConfusionMatrix(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__TestOptionsType_ConfusionMatrix %p -> %p\n", q, p));
	*(_om__TestOptionsType_ConfusionMatrix*)p = *(_om__TestOptionsType_ConfusionMatrix*)q;
}

void _om__OccurrencesType_Point::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__OccurrencesType_Point::Id = NULL;
	soap_default_std__string(soap, &this->_om__OccurrencesType_Point::X);
	soap_default_std__string(soap, &this->_om__OccurrencesType_Point::Y);
	this->_om__OccurrencesType_Point::Sample = NULL;
}

void _om__OccurrencesType_Point::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__OccurrencesType_Point::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__OccurrencesType_Point(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__OccurrencesType_Point(struct soap *soap, const char *tag, int id, const _om__OccurrencesType_Point *a, const char *type)
{
	if (((_om__OccurrencesType_Point*)a)->Id)
		soap_set_attr(soap, "Id", ((_om__OccurrencesType_Point*)a)->Id->c_str(), 1);
	soap_set_attr(soap, "X", ((_om__OccurrencesType_Point*)a)->X.c_str(), 1);
	soap_set_attr(soap, "Y", ((_om__OccurrencesType_Point*)a)->Y.c_str(), 1);
	if (((_om__OccurrencesType_Point*)a)->Sample)
		soap_set_attr(soap, "Sample", ((_om__OccurrencesType_Point*)a)->Sample->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__OccurrencesType_Point), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__OccurrencesType_Point::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__OccurrencesType_Point(soap, tag, this, type);
}

SOAP_FMAC3 _om__OccurrencesType_Point * SOAP_FMAC4 soap_in__om__OccurrencesType_Point(struct soap *soap, const char *tag, _om__OccurrencesType_Point *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__OccurrencesType_Point *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__OccurrencesType_Point, sizeof(_om__OccurrencesType_Point), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__OccurrencesType_Point)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__OccurrencesType_Point *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__OccurrencesType_Point*)a)->Id = soap_new_std__string(soap, -1);
				((_om__OccurrencesType_Point*)a)->Id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "X", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__OccurrencesType_Point*)a)->X.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__OccurrencesType_Point*)a)->Y.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Sample", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__OccurrencesType_Point*)a)->Sample = soap_new_std__string(soap, -1);
				((_om__OccurrencesType_Point*)a)->Sample->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__OccurrencesType_Point *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__OccurrencesType_Point, 0, sizeof(_om__OccurrencesType_Point), 0, soap_copy__om__OccurrencesType_Point);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__OccurrencesType_Point::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__OccurrencesType_Point);
	if (this->soap_out(soap, tag?tag:"om:OccurrencesType-Point", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__OccurrencesType_Point::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__OccurrencesType_Point(soap, this, tag, type);
}

SOAP_FMAC3 _om__OccurrencesType_Point * SOAP_FMAC4 soap_get__om__OccurrencesType_Point(struct soap *soap, _om__OccurrencesType_Point *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__OccurrencesType_Point(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__OccurrencesType_Point * SOAP_FMAC2 soap_instantiate__om__OccurrencesType_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__OccurrencesType_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__OccurrencesType_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__OccurrencesType_Point);
		if (size)
			*size = sizeof(_om__OccurrencesType_Point);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__OccurrencesType_Point, n);
		if (size)
			*size = n * sizeof(_om__OccurrencesType_Point);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__OccurrencesType_Point*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__OccurrencesType_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__OccurrencesType_Point %p -> %p\n", q, p));
	*(_om__OccurrencesType_Point*)p = *(_om__OccurrencesType_Point*)q;
}

void _om__SerializedAlgorithmType_Model::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_xsd__anyType(soap, &this->_om__SerializedAlgorithmType_Model::__any);
}

void _om__SerializedAlgorithmType_Model::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->_om__SerializedAlgorithmType_Model::__any);
#endif
}

int _om__SerializedAlgorithmType_Model::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__SerializedAlgorithmType_Model(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__SerializedAlgorithmType_Model(struct soap *soap, const char *tag, int id, const _om__SerializedAlgorithmType_Model *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Model), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->_om__SerializedAlgorithmType_Model::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__SerializedAlgorithmType_Model::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__SerializedAlgorithmType_Model(soap, tag, this, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Model * SOAP_FMAC4 soap_in__om__SerializedAlgorithmType_Model(struct soap *soap, const char *tag, _om__SerializedAlgorithmType_Model *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__SerializedAlgorithmType_Model *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Model, sizeof(_om__SerializedAlgorithmType_Model), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__SerializedAlgorithmType_Model)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__SerializedAlgorithmType_Model *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->_om__SerializedAlgorithmType_Model::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__SerializedAlgorithmType_Model *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__SerializedAlgorithmType_Model, 0, sizeof(_om__SerializedAlgorithmType_Model), 0, soap_copy__om__SerializedAlgorithmType_Model);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__SerializedAlgorithmType_Model::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__SerializedAlgorithmType_Model);
	if (this->soap_out(soap, tag?tag:"om:SerializedAlgorithmType-Model", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__SerializedAlgorithmType_Model::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__SerializedAlgorithmType_Model(soap, this, tag, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Model * SOAP_FMAC4 soap_get__om__SerializedAlgorithmType_Model(struct soap *soap, _om__SerializedAlgorithmType_Model *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__SerializedAlgorithmType_Model(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__SerializedAlgorithmType_Model * SOAP_FMAC2 soap_instantiate__om__SerializedAlgorithmType_Model(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__SerializedAlgorithmType_Model(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__SerializedAlgorithmType_Model, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__SerializedAlgorithmType_Model);
		if (size)
			*size = sizeof(_om__SerializedAlgorithmType_Model);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__SerializedAlgorithmType_Model, n);
		if (size)
			*size = n * sizeof(_om__SerializedAlgorithmType_Model);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__SerializedAlgorithmType_Model*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__SerializedAlgorithmType_Model(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__SerializedAlgorithmType_Model %p -> %p\n", q, p));
	*(_om__SerializedAlgorithmType_Model*)p = *(_om__SerializedAlgorithmType_Model*)q;
}

void _om__SerializedAlgorithmType_Parameters_Parameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__SerializedAlgorithmType_Parameters_Parameter::Id);
	soap_default_std__string(soap, &this->_om__SerializedAlgorithmType_Parameters_Parameter::Value);
}

void _om__SerializedAlgorithmType_Parameters_Parameter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__SerializedAlgorithmType_Parameters_Parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const _om__SerializedAlgorithmType_Parameters_Parameter *a, const char *type)
{
	soap_set_attr(soap, "Id", ((_om__SerializedAlgorithmType_Parameters_Parameter*)a)->Id.c_str(), 1);
	soap_set_attr(soap, "Value", ((_om__SerializedAlgorithmType_Parameters_Parameter*)a)->Value.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__SerializedAlgorithmType_Parameters_Parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, this, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Parameters_Parameter * SOAP_FMAC4 soap_in__om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, _om__SerializedAlgorithmType_Parameters_Parameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__SerializedAlgorithmType_Parameters_Parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter, sizeof(_om__SerializedAlgorithmType_Parameters_Parameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__SerializedAlgorithmType_Parameters_Parameter *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__SerializedAlgorithmType_Parameters_Parameter*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Value", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__SerializedAlgorithmType_Parameters_Parameter*)a)->Value.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__SerializedAlgorithmType_Parameters_Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter, 0, sizeof(_om__SerializedAlgorithmType_Parameters_Parameter), 0, soap_copy__om__SerializedAlgorithmType_Parameters_Parameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__SerializedAlgorithmType_Parameters_Parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter);
	if (this->soap_out(soap, tag?tag:"om:SerializedAlgorithmType-Parameters-Parameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__SerializedAlgorithmType_Parameters_Parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__SerializedAlgorithmType_Parameters_Parameter(soap, this, tag, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Parameters_Parameter * SOAP_FMAC4 soap_get__om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, _om__SerializedAlgorithmType_Parameters_Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__SerializedAlgorithmType_Parameters_Parameter * SOAP_FMAC2 soap_instantiate__om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__SerializedAlgorithmType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__SerializedAlgorithmType_Parameters_Parameter);
		if (size)
			*size = sizeof(_om__SerializedAlgorithmType_Parameters_Parameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__SerializedAlgorithmType_Parameters_Parameter, n);
		if (size)
			*size = n * sizeof(_om__SerializedAlgorithmType_Parameters_Parameter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__SerializedAlgorithmType_Parameters_Parameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__SerializedAlgorithmType_Parameters_Parameter %p -> %p\n", q, p));
	*(_om__SerializedAlgorithmType_Parameters_Parameter*)p = *(_om__SerializedAlgorithmType_Parameters_Parameter*)q;
}

void _om__SerializedAlgorithmType_Parameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__SerializedAlgorithmType_Parameters::Parameter = NULL;
}

void _om__SerializedAlgorithmType_Parameters::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, &this->_om__SerializedAlgorithmType_Parameters::Parameter);
#endif
}

int _om__SerializedAlgorithmType_Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__SerializedAlgorithmType_Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__SerializedAlgorithmType_Parameters(struct soap *soap, const char *tag, int id, const _om__SerializedAlgorithmType_Parameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, "om:Parameter", -1, &(a->_om__SerializedAlgorithmType_Parameters::Parameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__SerializedAlgorithmType_Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__SerializedAlgorithmType_Parameters(soap, tag, this, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Parameters * SOAP_FMAC4 soap_in__om__SerializedAlgorithmType_Parameters(struct soap *soap, const char *tag, _om__SerializedAlgorithmType_Parameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__SerializedAlgorithmType_Parameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters, sizeof(_om__SerializedAlgorithmType_Parameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__SerializedAlgorithmType_Parameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, "om:Parameter", &(a->_om__SerializedAlgorithmType_Parameters::Parameter), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__SerializedAlgorithmType_Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters, 0, sizeof(_om__SerializedAlgorithmType_Parameters), 0, soap_copy__om__SerializedAlgorithmType_Parameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__SerializedAlgorithmType_Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters);
	if (this->soap_out(soap, tag?tag:"om:SerializedAlgorithmType-Parameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__SerializedAlgorithmType_Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__SerializedAlgorithmType_Parameters(soap, this, tag, type);
}

SOAP_FMAC3 _om__SerializedAlgorithmType_Parameters * SOAP_FMAC4 soap_get__om__SerializedAlgorithmType_Parameters(struct soap *soap, _om__SerializedAlgorithmType_Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__SerializedAlgorithmType_Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__SerializedAlgorithmType_Parameters * SOAP_FMAC2 soap_instantiate__om__SerializedAlgorithmType_Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__SerializedAlgorithmType_Parameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__SerializedAlgorithmType_Parameters);
		if (size)
			*size = sizeof(_om__SerializedAlgorithmType_Parameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__SerializedAlgorithmType_Parameters, n);
		if (size)
			*size = n * sizeof(_om__SerializedAlgorithmType_Parameters);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__SerializedAlgorithmType_Parameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__SerializedAlgorithmType_Parameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__SerializedAlgorithmType_Parameters %p -> %p\n", q, p));
	*(_om__SerializedAlgorithmType_Parameters*)p = *(_om__SerializedAlgorithmType_Parameters*)q;
}

void _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__BasicAlgorithmDefinitionType_Parameters_Parameter::Id);
	soap_default_std__string(soap, &this->_om__BasicAlgorithmDefinitionType_Parameters_Parameter::Value);
}

void _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const _om__BasicAlgorithmDefinitionType_Parameters_Parameter *a, const char *type)
{
	soap_set_attr(soap, "Id", ((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)a)->Id.c_str(), 1);
	soap_set_attr(soap, "Value", ((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)a)->Value.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, this, type);
}

SOAP_FMAC3 _om__BasicAlgorithmDefinitionType_Parameters_Parameter * SOAP_FMAC4 soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, _om__BasicAlgorithmDefinitionType_Parameters_Parameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter, sizeof(_om__BasicAlgorithmDefinitionType_Parameters_Parameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Value", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)a)->Value.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__BasicAlgorithmDefinitionType_Parameters_Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter, 0, sizeof(_om__BasicAlgorithmDefinitionType_Parameters_Parameter), 0, soap_copy__om__BasicAlgorithmDefinitionType_Parameters_Parameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter);
	if (this->soap_out(soap, tag?tag:"om:BasicAlgorithmDefinitionType-Parameters-Parameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__BasicAlgorithmDefinitionType_Parameters_Parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, this, tag, type);
}

SOAP_FMAC3 _om__BasicAlgorithmDefinitionType_Parameters_Parameter * SOAP_FMAC4 soap_get__om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, _om__BasicAlgorithmDefinitionType_Parameters_Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__BasicAlgorithmDefinitionType_Parameters_Parameter * SOAP_FMAC2 soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__BasicAlgorithmDefinitionType_Parameters_Parameter);
		if (size)
			*size = sizeof(_om__BasicAlgorithmDefinitionType_Parameters_Parameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__BasicAlgorithmDefinitionType_Parameters_Parameter, n);
		if (size)
			*size = n * sizeof(_om__BasicAlgorithmDefinitionType_Parameters_Parameter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__BasicAlgorithmDefinitionType_Parameters_Parameter %p -> %p\n", q, p));
	*(_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)p = *(_om__BasicAlgorithmDefinitionType_Parameters_Parameter*)q;
}

void _om__BasicAlgorithmDefinitionType_Parameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__BasicAlgorithmDefinitionType_Parameters::Parameter = NULL;
}

void _om__BasicAlgorithmDefinitionType_Parameters::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, &this->_om__BasicAlgorithmDefinitionType_Parameters::Parameter);
#endif
}

int _om__BasicAlgorithmDefinitionType_Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__BasicAlgorithmDefinitionType_Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__BasicAlgorithmDefinitionType_Parameters(struct soap *soap, const char *tag, int id, const _om__BasicAlgorithmDefinitionType_Parameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, "om:Parameter", -1, &(a->_om__BasicAlgorithmDefinitionType_Parameters::Parameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__BasicAlgorithmDefinitionType_Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__BasicAlgorithmDefinitionType_Parameters(soap, tag, this, type);
}

SOAP_FMAC3 _om__BasicAlgorithmDefinitionType_Parameters * SOAP_FMAC4 soap_in__om__BasicAlgorithmDefinitionType_Parameters(struct soap *soap, const char *tag, _om__BasicAlgorithmDefinitionType_Parameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__BasicAlgorithmDefinitionType_Parameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters, sizeof(_om__BasicAlgorithmDefinitionType_Parameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__BasicAlgorithmDefinitionType_Parameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, "om:Parameter", &(a->_om__BasicAlgorithmDefinitionType_Parameters::Parameter), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__BasicAlgorithmDefinitionType_Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters, 0, sizeof(_om__BasicAlgorithmDefinitionType_Parameters), 0, soap_copy__om__BasicAlgorithmDefinitionType_Parameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__BasicAlgorithmDefinitionType_Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters);
	if (this->soap_out(soap, tag?tag:"om:BasicAlgorithmDefinitionType-Parameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__BasicAlgorithmDefinitionType_Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__BasicAlgorithmDefinitionType_Parameters(soap, this, tag, type);
}

SOAP_FMAC3 _om__BasicAlgorithmDefinitionType_Parameters * SOAP_FMAC4 soap_get__om__BasicAlgorithmDefinitionType_Parameters(struct soap *soap, _om__BasicAlgorithmDefinitionType_Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__BasicAlgorithmDefinitionType_Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__BasicAlgorithmDefinitionType_Parameters * SOAP_FMAC2 soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__BasicAlgorithmDefinitionType_Parameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__BasicAlgorithmDefinitionType_Parameters);
		if (size)
			*size = sizeof(_om__BasicAlgorithmDefinitionType_Parameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__BasicAlgorithmDefinitionType_Parameters, n);
		if (size)
			*size = n * sizeof(_om__BasicAlgorithmDefinitionType_Parameters);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__BasicAlgorithmDefinitionType_Parameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__BasicAlgorithmDefinitionType_Parameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__BasicAlgorithmDefinitionType_Parameters %p -> %p\n", q, p));
	*(_om__BasicAlgorithmDefinitionType_Parameters*)p = *(_om__BasicAlgorithmDefinitionType_Parameters*)q;
}

void _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::Value);
}

void _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::Value);
#endif
}

int _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "om:Value", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::Value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "om:Value", &(a->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::Value), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues, 0, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues), 0, soap_copy__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::Value.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues*)p = *(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues*)q;
}

void _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::Min = NULL;
	this->_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::Max = NULL;
}

void _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *a, const char *type)
{
	if (((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Min)
		soap_set_attr(soap, "Min", soap_double2s(soap, *((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Min), 1);
	if (((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Max)
		soap_set_attr(soap, "Max", soap_double2s(soap, *((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Max), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Min", 0);
		if (t)
		{
			if (!(((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Min = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Min))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Max", 0);
		if (t)
		{
			if (!(((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Max = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)a)->Max))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange, 0, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange), 0, soap_copy__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)p = *(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange*)q;
}

void _om__AlgorithmMetadataType_Parameters_Parameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Name);
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Type);
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Overview);
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Description);
	this->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedRange = NULL;
	this->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedValues = NULL;
	this->_om__AlgorithmMetadataType_Parameters_Parameter::Default = NULL;
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Id);
}

void _om__AlgorithmMetadataType_Parameters_Parameter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Name, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Name);
	soap_embedded(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Type, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Type);
	soap_embedded(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Overview, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Overview);
	soap_embedded(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Description, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Description);
	soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedRange);
	soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedValues);
	soap_serialize_PointerTostd__string(soap, &this->_om__AlgorithmMetadataType_Parameters_Parameter::Default);
#endif
}

int _om__AlgorithmMetadataType_Parameters_Parameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Parameters_Parameter *a, const char *type)
{
	soap_set_attr(soap, "Id", ((_om__AlgorithmMetadataType_Parameters_Parameter*)a)->Id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter), type))
		return soap->error;
	if (soap_out_std__string(soap, "om:Name", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "om:Type", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Type), ""))
		return soap->error;
	if (soap_out_std__string(soap, "om:Overview", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Overview), ""))
		return soap->error;
	if (soap_out_std__string(soap, "om:Description", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Description), ""))
		return soap->error;
	if (soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, "om:AcceptedRange", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedRange), ""))
		return soap->error;
	if (soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, "om:AcceptedValues", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedValues), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "om:Default", -1, &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Default), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters_Parameter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Parameters_Parameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Parameters_Parameter *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__AlgorithmMetadataType_Parameters_Parameter*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Overview1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_AcceptedRange1 = 1;
	size_t soap_flag_AcceptedValues1 = 1;
	size_t soap_flag_Default1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Name", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Type", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Overview1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Overview", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Overview), "xsd:string"))
				{	soap_flag_Overview1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Description", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_AcceptedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, "om:AcceptedRange", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedRange), ""))
				{	soap_flag_AcceptedRange1--;
					continue;
				}
			if (soap_flag_AcceptedValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, "om:AcceptedValues", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::AcceptedValues), ""))
				{	soap_flag_AcceptedValues1--;
					continue;
				}
			if (soap_flag_Default1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:Default", &(a->_om__AlgorithmMetadataType_Parameters_Parameter::Default), "xsd:string"))
				{	soap_flag_Default1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Parameters_Parameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter, 0, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter), 0, soap_copy__om__AlgorithmMetadataType_Parameters_Parameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Type1 > 0 || soap_flag_Overview1 > 0 || soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Parameters_Parameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Parameters-Parameter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Parameters_Parameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Parameters_Parameter(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Parameters_Parameter * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Parameters_Parameter);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Parameters_Parameter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Parameters_Parameter, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Parameters_Parameter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Parameters_Parameter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Parameters_Parameter %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Parameters_Parameter*)p = *(_om__AlgorithmMetadataType_Parameters_Parameter*)q;
}

void _om__AlgorithmMetadataType_Parameters::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_om__AlgorithmMetadataType_Parameters::Parameter = NULL;
}

void _om__AlgorithmMetadataType_Parameters::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, &this->_om__AlgorithmMetadataType_Parameters::Parameter);
#endif
}

int _om__AlgorithmMetadataType_Parameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Parameters(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Parameters(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Parameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, "om:Parameter", -1, &(a->_om__AlgorithmMetadataType_Parameters::Parameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Parameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Parameters(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Parameters(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Parameters *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters, sizeof(_om__AlgorithmMetadataType_Parameters), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Parameters *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, "om:Parameter", &(a->_om__AlgorithmMetadataType_Parameters::Parameter), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Parameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters, 0, sizeof(_om__AlgorithmMetadataType_Parameters), 0, soap_copy__om__AlgorithmMetadataType_Parameters);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Parameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Parameters", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Parameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Parameters(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Parameters(struct soap *soap, _om__AlgorithmMetadataType_Parameters *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Parameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Parameters * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Parameters(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Parameters(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Parameters);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Parameters);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Parameters, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Parameters);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Parameters*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Parameters(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Parameters %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Parameters*)p = *(_om__AlgorithmMetadataType_Parameters*)q;
}

void _om__AlgorithmMetadataType_Developers_Developer::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Developers_Developer::Name);
	this->_om__AlgorithmMetadataType_Developers_Developer::Contact = NULL;
}

void _om__AlgorithmMetadataType_Developers_Developer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__AlgorithmMetadataType_Developers_Developer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Developers_Developer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Developers_Developer *a, const char *type)
{
	soap_set_attr(soap, "Name", ((_om__AlgorithmMetadataType_Developers_Developer*)a)->Name.c_str(), 1);
	if (((_om__AlgorithmMetadataType_Developers_Developer*)a)->Contact)
		soap_set_attr(soap, "Contact", ((_om__AlgorithmMetadataType_Developers_Developer*)a)->Contact->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Developers_Developer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Developers_Developer(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Developers_Developer * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Developers_Developer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Developers_Developer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer, sizeof(_om__AlgorithmMetadataType_Developers_Developer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Developers_Developer *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__AlgorithmMetadataType_Developers_Developer*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Contact", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__AlgorithmMetadataType_Developers_Developer*)a)->Contact = soap_new_std__string(soap, -1);
				((_om__AlgorithmMetadataType_Developers_Developer*)a)->Contact->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Developers_Developer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer, 0, sizeof(_om__AlgorithmMetadataType_Developers_Developer), 0, soap_copy__om__AlgorithmMetadataType_Developers_Developer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Developers_Developer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Developers-Developer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Developers_Developer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Developers_Developer(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Developers_Developer * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, _om__AlgorithmMetadataType_Developers_Developer *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Developers_Developer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Developers_Developer * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Developers_Developer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Developers_Developer);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Developers_Developer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Developers_Developer, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Developers_Developer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Developers_Developer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Developers_Developer %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Developers_Developer*)p = *(_om__AlgorithmMetadataType_Developers_Developer*)q;
}

void _om__AlgorithmMetadataType_Developers::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, &this->_om__AlgorithmMetadataType_Developers::Developer);
}

void _om__AlgorithmMetadataType_Developers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, &this->_om__AlgorithmMetadataType_Developers::Developer);
#endif
}

int _om__AlgorithmMetadataType_Developers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Developers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Developers(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Developers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, "om:Developer", -1, &(a->_om__AlgorithmMetadataType_Developers::Developer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Developers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Developers(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Developers * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Developers(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Developers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Developers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers, sizeof(_om__AlgorithmMetadataType_Developers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Developers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Developers *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, "om:Developer", &(a->_om__AlgorithmMetadataType_Developers::Developer), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Developers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers, 0, sizeof(_om__AlgorithmMetadataType_Developers), 0, soap_copy__om__AlgorithmMetadataType_Developers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__AlgorithmMetadataType_Developers::Developer.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Developers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Developers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Developers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Developers(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Developers * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Developers(struct soap *soap, _om__AlgorithmMetadataType_Developers *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Developers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Developers * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Developers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Developers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Developers, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Developers);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Developers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Developers, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Developers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Developers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Developers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Developers %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Developers*)p = *(_om__AlgorithmMetadataType_Developers*)q;
}

void _om__AlgorithmMetadataType_Designers_Designer::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->_om__AlgorithmMetadataType_Designers_Designer::Name);
	this->_om__AlgorithmMetadataType_Designers_Designer::Contact = NULL;
}

void _om__AlgorithmMetadataType_Designers_Designer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _om__AlgorithmMetadataType_Designers_Designer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Designers_Designer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Designers_Designer *a, const char *type)
{
	soap_set_attr(soap, "Name", ((_om__AlgorithmMetadataType_Designers_Designer*)a)->Name.c_str(), 1);
	if (((_om__AlgorithmMetadataType_Designers_Designer*)a)->Contact)
		soap_set_attr(soap, "Contact", ((_om__AlgorithmMetadataType_Designers_Designer*)a)->Contact->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Designers_Designer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Designers_Designer(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Designers_Designer * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Designers_Designer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Designers_Designer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer, sizeof(_om__AlgorithmMetadataType_Designers_Designer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Designers_Designer *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((_om__AlgorithmMetadataType_Designers_Designer*)a)->Name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Contact", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_om__AlgorithmMetadataType_Designers_Designer*)a)->Contact = soap_new_std__string(soap, -1);
				((_om__AlgorithmMetadataType_Designers_Designer*)a)->Contact->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Designers_Designer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer, 0, sizeof(_om__AlgorithmMetadataType_Designers_Designer), 0, soap_copy__om__AlgorithmMetadataType_Designers_Designer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Designers_Designer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Designers-Designer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Designers_Designer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Designers_Designer(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Designers_Designer * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, _om__AlgorithmMetadataType_Designers_Designer *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Designers_Designer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Designers_Designer * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Designers_Designer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Designers_Designer);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Designers_Designer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Designers_Designer, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Designers_Designer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Designers_Designer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Designers_Designer %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Designers_Designer*)p = *(_om__AlgorithmMetadataType_Designers_Designer*)q;
}

void _om__AlgorithmMetadataType_Designers::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, &this->_om__AlgorithmMetadataType_Designers::Designer);
}

void _om__AlgorithmMetadataType_Designers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, &this->_om__AlgorithmMetadataType_Designers::Designer);
#endif
}

int _om__AlgorithmMetadataType_Designers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__om__AlgorithmMetadataType_Designers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__AlgorithmMetadataType_Designers(struct soap *soap, const char *tag, int id, const _om__AlgorithmMetadataType_Designers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, "om:Designer", -1, &(a->_om__AlgorithmMetadataType_Designers::Designer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_om__AlgorithmMetadataType_Designers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__om__AlgorithmMetadataType_Designers(soap, tag, this, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Designers * SOAP_FMAC4 soap_in__om__AlgorithmMetadataType_Designers(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Designers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_om__AlgorithmMetadataType_Designers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers, sizeof(_om__AlgorithmMetadataType_Designers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om__om__AlgorithmMetadataType_Designers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_om__AlgorithmMetadataType_Designers *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, "om:Designer", &(a->_om__AlgorithmMetadataType_Designers::Designer), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_om__AlgorithmMetadataType_Designers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers, 0, sizeof(_om__AlgorithmMetadataType_Designers), 0, soap_copy__om__AlgorithmMetadataType_Designers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_om__AlgorithmMetadataType_Designers::Designer.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _om__AlgorithmMetadataType_Designers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType-Designers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_om__AlgorithmMetadataType_Designers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__om__AlgorithmMetadataType_Designers(soap, this, tag, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Designers * SOAP_FMAC4 soap_get__om__AlgorithmMetadataType_Designers(struct soap *soap, _om__AlgorithmMetadataType_Designers *p, const char *tag, const char *type)
{
	if ((p = soap_in__om__AlgorithmMetadataType_Designers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _om__AlgorithmMetadataType_Designers * SOAP_FMAC2 soap_instantiate__om__AlgorithmMetadataType_Designers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__om__AlgorithmMetadataType_Designers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om__om__AlgorithmMetadataType_Designers, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_om__AlgorithmMetadataType_Designers);
		if (size)
			*size = sizeof(_om__AlgorithmMetadataType_Designers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_om__AlgorithmMetadataType_Designers, n);
		if (size)
			*size = n * sizeof(_om__AlgorithmMetadataType_Designers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_om__AlgorithmMetadataType_Designers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__om__AlgorithmMetadataType_Designers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _om__AlgorithmMetadataType_Designers %p -> %p\n", q, p));
	*(_om__AlgorithmMetadataType_Designers*)p = *(_om__AlgorithmMetadataType_Designers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_om__ThresholdParameterType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ThresholdParameterType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_om_om__ThresholdParameterType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_om__ThresholdParameterType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_om__ThresholdParameterType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_om__ThresholdParameterType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_om_om__ThresholdParameterType, 0, sizeof(std::string), 0, soap_copy_om__ThresholdParameterType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_om__ThresholdParameterType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_om__ThresholdParameterType);
	if (soap_out_om__ThresholdParameterType(soap, tag?tag:"om:ThresholdParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_om__ThresholdParameterType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ThresholdParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void om__ResultSetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_om__ResultSetType_Job(soap, &this->om__ResultSetType::Job);
	/* transient soap skipped */
}

void om__ResultSetType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_om__ResultSetType_Job(soap, &this->om__ResultSetType::Job);
	/* transient soap skipped */
#endif
}

int om__ResultSetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ResultSetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ResultSetType(struct soap *soap, const char *tag, int id, const om__ResultSetType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ResultSetType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__ResultSetType_Job(soap, "om:Job", -1, &(a->om__ResultSetType::Job), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ResultSetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ResultSetType(soap, tag, this, type);
}

SOAP_FMAC3 om__ResultSetType * SOAP_FMAC4 soap_in_om__ResultSetType(struct soap *soap, const char *tag, om__ResultSetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ResultSetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ResultSetType, sizeof(om__ResultSetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ResultSetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ResultSetType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__ResultSetType_Job(soap, "om:Job", &(a->om__ResultSetType::Job), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ResultSetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ResultSetType, 0, sizeof(om__ResultSetType), 0, soap_copy_om__ResultSetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->om__ResultSetType::Job.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ResultSetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ResultSetType);
	if (this->soap_out(soap, tag?tag:"om:ResultSetType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ResultSetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ResultSetType(soap, this, tag, type);
}

SOAP_FMAC3 om__ResultSetType * SOAP_FMAC4 soap_get_om__ResultSetType(struct soap *soap, om__ResultSetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ResultSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ResultSetType * SOAP_FMAC2 soap_instantiate_om__ResultSetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ResultSetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ResultSetType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ResultSetType);
		if (size)
			*size = sizeof(om__ResultSetType);
		((om__ResultSetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ResultSetType, n);
		if (size)
			*size = n * sizeof(om__ResultSetType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ResultSetType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ResultSetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ResultSetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ResultSetType %p -> %p\n", q, p));
	*(om__ResultSetType*)p = *(om__ResultSetType*)q;
}

void om__JobTicketsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_om__JobTicketsType_Job(soap, &this->om__JobTicketsType::Job);
	/* transient soap skipped */
}

void om__JobTicketsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_om__JobTicketsType_Job(soap, &this->om__JobTicketsType::Job);
	/* transient soap skipped */
#endif
}

int om__JobTicketsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__JobTicketsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__JobTicketsType(struct soap *soap, const char *tag, int id, const om__JobTicketsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__JobTicketsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__JobTicketsType_Job(soap, "om:Job", -1, &(a->om__JobTicketsType::Job), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__JobTicketsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__JobTicketsType(soap, tag, this, type);
}

SOAP_FMAC3 om__JobTicketsType * SOAP_FMAC4 soap_in_om__JobTicketsType(struct soap *soap, const char *tag, om__JobTicketsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__JobTicketsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__JobTicketsType, sizeof(om__JobTicketsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__JobTicketsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__JobTicketsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__JobTicketsType_Job(soap, "om:Job", &(a->om__JobTicketsType::Job), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__JobTicketsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__JobTicketsType, 0, sizeof(om__JobTicketsType), 0, soap_copy_om__JobTicketsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->om__JobTicketsType::Job.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__JobTicketsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__JobTicketsType);
	if (this->soap_out(soap, tag?tag:"om:JobTicketsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__JobTicketsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__JobTicketsType(soap, this, tag, type);
}

SOAP_FMAC3 om__JobTicketsType * SOAP_FMAC4 soap_get_om__JobTicketsType(struct soap *soap, om__JobTicketsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__JobTicketsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__JobTicketsType * SOAP_FMAC2 soap_instantiate_om__JobTicketsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__JobTicketsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__JobTicketsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__JobTicketsType);
		if (size)
			*size = sizeof(om__JobTicketsType);
		((om__JobTicketsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__JobTicketsType, n);
		if (size)
			*size = n * sizeof(om__JobTicketsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__JobTicketsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__JobTicketsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__JobTicketsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__JobTicketsType %p -> %p\n", q, p));
	*(om__JobTicketsType*)p = *(om__JobTicketsType*)q;
}

void om__ProjectModelJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__IdentifiedType::soap_default(soap);
	this->om__ProjectModelJobType::EnvironmentRef = NULL;
	this->om__ProjectModelJobType::ModelRef = NULL;
	this->om__ProjectModelJobType::OutputParameters = NULL;
	this->om__ProjectModelJobType::Statistics = NULL;
}

void om__ProjectModelJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__ProjectModelJobType::EnvironmentRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__ProjectModelJobType::ModelRef);
	soap_serialize_PointerToom__MapOutputParametersType(soap, &this->om__ProjectModelJobType::OutputParameters);
	soap_serialize_PointerToom__ProjectionStatisticsParametersType(soap, &this->om__ProjectModelJobType::Statistics);
	this->om__IdentifiedType::soap_serialize(soap);
#endif
}

int om__ProjectModelJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ProjectModelJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ProjectModelJobType(struct soap *soap, const char *tag, int id, const om__ProjectModelJobType *a, const char *type)
{
	soap_set_attr(soap, "id", ((om__IdentifiedType*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ProjectModelJobType), "om:ProjectModelJobType"))
		return soap->error;
	/* transient soap skipped */
	if (a->om__ProjectModelJobType::EnvironmentRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:EnvironmentRef", -1, &a->om__ProjectModelJobType::EnvironmentRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:EnvironmentRef"))
		return soap->error;
	if (a->om__ProjectModelJobType::ModelRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:ModelRef", -1, &a->om__ProjectModelJobType::ModelRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:ModelRef"))
		return soap->error;
	if (soap_out_PointerToom__MapOutputParametersType(soap, "om:OutputParameters", -1, &(a->om__ProjectModelJobType::OutputParameters), ""))
		return soap->error;
	if (soap_out_PointerToom__ProjectionStatisticsParametersType(soap, "om:Statistics", -1, &(a->om__ProjectModelJobType::Statistics), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *om__ProjectModelJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ProjectModelJobType(soap, tag, this, type);
}

SOAP_FMAC3 om__ProjectModelJobType * SOAP_FMAC4 soap_in_om__ProjectModelJobType(struct soap *soap, const char *tag, om__ProjectModelJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ProjectModelJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ProjectModelJobType, sizeof(om__ProjectModelJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ProjectModelJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ProjectModelJobType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__IdentifiedType*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_EnvironmentRef1 = 1;
	size_t soap_flag_ModelRef1 = 1;
	size_t soap_flag_OutputParameters1 = 1;
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EnvironmentRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:EnvironmentRef", &(a->om__ProjectModelJobType::EnvironmentRef), "om:ReferenceType"))
				{	soap_flag_EnvironmentRef1--;
					continue;
				}
			if (soap_flag_ModelRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:ModelRef", &(a->om__ProjectModelJobType::ModelRef), "om:ReferenceType"))
				{	soap_flag_ModelRef1--;
					continue;
				}
			if (soap_flag_OutputParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__MapOutputParametersType(soap, "om:OutputParameters", &(a->om__ProjectModelJobType::OutputParameters), "om:MapOutputParametersType"))
				{	soap_flag_OutputParameters1--;
					continue;
				}
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ProjectionStatisticsParametersType(soap, "om:Statistics", &(a->om__ProjectModelJobType::Statistics), "om:ProjectionStatisticsParametersType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ProjectModelJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ProjectModelJobType, 0, sizeof(om__ProjectModelJobType), 0, soap_copy_om__ProjectModelJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EnvironmentRef1 > 0 || soap_flag_ModelRef1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ProjectModelJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ProjectModelJobType);
	if (this->soap_out(soap, tag?tag:"om:ProjectModelJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ProjectModelJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ProjectModelJobType(soap, this, tag, type);
}

SOAP_FMAC3 om__ProjectModelJobType * SOAP_FMAC4 soap_get_om__ProjectModelJobType(struct soap *soap, om__ProjectModelJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ProjectModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ProjectModelJobType * SOAP_FMAC2 soap_instantiate_om__ProjectModelJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ProjectModelJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ProjectModelJobType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ProjectModelJobType);
		if (size)
			*size = sizeof(om__ProjectModelJobType);
		((om__ProjectModelJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ProjectModelJobType, n);
		if (size)
			*size = n * sizeof(om__ProjectModelJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ProjectModelJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ProjectModelJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ProjectModelJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ProjectModelJobType %p -> %p\n", q, p));
	*(om__ProjectModelJobType*)p = *(om__ProjectModelJobType*)q;
}

void om__TestModelJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__IdentifiedType::soap_default(soap);
	this->om__TestModelJobType::EnvironmentRef = NULL;
	this->om__TestModelJobType::PresenceRef = NULL;
	this->om__TestModelJobType::AbsenceRef = NULL;
	this->om__TestModelJobType::ModelRef = NULL;
	this->om__TestModelJobType::Statistics = NULL;
}

void om__TestModelJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__TestModelJobType::EnvironmentRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__TestModelJobType::PresenceRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__TestModelJobType::AbsenceRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__TestModelJobType::ModelRef);
	soap_serialize_PointerToom__TestOptionsType(soap, &this->om__TestModelJobType::Statistics);
	this->om__IdentifiedType::soap_serialize(soap);
#endif
}

int om__TestModelJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__TestModelJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__TestModelJobType(struct soap *soap, const char *tag, int id, const om__TestModelJobType *a, const char *type)
{
	soap_set_attr(soap, "id", ((om__IdentifiedType*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__TestModelJobType), "om:TestModelJobType"))
		return soap->error;
	/* transient soap skipped */
	if (a->om__TestModelJobType::EnvironmentRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:EnvironmentRef", -1, &a->om__TestModelJobType::EnvironmentRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:EnvironmentRef"))
		return soap->error;
	if (a->om__TestModelJobType::PresenceRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:PresenceRef", -1, &a->om__TestModelJobType::PresenceRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:PresenceRef"))
		return soap->error;
	if (soap_out_PointerToom__ReferenceType(soap, "om:AbsenceRef", -1, &(a->om__TestModelJobType::AbsenceRef), ""))
		return soap->error;
	if (a->om__TestModelJobType::ModelRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:ModelRef", -1, &a->om__TestModelJobType::ModelRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:ModelRef"))
		return soap->error;
	if (soap_out_PointerToom__TestOptionsType(soap, "om:Statistics", -1, &(a->om__TestModelJobType::Statistics), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *om__TestModelJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__TestModelJobType(soap, tag, this, type);
}

SOAP_FMAC3 om__TestModelJobType * SOAP_FMAC4 soap_in_om__TestModelJobType(struct soap *soap, const char *tag, om__TestModelJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__TestModelJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__TestModelJobType, sizeof(om__TestModelJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__TestModelJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__TestModelJobType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__IdentifiedType*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_EnvironmentRef1 = 1;
	size_t soap_flag_PresenceRef1 = 1;
	size_t soap_flag_AbsenceRef1 = 1;
	size_t soap_flag_ModelRef1 = 1;
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EnvironmentRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:EnvironmentRef", &(a->om__TestModelJobType::EnvironmentRef), "om:ReferenceType"))
				{	soap_flag_EnvironmentRef1--;
					continue;
				}
			if (soap_flag_PresenceRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:PresenceRef", &(a->om__TestModelJobType::PresenceRef), "om:ReferenceType"))
				{	soap_flag_PresenceRef1--;
					continue;
				}
			if (soap_flag_AbsenceRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:AbsenceRef", &(a->om__TestModelJobType::AbsenceRef), "om:ReferenceType"))
				{	soap_flag_AbsenceRef1--;
					continue;
				}
			if (soap_flag_ModelRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:ModelRef", &(a->om__TestModelJobType::ModelRef), "om:ReferenceType"))
				{	soap_flag_ModelRef1--;
					continue;
				}
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__TestOptionsType(soap, "om:Statistics", &(a->om__TestModelJobType::Statistics), "om:TestOptionsType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__TestModelJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__TestModelJobType, 0, sizeof(om__TestModelJobType), 0, soap_copy_om__TestModelJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EnvironmentRef1 > 0 || soap_flag_PresenceRef1 > 0 || soap_flag_ModelRef1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__TestModelJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__TestModelJobType);
	if (this->soap_out(soap, tag?tag:"om:TestModelJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__TestModelJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__TestModelJobType(soap, this, tag, type);
}

SOAP_FMAC3 om__TestModelJobType * SOAP_FMAC4 soap_get_om__TestModelJobType(struct soap *soap, om__TestModelJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__TestModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__TestModelJobType * SOAP_FMAC2 soap_instantiate_om__TestModelJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__TestModelJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__TestModelJobType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__TestModelJobType);
		if (size)
			*size = sizeof(om__TestModelJobType);
		((om__TestModelJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestModelJobType, n);
		if (size)
			*size = n * sizeof(om__TestModelJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__TestModelJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__TestModelJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__TestModelJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__TestModelJobType %p -> %p\n", q, p));
	*(om__TestModelJobType*)p = *(om__TestModelJobType*)q;
}

void om__CreateModelJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__IdentifiedType::soap_default(soap);
	this->om__CreateModelJobType::EnvironmentRef = NULL;
	this->om__CreateModelJobType::PresenceRef = NULL;
	this->om__CreateModelJobType::AbsenceRef = NULL;
	this->om__CreateModelJobType::AlgorithmRef = NULL;
	this->om__CreateModelJobType::Options = NULL;
}

void om__CreateModelJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__CreateModelJobType::EnvironmentRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__CreateModelJobType::PresenceRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__CreateModelJobType::AbsenceRef);
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__CreateModelJobType::AlgorithmRef);
	soap_serialize_PointerToom__ModelOptionsType(soap, &this->om__CreateModelJobType::Options);
	this->om__IdentifiedType::soap_serialize(soap);
#endif
}

int om__CreateModelJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__CreateModelJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__CreateModelJobType(struct soap *soap, const char *tag, int id, const om__CreateModelJobType *a, const char *type)
{
	soap_set_attr(soap, "id", ((om__IdentifiedType*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__CreateModelJobType), "om:CreateModelJobType"))
		return soap->error;
	/* transient soap skipped */
	if (a->om__CreateModelJobType::EnvironmentRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:EnvironmentRef", -1, &a->om__CreateModelJobType::EnvironmentRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:EnvironmentRef"))
		return soap->error;
	if (a->om__CreateModelJobType::PresenceRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:PresenceRef", -1, &a->om__CreateModelJobType::PresenceRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:PresenceRef"))
		return soap->error;
	if (soap_out_PointerToom__ReferenceType(soap, "om:AbsenceRef", -1, &(a->om__CreateModelJobType::AbsenceRef), ""))
		return soap->error;
	if (a->om__CreateModelJobType::AlgorithmRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:AlgorithmRef", -1, &a->om__CreateModelJobType::AlgorithmRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:AlgorithmRef"))
		return soap->error;
	if (soap_out_PointerToom__ModelOptionsType(soap, "om:Options", -1, &(a->om__CreateModelJobType::Options), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *om__CreateModelJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__CreateModelJobType(soap, tag, this, type);
}

SOAP_FMAC3 om__CreateModelJobType * SOAP_FMAC4 soap_in_om__CreateModelJobType(struct soap *soap, const char *tag, om__CreateModelJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__CreateModelJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__CreateModelJobType, sizeof(om__CreateModelJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__CreateModelJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__CreateModelJobType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__IdentifiedType*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_EnvironmentRef1 = 1;
	size_t soap_flag_PresenceRef1 = 1;
	size_t soap_flag_AbsenceRef1 = 1;
	size_t soap_flag_AlgorithmRef1 = 1;
	size_t soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EnvironmentRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:EnvironmentRef", &(a->om__CreateModelJobType::EnvironmentRef), "om:ReferenceType"))
				{	soap_flag_EnvironmentRef1--;
					continue;
				}
			if (soap_flag_PresenceRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:PresenceRef", &(a->om__CreateModelJobType::PresenceRef), "om:ReferenceType"))
				{	soap_flag_PresenceRef1--;
					continue;
				}
			if (soap_flag_AbsenceRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:AbsenceRef", &(a->om__CreateModelJobType::AbsenceRef), "om:ReferenceType"))
				{	soap_flag_AbsenceRef1--;
					continue;
				}
			if (soap_flag_AlgorithmRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:AlgorithmRef", &(a->om__CreateModelJobType::AlgorithmRef), "om:ReferenceType"))
				{	soap_flag_AlgorithmRef1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ModelOptionsType(soap, "om:Options", &(a->om__CreateModelJobType::Options), "om:ModelOptionsType"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__CreateModelJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__CreateModelJobType, 0, sizeof(om__CreateModelJobType), 0, soap_copy_om__CreateModelJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EnvironmentRef1 > 0 || soap_flag_PresenceRef1 > 0 || soap_flag_AlgorithmRef1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__CreateModelJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__CreateModelJobType);
	if (this->soap_out(soap, tag?tag:"om:CreateModelJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__CreateModelJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__CreateModelJobType(soap, this, tag, type);
}

SOAP_FMAC3 om__CreateModelJobType * SOAP_FMAC4 soap_get_om__CreateModelJobType(struct soap *soap, om__CreateModelJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__CreateModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__CreateModelJobType * SOAP_FMAC2 soap_instantiate_om__CreateModelJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__CreateModelJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__CreateModelJobType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__CreateModelJobType);
		if (size)
			*size = sizeof(om__CreateModelJobType);
		((om__CreateModelJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__CreateModelJobType, n);
		if (size)
			*size = n * sizeof(om__CreateModelJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__CreateModelJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__CreateModelJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__CreateModelJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__CreateModelJobType %p -> %p\n", q, p));
	*(om__CreateModelJobType*)p = *(om__CreateModelJobType*)q;
}

void om__SamplingJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__IdentifiedType::soap_default(soap);
	this->om__SamplingJobType::EnvironmentRef = NULL;
	this->om__SamplingJobType::Options = NULL;
}

void om__SamplingJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__ReferenceType(soap, &this->om__SamplingJobType::EnvironmentRef);
	soap_serialize_PointerToom__SamplingOptionsType(soap, &this->om__SamplingJobType::Options);
	this->om__IdentifiedType::soap_serialize(soap);
#endif
}

int om__SamplingJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SamplingJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SamplingJobType(struct soap *soap, const char *tag, int id, const om__SamplingJobType *a, const char *type)
{
	soap_set_attr(soap, "id", ((om__IdentifiedType*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SamplingJobType), "om:SamplingJobType"))
		return soap->error;
	/* transient soap skipped */
	if (a->om__SamplingJobType::EnvironmentRef)
	{	if (soap_out_PointerToom__ReferenceType(soap, "om:EnvironmentRef", -1, &a->om__SamplingJobType::EnvironmentRef, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:EnvironmentRef"))
		return soap->error;
	if (a->om__SamplingJobType::Options)
	{	if (soap_out_PointerToom__SamplingOptionsType(soap, "om:Options", -1, &a->om__SamplingJobType::Options, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Options"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *om__SamplingJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SamplingJobType(soap, tag, this, type);
}

SOAP_FMAC3 om__SamplingJobType * SOAP_FMAC4 soap_in_om__SamplingJobType(struct soap *soap, const char *tag, om__SamplingJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SamplingJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SamplingJobType, sizeof(om__SamplingJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SamplingJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SamplingJobType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__IdentifiedType*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_EnvironmentRef1 = 1;
	size_t soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EnvironmentRef1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ReferenceType(soap, "om:EnvironmentRef", &(a->om__SamplingJobType::EnvironmentRef), "om:ReferenceType"))
				{	soap_flag_EnvironmentRef1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplingOptionsType(soap, "om:Options", &(a->om__SamplingJobType::Options), "om:SamplingOptionsType"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SamplingJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SamplingJobType, 0, sizeof(om__SamplingJobType), 0, soap_copy_om__SamplingJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EnvironmentRef1 > 0 || soap_flag_Options1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__SamplingJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SamplingJobType);
	if (this->soap_out(soap, tag?tag:"om:SamplingJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SamplingJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SamplingJobType(soap, this, tag, type);
}

SOAP_FMAC3 om__SamplingJobType * SOAP_FMAC4 soap_get_om__SamplingJobType(struct soap *soap, om__SamplingJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SamplingJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SamplingJobType * SOAP_FMAC2 soap_instantiate_om__SamplingJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SamplingJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SamplingJobType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SamplingJobType);
		if (size)
			*size = sizeof(om__SamplingJobType);
		((om__SamplingJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SamplingJobType, n);
		if (size)
			*size = n * sizeof(om__SamplingJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SamplingJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SamplingJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SamplingJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SamplingJobType %p -> %p\n", q, p));
	*(om__SamplingJobType*)p = *(om__SamplingJobType*)q;
}

void om__IdentifiedType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__ID(soap, &this->om__IdentifiedType::id);
	/* transient soap skipped */
}

void om__IdentifiedType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int om__IdentifiedType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__IdentifiedType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__IdentifiedType(struct soap *soap, const char *tag, int id, const om__IdentifiedType *a, const char *type)
{
	soap_set_attr(soap, "id", ((om__IdentifiedType*)a)->id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__IdentifiedType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__IdentifiedType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__IdentifiedType(soap, tag, this, type);
}

SOAP_FMAC3 om__IdentifiedType * SOAP_FMAC4 soap_in_om__IdentifiedType(struct soap *soap, const char *tag, om__IdentifiedType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__IdentifiedType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__IdentifiedType, sizeof(om__IdentifiedType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__IdentifiedType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__IdentifiedType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__IdentifiedType*)a)->id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__IdentifiedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__IdentifiedType, 0, sizeof(om__IdentifiedType), 0, soap_copy_om__IdentifiedType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__IdentifiedType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__IdentifiedType);
	if (this->soap_out(soap, tag?tag:"om:IdentifiedType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__IdentifiedType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__IdentifiedType(soap, this, tag, type);
}

SOAP_FMAC3 om__IdentifiedType * SOAP_FMAC4 soap_get_om__IdentifiedType(struct soap *soap, om__IdentifiedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__IdentifiedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__IdentifiedType * SOAP_FMAC2 soap_instantiate_om__IdentifiedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__IdentifiedType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__IdentifiedType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "om:SamplingJobType"))
	{	cp->type = SOAP_TYPE_om_om__SamplingJobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__SamplingJobType);
			if (size)
				*size = sizeof(om__SamplingJobType);
			((om__SamplingJobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SamplingJobType, n);
			if (size)
				*size = n * sizeof(om__SamplingJobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__SamplingJobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__SamplingJobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "om:CreateModelJobType"))
	{	cp->type = SOAP_TYPE_om_om__CreateModelJobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__CreateModelJobType);
			if (size)
				*size = sizeof(om__CreateModelJobType);
			((om__CreateModelJobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__CreateModelJobType, n);
			if (size)
				*size = n * sizeof(om__CreateModelJobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__CreateModelJobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__CreateModelJobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "om:TestModelJobType"))
	{	cp->type = SOAP_TYPE_om_om__TestModelJobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__TestModelJobType);
			if (size)
				*size = sizeof(om__TestModelJobType);
			((om__TestModelJobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestModelJobType, n);
			if (size)
				*size = n * sizeof(om__TestModelJobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__TestModelJobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__TestModelJobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "om:ProjectModelJobType"))
	{	cp->type = SOAP_TYPE_om_om__ProjectModelJobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__ProjectModelJobType);
			if (size)
				*size = sizeof(om__ProjectModelJobType);
			((om__ProjectModelJobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ProjectModelJobType, n);
			if (size)
				*size = n * sizeof(om__ProjectModelJobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__ProjectModelJobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__ProjectModelJobType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__IdentifiedType);
		if (size)
			*size = sizeof(om__IdentifiedType);
		((om__IdentifiedType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__IdentifiedType, n);
		if (size)
			*size = n * sizeof(om__IdentifiedType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__IdentifiedType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__IdentifiedType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__IdentifiedType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__IdentifiedType %p -> %p\n", q, p));
	*(om__IdentifiedType*)p = *(om__IdentifiedType*)q;
}

void om__ReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__IDREF(soap, &this->om__ReferenceType::idref);
	/* transient soap skipped */
}

void om__ReferenceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int om__ReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ReferenceType(struct soap *soap, const char *tag, int id, const om__ReferenceType *a, const char *type)
{
	soap_set_attr(soap, "idref", ((om__ReferenceType*)a)->idref.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ReferenceType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 om__ReferenceType * SOAP_FMAC4 soap_in_om__ReferenceType(struct soap *soap, const char *tag, om__ReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ReferenceType, sizeof(om__ReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "idref", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__ReferenceType*)a)->idref.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ReferenceType, 0, sizeof(om__ReferenceType), 0, soap_copy_om__ReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__ReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ReferenceType);
	if (this->soap_out(soap, tag?tag:"om:ReferenceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 om__ReferenceType * SOAP_FMAC4 soap_get_om__ReferenceType(struct soap *soap, om__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ReferenceType * SOAP_FMAC2 soap_instantiate_om__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ReferenceType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ReferenceType);
		if (size)
			*size = sizeof(om__ReferenceType);
		((om__ReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ReferenceType, n);
		if (size)
			*size = n * sizeof(om__ReferenceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ReferenceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ReferenceType %p -> %p\n", q, p));
	*(om__ReferenceType*)p = *(om__ReferenceType*)q;
}

void om__ExperimentParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, &this->om__ExperimentParametersType::Environment);
	this->om__ExperimentParametersType::Presence = NULL;
	this->om__ExperimentParametersType::Absence = NULL;
	this->om__ExperimentParametersType::AlgorithmSettings = NULL;
	this->om__ExperimentParametersType::SerializedAlgorithm = NULL;
	this->om__ExperimentParametersType::Jobs._om__ExperimentParametersType_Jobs::soap_default(soap);
	/* transient soap skipped */
}

void om__ExperimentParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, &this->om__ExperimentParametersType::Environment);
	soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, &this->om__ExperimentParametersType::Presence);
	soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, &this->om__ExperimentParametersType::Absence);
	soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, &this->om__ExperimentParametersType::AlgorithmSettings);
	soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, &this->om__ExperimentParametersType::SerializedAlgorithm);
	this->om__ExperimentParametersType::Jobs.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int om__ExperimentParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ExperimentParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ExperimentParametersType(struct soap *soap, const char *tag, int id, const om__ExperimentParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ExperimentParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, "om:Environment", -1, &(a->om__ExperimentParametersType::Environment), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, "om:Presence", -1, &(a->om__ExperimentParametersType::Presence), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, "om:Absence", -1, &(a->om__ExperimentParametersType::Absence), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, "om:AlgorithmSettings", -1, &(a->om__ExperimentParametersType::AlgorithmSettings), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, "om:SerializedAlgorithm", -1, &(a->om__ExperimentParametersType::SerializedAlgorithm), ""))
		return soap->error;
	if ((a->om__ExperimentParametersType::Jobs).soap_out(soap, "om:Jobs", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ExperimentParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ExperimentParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__ExperimentParametersType * SOAP_FMAC4 soap_in_om__ExperimentParametersType(struct soap *soap, const char *tag, om__ExperimentParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ExperimentParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ExperimentParametersType, sizeof(om__ExperimentParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ExperimentParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ExperimentParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Jobs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, "om:Environment", &(a->om__ExperimentParametersType::Environment), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, "om:Presence", &(a->om__ExperimentParametersType::Presence), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, "om:Absence", &(a->om__ExperimentParametersType::Absence), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, "om:AlgorithmSettings", &(a->om__ExperimentParametersType::AlgorithmSettings), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, "om:SerializedAlgorithm", &(a->om__ExperimentParametersType::SerializedAlgorithm), ""))
					continue;
			if (soap_flag_Jobs1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__ExperimentParametersType::Jobs).soap_in(soap, "om:Jobs", ""))
				{	soap_flag_Jobs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ExperimentParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ExperimentParametersType, 0, sizeof(om__ExperimentParametersType), 0, soap_copy_om__ExperimentParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->om__ExperimentParametersType::Environment.size() < 1 || soap_flag_Jobs1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ExperimentParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ExperimentParametersType);
	if (this->soap_out(soap, tag?tag:"om:ExperimentParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ExperimentParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ExperimentParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__ExperimentParametersType * SOAP_FMAC4 soap_get_om__ExperimentParametersType(struct soap *soap, om__ExperimentParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ExperimentParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ExperimentParametersType * SOAP_FMAC2 soap_instantiate_om__ExperimentParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ExperimentParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ExperimentParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ExperimentParametersType);
		if (size)
			*size = sizeof(om__ExperimentParametersType);
		((om__ExperimentParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ExperimentParametersType, n);
		if (size)
			*size = n * sizeof(om__ExperimentParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ExperimentParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ExperimentParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ExperimentParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ExperimentParametersType %p -> %p\n", q, p));
	*(om__ExperimentParametersType*)p = *(om__ExperimentParametersType*)q;
}

void om__SamplingParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__SamplingParametersType::Environment = NULL;
	this->om__SamplingParametersType::Options = NULL;
	/* transient soap skipped */
}

void om__SamplingParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__EnvironmentType(soap, &this->om__SamplingParametersType::Environment);
	soap_serialize_PointerToom__SamplingOptionsType(soap, &this->om__SamplingParametersType::Options);
	/* transient soap skipped */
#endif
}

int om__SamplingParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SamplingParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SamplingParametersType(struct soap *soap, const char *tag, int id, const om__SamplingParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SamplingParametersType), type))
		return soap->error;
	if (a->om__SamplingParametersType::Environment)
	{	if (soap_out_PointerToom__EnvironmentType(soap, "om:Environment", -1, &a->om__SamplingParametersType::Environment, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Environment"))
		return soap->error;
	if (a->om__SamplingParametersType::Options)
	{	if (soap_out_PointerToom__SamplingOptionsType(soap, "om:Options", -1, &a->om__SamplingParametersType::Options, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Options"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__SamplingParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SamplingParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__SamplingParametersType * SOAP_FMAC4 soap_in_om__SamplingParametersType(struct soap *soap, const char *tag, om__SamplingParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SamplingParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SamplingParametersType, sizeof(om__SamplingParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SamplingParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SamplingParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Environment1 = 1;
	size_t soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Environment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__EnvironmentType(soap, "om:Environment", &(a->om__SamplingParametersType::Environment), "om:EnvironmentType"))
				{	soap_flag_Environment1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplingOptionsType(soap, "om:Options", &(a->om__SamplingParametersType::Options), "om:SamplingOptionsType"))
				{	soap_flag_Options1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SamplingParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SamplingParametersType, 0, sizeof(om__SamplingParametersType), 0, soap_copy_om__SamplingParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Environment1 > 0 || soap_flag_Options1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__SamplingParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SamplingParametersType);
	if (this->soap_out(soap, tag?tag:"om:SamplingParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SamplingParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SamplingParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__SamplingParametersType * SOAP_FMAC4 soap_get_om__SamplingParametersType(struct soap *soap, om__SamplingParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SamplingParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SamplingParametersType * SOAP_FMAC2 soap_instantiate_om__SamplingParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SamplingParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SamplingParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SamplingParametersType);
		if (size)
			*size = sizeof(om__SamplingParametersType);
		((om__SamplingParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SamplingParametersType, n);
		if (size)
			*size = n * sizeof(om__SamplingParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SamplingParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SamplingParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SamplingParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SamplingParametersType %p -> %p\n", q, p));
	*(om__SamplingParametersType*)p = *(om__SamplingParametersType*)q;
}

void om__SamplingOptionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__SamplingOptionsType::OccurrencesFilter = NULL;
	soap_default_int(soap, &this->om__SamplingOptionsType::NumPoints);
	this->om__SamplingOptionsType::Label = NULL;
	this->om__SamplingOptionsType::ProportionOfAbsences = NULL;
	/* transient soap skipped */
}

void om__SamplingOptionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__OccurrencesFilterType(soap, &this->om__SamplingOptionsType::OccurrencesFilter);
	/* transient soap skipped */
#endif
}

int om__SamplingOptionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SamplingOptionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SamplingOptionsType(struct soap *soap, const char *tag, int id, const om__SamplingOptionsType *a, const char *type)
{
	soap_set_attr(soap, "NumPoints", soap_int2s(soap, ((om__SamplingOptionsType*)a)->NumPoints), 1);
	if (((om__SamplingOptionsType*)a)->Label)
		soap_set_attr(soap, "Label", ((om__SamplingOptionsType*)a)->Label->c_str(), 1);
	if (((om__SamplingOptionsType*)a)->ProportionOfAbsences)
		soap_set_attr(soap, "ProportionOfAbsences", soap_double2s(soap, *((om__SamplingOptionsType*)a)->ProportionOfAbsences), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SamplingOptionsType), type))
		return soap->error;
	if (soap_out_PointerToom__OccurrencesFilterType(soap, "om:OccurrencesFilter", -1, &(a->om__SamplingOptionsType::OccurrencesFilter), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__SamplingOptionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SamplingOptionsType(soap, tag, this, type);
}

SOAP_FMAC3 om__SamplingOptionsType * SOAP_FMAC4 soap_in_om__SamplingOptionsType(struct soap *soap, const char *tag, om__SamplingOptionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SamplingOptionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SamplingOptionsType, sizeof(om__SamplingOptionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SamplingOptionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SamplingOptionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "NumPoints", 1), &((om__SamplingOptionsType*)a)->NumPoints))
		return NULL;
	{	const char *t = soap_attr_value(soap, "Label", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__SamplingOptionsType*)a)->Label = soap_new_std__string(soap, -1);
				((om__SamplingOptionsType*)a)->Label->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ProportionOfAbsences", 0);
		if (t)
		{
			if (!(((om__SamplingOptionsType*)a)->ProportionOfAbsences = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__SamplingOptionsType*)a)->ProportionOfAbsences))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_OccurrencesFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OccurrencesFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__OccurrencesFilterType(soap, "om:OccurrencesFilter", &(a->om__SamplingOptionsType::OccurrencesFilter), "om:OccurrencesFilterType"))
				{	soap_flag_OccurrencesFilter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SamplingOptionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SamplingOptionsType, 0, sizeof(om__SamplingOptionsType), 0, soap_copy_om__SamplingOptionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__SamplingOptionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SamplingOptionsType);
	if (this->soap_out(soap, tag?tag:"om:SamplingOptionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SamplingOptionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SamplingOptionsType(soap, this, tag, type);
}

SOAP_FMAC3 om__SamplingOptionsType * SOAP_FMAC4 soap_get_om__SamplingOptionsType(struct soap *soap, om__SamplingOptionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SamplingOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SamplingOptionsType * SOAP_FMAC2 soap_instantiate_om__SamplingOptionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SamplingOptionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SamplingOptionsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SamplingOptionsType);
		if (size)
			*size = sizeof(om__SamplingOptionsType);
		((om__SamplingOptionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SamplingOptionsType, n);
		if (size)
			*size = n * sizeof(om__SamplingOptionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SamplingOptionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SamplingOptionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SamplingOptionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SamplingOptionsType %p -> %p\n", q, p));
	*(om__SamplingOptionsType*)p = *(om__SamplingOptionsType*)q;
}

void om__ModelEvaluationResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModelEvaluationResultType::Values._om__ModelEvaluationResultType_Values::soap_default(soap);
	/* transient soap skipped */
}

void om__ModelEvaluationResultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->om__ModelEvaluationResultType::Values.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int om__ModelEvaluationResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModelEvaluationResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModelEvaluationResultType(struct soap *soap, const char *tag, int id, const om__ModelEvaluationResultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModelEvaluationResultType), type))
		return soap->error;
	if ((a->om__ModelEvaluationResultType::Values).soap_out(soap, "om:Values", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModelEvaluationResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModelEvaluationResultType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModelEvaluationResultType * SOAP_FMAC4 soap_in_om__ModelEvaluationResultType(struct soap *soap, const char *tag, om__ModelEvaluationResultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModelEvaluationResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModelEvaluationResultType, sizeof(om__ModelEvaluationResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModelEvaluationResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModelEvaluationResultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Values1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Values1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__ModelEvaluationResultType::Values).soap_in(soap, "om:Values", ""))
				{	soap_flag_Values1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModelEvaluationResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModelEvaluationResultType, 0, sizeof(om__ModelEvaluationResultType), 0, soap_copy_om__ModelEvaluationResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Values1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ModelEvaluationResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModelEvaluationResultType);
	if (this->soap_out(soap, tag?tag:"om:ModelEvaluationResultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModelEvaluationResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModelEvaluationResultType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModelEvaluationResultType * SOAP_FMAC4 soap_get_om__ModelEvaluationResultType(struct soap *soap, om__ModelEvaluationResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModelEvaluationResultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModelEvaluationResultType * SOAP_FMAC2 soap_instantiate_om__ModelEvaluationResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModelEvaluationResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModelEvaluationResultType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModelEvaluationResultType);
		if (size)
			*size = sizeof(om__ModelEvaluationResultType);
		((om__ModelEvaluationResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModelEvaluationResultType, n);
		if (size)
			*size = n * sizeof(om__ModelEvaluationResultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModelEvaluationResultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModelEvaluationResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModelEvaluationResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModelEvaluationResultType %p -> %p\n", q, p));
	*(om__ModelEvaluationResultType*)p = *(om__ModelEvaluationResultType*)q;
}

void om__ModelEvaluationParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModelEvaluationParametersType::Sampler = NULL;
	this->om__ModelEvaluationParametersType::Algorithm = NULL;
	/* transient soap skipped */
}

void om__ModelEvaluationParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SamplerType(soap, &this->om__ModelEvaluationParametersType::Sampler);
	soap_serialize_PointerToom__SerializedAlgorithmType(soap, &this->om__ModelEvaluationParametersType::Algorithm);
	/* transient soap skipped */
#endif
}

int om__ModelEvaluationParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModelEvaluationParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModelEvaluationParametersType(struct soap *soap, const char *tag, int id, const om__ModelEvaluationParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModelEvaluationParametersType), type))
		return soap->error;
	if (a->om__ModelEvaluationParametersType::Sampler)
	{	if (soap_out_PointerToom__SamplerType(soap, "om:Sampler", -1, &a->om__ModelEvaluationParametersType::Sampler, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Sampler"))
		return soap->error;
	if (a->om__ModelEvaluationParametersType::Algorithm)
	{	if (soap_out_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", -1, &a->om__ModelEvaluationParametersType::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModelEvaluationParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModelEvaluationParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModelEvaluationParametersType * SOAP_FMAC4 soap_in_om__ModelEvaluationParametersType(struct soap *soap, const char *tag, om__ModelEvaluationParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModelEvaluationParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModelEvaluationParametersType, sizeof(om__ModelEvaluationParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModelEvaluationParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModelEvaluationParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Sampler1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sampler1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplerType(soap, "om:Sampler", &(a->om__ModelEvaluationParametersType::Sampler), "om:SamplerType"))
				{	soap_flag_Sampler1--;
					continue;
				}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", &(a->om__ModelEvaluationParametersType::Algorithm), "om:SerializedAlgorithmType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModelEvaluationParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModelEvaluationParametersType, 0, sizeof(om__ModelEvaluationParametersType), 0, soap_copy_om__ModelEvaluationParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Sampler1 > 0 || soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ModelEvaluationParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModelEvaluationParametersType);
	if (this->soap_out(soap, tag?tag:"om:ModelEvaluationParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModelEvaluationParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModelEvaluationParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModelEvaluationParametersType * SOAP_FMAC4 soap_get_om__ModelEvaluationParametersType(struct soap *soap, om__ModelEvaluationParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModelEvaluationParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModelEvaluationParametersType * SOAP_FMAC2 soap_instantiate_om__ModelEvaluationParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModelEvaluationParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModelEvaluationParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModelEvaluationParametersType);
		if (size)
			*size = sizeof(om__ModelEvaluationParametersType);
		((om__ModelEvaluationParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModelEvaluationParametersType, n);
		if (size)
			*size = n * sizeof(om__ModelEvaluationParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModelEvaluationParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModelEvaluationParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModelEvaluationParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModelEvaluationParametersType %p -> %p\n", q, p));
	*(om__ModelEvaluationParametersType*)p = *(om__ModelEvaluationParametersType*)q;
}

void om__ProjectionParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ProjectionParametersType::Algorithm = NULL;
	this->om__ProjectionParametersType::Environment = NULL;
	this->om__ProjectionParametersType::OutputParameters = NULL;
	this->om__ProjectionParametersType::Statistics = NULL;
	/* transient soap skipped */
}

void om__ProjectionParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SerializedAlgorithmType(soap, &this->om__ProjectionParametersType::Algorithm);
	soap_serialize_PointerToom__EnvironmentType(soap, &this->om__ProjectionParametersType::Environment);
	soap_serialize_PointerToom__MapOutputParametersType(soap, &this->om__ProjectionParametersType::OutputParameters);
	soap_serialize_PointerToom__ProjectionStatisticsParametersType(soap, &this->om__ProjectionParametersType::Statistics);
	/* transient soap skipped */
#endif
}

int om__ProjectionParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ProjectionParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ProjectionParametersType(struct soap *soap, const char *tag, int id, const om__ProjectionParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ProjectionParametersType), type))
		return soap->error;
	if (a->om__ProjectionParametersType::Algorithm)
	{	if (soap_out_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", -1, &a->om__ProjectionParametersType::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	if (a->om__ProjectionParametersType::Environment)
	{	if (soap_out_PointerToom__EnvironmentType(soap, "om:Environment", -1, &a->om__ProjectionParametersType::Environment, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Environment"))
		return soap->error;
	if (soap_out_PointerToom__MapOutputParametersType(soap, "om:OutputParameters", -1, &(a->om__ProjectionParametersType::OutputParameters), ""))
		return soap->error;
	if (soap_out_PointerToom__ProjectionStatisticsParametersType(soap, "om:Statistics", -1, &(a->om__ProjectionParametersType::Statistics), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ProjectionParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ProjectionParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__ProjectionParametersType * SOAP_FMAC4 soap_in_om__ProjectionParametersType(struct soap *soap, const char *tag, om__ProjectionParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ProjectionParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ProjectionParametersType, sizeof(om__ProjectionParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ProjectionParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ProjectionParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_Environment1 = 1;
	size_t soap_flag_OutputParameters1 = 1;
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", &(a->om__ProjectionParametersType::Algorithm), "om:SerializedAlgorithmType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap_flag_Environment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__EnvironmentType(soap, "om:Environment", &(a->om__ProjectionParametersType::Environment), "om:EnvironmentType"))
				{	soap_flag_Environment1--;
					continue;
				}
			if (soap_flag_OutputParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__MapOutputParametersType(soap, "om:OutputParameters", &(a->om__ProjectionParametersType::OutputParameters), "om:MapOutputParametersType"))
				{	soap_flag_OutputParameters1--;
					continue;
				}
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ProjectionStatisticsParametersType(soap, "om:Statistics", &(a->om__ProjectionParametersType::Statistics), "om:ProjectionStatisticsParametersType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ProjectionParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ProjectionParametersType, 0, sizeof(om__ProjectionParametersType), 0, soap_copy_om__ProjectionParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Algorithm1 > 0 || soap_flag_Environment1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ProjectionParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ProjectionParametersType);
	if (this->soap_out(soap, tag?tag:"om:ProjectionParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ProjectionParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ProjectionParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__ProjectionParametersType * SOAP_FMAC4 soap_get_om__ProjectionParametersType(struct soap *soap, om__ProjectionParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ProjectionParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ProjectionParametersType * SOAP_FMAC2 soap_instantiate_om__ProjectionParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ProjectionParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ProjectionParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ProjectionParametersType);
		if (size)
			*size = sizeof(om__ProjectionParametersType);
		((om__ProjectionParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ProjectionParametersType, n);
		if (size)
			*size = n * sizeof(om__ProjectionParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ProjectionParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ProjectionParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ProjectionParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ProjectionParametersType %p -> %p\n", q, p));
	*(om__ProjectionParametersType*)p = *(om__ProjectionParametersType*)q;
}

void om__TestResultEnvelopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__TestResultEnvelopeType::Statistics = NULL;
	/* transient soap skipped */
}

void om__TestResultEnvelopeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__TestResultType(soap, &this->om__TestResultEnvelopeType::Statistics);
	/* transient soap skipped */
#endif
}

int om__TestResultEnvelopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__TestResultEnvelopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__TestResultEnvelopeType(struct soap *soap, const char *tag, int id, const om__TestResultEnvelopeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__TestResultEnvelopeType), type))
		return soap->error;
	if (soap_out_PointerToom__TestResultType(soap, "om:Statistics", -1, &(a->om__TestResultEnvelopeType::Statistics), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__TestResultEnvelopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__TestResultEnvelopeType(soap, tag, this, type);
}

SOAP_FMAC3 om__TestResultEnvelopeType * SOAP_FMAC4 soap_in_om__TestResultEnvelopeType(struct soap *soap, const char *tag, om__TestResultEnvelopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__TestResultEnvelopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__TestResultEnvelopeType, sizeof(om__TestResultEnvelopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__TestResultEnvelopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__TestResultEnvelopeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__TestResultType(soap, "om:Statistics", &(a->om__TestResultEnvelopeType::Statistics), "om:TestResultType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__TestResultEnvelopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__TestResultEnvelopeType, 0, sizeof(om__TestResultEnvelopeType), 0, soap_copy_om__TestResultEnvelopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__TestResultEnvelopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__TestResultEnvelopeType);
	if (this->soap_out(soap, tag?tag:"om:TestResultEnvelopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__TestResultEnvelopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__TestResultEnvelopeType(soap, this, tag, type);
}

SOAP_FMAC3 om__TestResultEnvelopeType * SOAP_FMAC4 soap_get_om__TestResultEnvelopeType(struct soap *soap, om__TestResultEnvelopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__TestResultEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__TestResultEnvelopeType * SOAP_FMAC2 soap_instantiate_om__TestResultEnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__TestResultEnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__TestResultEnvelopeType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__TestResultEnvelopeType);
		if (size)
			*size = sizeof(om__TestResultEnvelopeType);
		((om__TestResultEnvelopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestResultEnvelopeType, n);
		if (size)
			*size = n * sizeof(om__TestResultEnvelopeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__TestResultEnvelopeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__TestResultEnvelopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__TestResultEnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__TestResultEnvelopeType %p -> %p\n", q, p));
	*(om__TestResultEnvelopeType*)p = *(om__TestResultEnvelopeType*)q;
}

void om__TestParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__TestParametersType::Sampler = NULL;
	this->om__TestParametersType::Algorithm = NULL;
	this->om__TestParametersType::Statistics = NULL;
	/* transient soap skipped */
}

void om__TestParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SamplerType(soap, &this->om__TestParametersType::Sampler);
	soap_serialize_PointerToom__SerializedAlgorithmType(soap, &this->om__TestParametersType::Algorithm);
	soap_serialize_PointerToom__TestOptionsType(soap, &this->om__TestParametersType::Statistics);
	/* transient soap skipped */
#endif
}

int om__TestParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__TestParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__TestParametersType(struct soap *soap, const char *tag, int id, const om__TestParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__TestParametersType), type))
		return soap->error;
	if (a->om__TestParametersType::Sampler)
	{	if (soap_out_PointerToom__SamplerType(soap, "om:Sampler", -1, &a->om__TestParametersType::Sampler, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Sampler"))
		return soap->error;
	if (a->om__TestParametersType::Algorithm)
	{	if (soap_out_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", -1, &a->om__TestParametersType::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	if (soap_out_PointerToom__TestOptionsType(soap, "om:Statistics", -1, &(a->om__TestParametersType::Statistics), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__TestParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__TestParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__TestParametersType * SOAP_FMAC4 soap_in_om__TestParametersType(struct soap *soap, const char *tag, om__TestParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__TestParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__TestParametersType, sizeof(om__TestParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__TestParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__TestParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Sampler1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sampler1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplerType(soap, "om:Sampler", &(a->om__TestParametersType::Sampler), "om:SamplerType"))
				{	soap_flag_Sampler1--;
					continue;
				}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", &(a->om__TestParametersType::Algorithm), "om:SerializedAlgorithmType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__TestOptionsType(soap, "om:Statistics", &(a->om__TestParametersType::Statistics), "om:TestOptionsType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__TestParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__TestParametersType, 0, sizeof(om__TestParametersType), 0, soap_copy_om__TestParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Sampler1 > 0 || soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__TestParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__TestParametersType);
	if (this->soap_out(soap, tag?tag:"om:TestParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__TestParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__TestParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__TestParametersType * SOAP_FMAC4 soap_get_om__TestParametersType(struct soap *soap, om__TestParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__TestParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__TestParametersType * SOAP_FMAC2 soap_instantiate_om__TestParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__TestParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__TestParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__TestParametersType);
		if (size)
			*size = sizeof(om__TestParametersType);
		((om__TestParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestParametersType, n);
		if (size)
			*size = n * sizeof(om__TestParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__TestParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__TestParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__TestParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__TestParametersType %p -> %p\n", q, p));
	*(om__TestParametersType*)p = *(om__TestParametersType*)q;
}

void om__SerializedModelType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__SerializedModelType::Sampler = NULL;
	this->om__SerializedModelType::Algorithm = NULL;
	this->om__SerializedModelType::Statistics = NULL;
	/* transient soap skipped */
}

void om__SerializedModelType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SamplerType(soap, &this->om__SerializedModelType::Sampler);
	soap_serialize_PointerToom__SerializedAlgorithmType(soap, &this->om__SerializedModelType::Algorithm);
	soap_serialize_PointerToom__TestResultType(soap, &this->om__SerializedModelType::Statistics);
	/* transient soap skipped */
#endif
}

int om__SerializedModelType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SerializedModelType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SerializedModelType(struct soap *soap, const char *tag, int id, const om__SerializedModelType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SerializedModelType), type))
		return soap->error;
	if (a->om__SerializedModelType::Sampler)
	{	if (soap_out_PointerToom__SamplerType(soap, "om:Sampler", -1, &a->om__SerializedModelType::Sampler, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Sampler"))
		return soap->error;
	if (a->om__SerializedModelType::Algorithm)
	{	if (soap_out_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", -1, &a->om__SerializedModelType::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	if (soap_out_PointerToom__TestResultType(soap, "om:Statistics", -1, &(a->om__SerializedModelType::Statistics), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__SerializedModelType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SerializedModelType(soap, tag, this, type);
}

SOAP_FMAC3 om__SerializedModelType * SOAP_FMAC4 soap_in_om__SerializedModelType(struct soap *soap, const char *tag, om__SerializedModelType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SerializedModelType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SerializedModelType, sizeof(om__SerializedModelType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SerializedModelType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SerializedModelType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Sampler1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_Statistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sampler1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplerType(soap, "om:Sampler", &(a->om__SerializedModelType::Sampler), "om:SamplerType"))
				{	soap_flag_Sampler1--;
					continue;
				}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedAlgorithmType(soap, "om:Algorithm", &(a->om__SerializedModelType::Algorithm), "om:SerializedAlgorithmType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap_flag_Statistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__TestResultType(soap, "om:Statistics", &(a->om__SerializedModelType::Statistics), "om:TestResultType"))
				{	soap_flag_Statistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SerializedModelType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SerializedModelType, 0, sizeof(om__SerializedModelType), 0, soap_copy_om__SerializedModelType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Sampler1 > 0 || soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__SerializedModelType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SerializedModelType);
	if (this->soap_out(soap, tag?tag:"om:SerializedModelType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SerializedModelType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SerializedModelType(soap, this, tag, type);
}

SOAP_FMAC3 om__SerializedModelType * SOAP_FMAC4 soap_get_om__SerializedModelType(struct soap *soap, om__SerializedModelType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SerializedModelType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SerializedModelType * SOAP_FMAC2 soap_instantiate_om__SerializedModelType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SerializedModelType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SerializedModelType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SerializedModelType);
		if (size)
			*size = sizeof(om__SerializedModelType);
		((om__SerializedModelType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SerializedModelType, n);
		if (size)
			*size = n * sizeof(om__SerializedModelType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SerializedModelType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SerializedModelType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SerializedModelType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SerializedModelType %p -> %p\n", q, p));
	*(om__SerializedModelType*)p = *(om__SerializedModelType*)q;
}

void om__ModelEnvelopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModelEnvelopeType::SerializedModel = NULL;
	/* transient soap skipped */
}

void om__ModelEnvelopeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SerializedModelType(soap, &this->om__ModelEnvelopeType::SerializedModel);
	/* transient soap skipped */
#endif
}

int om__ModelEnvelopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModelEnvelopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModelEnvelopeType(struct soap *soap, const char *tag, int id, const om__ModelEnvelopeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModelEnvelopeType), type))
		return soap->error;
	if (a->om__ModelEnvelopeType::SerializedModel)
	{	if (soap_out_PointerToom__SerializedModelType(soap, "om:SerializedModel", -1, &a->om__ModelEnvelopeType::SerializedModel, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:SerializedModel"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModelEnvelopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModelEnvelopeType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModelEnvelopeType * SOAP_FMAC4 soap_in_om__ModelEnvelopeType(struct soap *soap, const char *tag, om__ModelEnvelopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModelEnvelopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModelEnvelopeType, sizeof(om__ModelEnvelopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModelEnvelopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModelEnvelopeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SerializedModel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SerializedModel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SerializedModelType(soap, "om:SerializedModel", &(a->om__ModelEnvelopeType::SerializedModel), "om:SerializedModelType"))
				{	soap_flag_SerializedModel1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModelEnvelopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModelEnvelopeType, 0, sizeof(om__ModelEnvelopeType), 0, soap_copy_om__ModelEnvelopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SerializedModel1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ModelEnvelopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModelEnvelopeType);
	if (this->soap_out(soap, tag?tag:"om:ModelEnvelopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModelEnvelopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModelEnvelopeType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModelEnvelopeType * SOAP_FMAC4 soap_get_om__ModelEnvelopeType(struct soap *soap, om__ModelEnvelopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModelEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModelEnvelopeType * SOAP_FMAC2 soap_instantiate_om__ModelEnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModelEnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModelEnvelopeType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModelEnvelopeType);
		if (size)
			*size = sizeof(om__ModelEnvelopeType);
		((om__ModelEnvelopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModelEnvelopeType, n);
		if (size)
			*size = n * sizeof(om__ModelEnvelopeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModelEnvelopeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModelEnvelopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModelEnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModelEnvelopeType %p -> %p\n", q, p));
	*(om__ModelEnvelopeType*)p = *(om__ModelEnvelopeType*)q;
}

void om__ModelOptionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModelOptionsType::OccurrencesFilter = NULL;
	/* transient soap skipped */
}

void om__ModelOptionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__OccurrencesFilterType(soap, &this->om__ModelOptionsType::OccurrencesFilter);
	/* transient soap skipped */
#endif
}

int om__ModelOptionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModelOptionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModelOptionsType(struct soap *soap, const char *tag, int id, const om__ModelOptionsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModelOptionsType), type))
		return soap->error;
	if (soap_out_PointerToom__OccurrencesFilterType(soap, "om:OccurrencesFilter", -1, &(a->om__ModelOptionsType::OccurrencesFilter), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModelOptionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModelOptionsType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModelOptionsType * SOAP_FMAC4 soap_in_om__ModelOptionsType(struct soap *soap, const char *tag, om__ModelOptionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModelOptionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModelOptionsType, sizeof(om__ModelOptionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModelOptionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModelOptionsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OccurrencesFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OccurrencesFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__OccurrencesFilterType(soap, "om:OccurrencesFilter", &(a->om__ModelOptionsType::OccurrencesFilter), "om:OccurrencesFilterType"))
				{	soap_flag_OccurrencesFilter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModelOptionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModelOptionsType, 0, sizeof(om__ModelOptionsType), 0, soap_copy_om__ModelOptionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__ModelOptionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModelOptionsType);
	if (this->soap_out(soap, tag?tag:"om:ModelOptionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModelOptionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModelOptionsType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModelOptionsType * SOAP_FMAC4 soap_get_om__ModelOptionsType(struct soap *soap, om__ModelOptionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModelOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModelOptionsType * SOAP_FMAC2 soap_instantiate_om__ModelOptionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModelOptionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModelOptionsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModelOptionsType);
		if (size)
			*size = sizeof(om__ModelOptionsType);
		((om__ModelOptionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModelOptionsType, n);
		if (size)
			*size = n * sizeof(om__ModelOptionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModelOptionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModelOptionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModelOptionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModelOptionsType %p -> %p\n", q, p));
	*(om__ModelOptionsType*)p = *(om__ModelOptionsType*)q;
}

void om__OccurrencesFilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__OccurrencesFilterType::__union_OccurrencesFilterType = 0;
	/* transient soap skipped */
}

void om__OccurrencesFilterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__om__union_OccurrencesFilterType(soap, this->om__OccurrencesFilterType::__union_OccurrencesFilterType, &this->om__OccurrencesFilterType::union_OccurrencesFilterType);
	/* transient soap skipped */
#endif
}

int om__OccurrencesFilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__OccurrencesFilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__OccurrencesFilterType(struct soap *soap, const char *tag, int id, const om__OccurrencesFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__OccurrencesFilterType), type))
		return soap->error;
	if (soap_out__om__union_OccurrencesFilterType(soap, a->om__OccurrencesFilterType::__union_OccurrencesFilterType, &a->om__OccurrencesFilterType::union_OccurrencesFilterType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__OccurrencesFilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__OccurrencesFilterType(soap, tag, this, type);
}

SOAP_FMAC3 om__OccurrencesFilterType * SOAP_FMAC4 soap_in_om__OccurrencesFilterType(struct soap *soap, const char *tag, om__OccurrencesFilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__OccurrencesFilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__OccurrencesFilterType, sizeof(om__OccurrencesFilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__om__union_OccurrencesFilterType(soap, &a->__union_OccurrencesFilterType, &a->union_OccurrencesFilterType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__OccurrencesFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__OccurrencesFilterType, 0, sizeof(om__OccurrencesFilterType), 0, soap_copy_om__OccurrencesFilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__OccurrencesFilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__OccurrencesFilterType);
	if (this->soap_out(soap, tag?tag:"om:OccurrencesFilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__OccurrencesFilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__OccurrencesFilterType(soap, this, tag, type);
}

SOAP_FMAC3 om__OccurrencesFilterType * SOAP_FMAC4 soap_get_om__OccurrencesFilterType(struct soap *soap, om__OccurrencesFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__OccurrencesFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__OccurrencesFilterType * SOAP_FMAC2 soap_instantiate_om__OccurrencesFilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__OccurrencesFilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__OccurrencesFilterType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__OccurrencesFilterType);
		if (size)
			*size = sizeof(om__OccurrencesFilterType);
		((om__OccurrencesFilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__OccurrencesFilterType, n);
		if (size)
			*size = n * sizeof(om__OccurrencesFilterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__OccurrencesFilterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__OccurrencesFilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__OccurrencesFilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__OccurrencesFilterType %p -> %p\n", q, p));
	*(om__OccurrencesFilterType*)p = *(om__OccurrencesFilterType*)q;
}

void om__ModelParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModelParametersType::Sampler = NULL;
	this->om__ModelParametersType::Algorithm = NULL;
	this->om__ModelParametersType::Options = NULL;
	/* transient soap skipped */
}

void om__ModelParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__SamplerType(soap, &this->om__ModelParametersType::Sampler);
	soap_serialize_PointerToom__BasicAlgorithmDefinitionType(soap, &this->om__ModelParametersType::Algorithm);
	soap_serialize_PointerToom__ModelOptionsType(soap, &this->om__ModelParametersType::Options);
	/* transient soap skipped */
#endif
}

int om__ModelParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModelParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModelParametersType(struct soap *soap, const char *tag, int id, const om__ModelParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModelParametersType), type))
		return soap->error;
	if (a->om__ModelParametersType::Sampler)
	{	if (soap_out_PointerToom__SamplerType(soap, "om:Sampler", -1, &a->om__ModelParametersType::Sampler, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Sampler"))
		return soap->error;
	if (a->om__ModelParametersType::Algorithm)
	{	if (soap_out_PointerToom__BasicAlgorithmDefinitionType(soap, "om:Algorithm", -1, &a->om__ModelParametersType::Algorithm, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithm"))
		return soap->error;
	if (soap_out_PointerToom__ModelOptionsType(soap, "om:Options", -1, &(a->om__ModelParametersType::Options), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModelParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModelParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModelParametersType * SOAP_FMAC4 soap_in_om__ModelParametersType(struct soap *soap, const char *tag, om__ModelParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModelParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModelParametersType, sizeof(om__ModelParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModelParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModelParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Sampler1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sampler1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__SamplerType(soap, "om:Sampler", &(a->om__ModelParametersType::Sampler), "om:SamplerType"))
				{	soap_flag_Sampler1--;
					continue;
				}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__BasicAlgorithmDefinitionType(soap, "om:Algorithm", &(a->om__ModelParametersType::Algorithm), "om:BasicAlgorithmDefinitionType"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__ModelOptionsType(soap, "om:Options", &(a->om__ModelParametersType::Options), "om:ModelOptionsType"))
				{	soap_flag_Options1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModelParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModelParametersType, 0, sizeof(om__ModelParametersType), 0, soap_copy_om__ModelParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Sampler1 > 0 || soap_flag_Algorithm1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ModelParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModelParametersType);
	if (this->soap_out(soap, tag?tag:"om:ModelParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModelParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModelParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModelParametersType * SOAP_FMAC4 soap_get_om__ModelParametersType(struct soap *soap, om__ModelParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModelParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModelParametersType * SOAP_FMAC2 soap_instantiate_om__ModelParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModelParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModelParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModelParametersType);
		if (size)
			*size = sizeof(om__ModelParametersType);
		((om__ModelParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModelParametersType, n);
		if (size)
			*size = n * sizeof(om__ModelParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModelParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModelParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModelParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModelParametersType %p -> %p\n", q, p));
	*(om__ModelParametersType*)p = *(om__ModelParametersType*)q;
}

void om__MapOutputParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__MapOutputParametersType::TemplateLayer = NULL;
	this->om__MapOutputParametersType::FileType = NULL;
	/* transient soap skipped */
}

void om__MapOutputParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__BasicLayerType(soap, &this->om__MapOutputParametersType::TemplateLayer);
	/* transient soap skipped */
#endif
}

int om__MapOutputParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__MapOutputParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__MapOutputParametersType(struct soap *soap, const char *tag, int id, const om__MapOutputParametersType *a, const char *type)
{
	if (((om__MapOutputParametersType*)a)->FileType)
		soap_set_attr(soap, "FileType", ((om__MapOutputParametersType*)a)->FileType->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__MapOutputParametersType), type))
		return soap->error;
	if (a->om__MapOutputParametersType::TemplateLayer)
	{	if (soap_out_PointerToom__BasicLayerType(soap, "om:TemplateLayer", -1, &a->om__MapOutputParametersType::TemplateLayer, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:TemplateLayer"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__MapOutputParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__MapOutputParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__MapOutputParametersType * SOAP_FMAC4 soap_in_om__MapOutputParametersType(struct soap *soap, const char *tag, om__MapOutputParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__MapOutputParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__MapOutputParametersType, sizeof(om__MapOutputParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__MapOutputParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__MapOutputParametersType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "FileType", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__MapOutputParametersType*)a)->FileType = soap_new_std__string(soap, -1);
				((om__MapOutputParametersType*)a)->FileType->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_TemplateLayer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TemplateLayer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__BasicLayerType(soap, "om:TemplateLayer", &(a->om__MapOutputParametersType::TemplateLayer), "om:BasicLayerType"))
				{	soap_flag_TemplateLayer1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__MapOutputParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__MapOutputParametersType, 0, sizeof(om__MapOutputParametersType), 0, soap_copy_om__MapOutputParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TemplateLayer1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__MapOutputParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__MapOutputParametersType);
	if (this->soap_out(soap, tag?tag:"om:MapOutputParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__MapOutputParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__MapOutputParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__MapOutputParametersType * SOAP_FMAC4 soap_get_om__MapOutputParametersType(struct soap *soap, om__MapOutputParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__MapOutputParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__MapOutputParametersType * SOAP_FMAC2 soap_instantiate_om__MapOutputParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__MapOutputParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__MapOutputParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__MapOutputParametersType);
		if (size)
			*size = sizeof(om__MapOutputParametersType);
		((om__MapOutputParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__MapOutputParametersType, n);
		if (size)
			*size = n * sizeof(om__MapOutputParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__MapOutputParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__MapOutputParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__MapOutputParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__MapOutputParametersType %p -> %p\n", q, p));
	*(om__MapOutputParametersType*)p = *(om__MapOutputParametersType*)q;
}

void om__AreaStatisticsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->om__AreaStatisticsType::TotalCells);
	soap_default_int(soap, &this->om__AreaStatisticsType::CellsPredicted);
	soap_default_om__ZeroOneIntervalType(soap, &this->om__AreaStatisticsType::PredictionThreshold);
	/* transient soap skipped */
}

void om__AreaStatisticsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int om__AreaStatisticsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__AreaStatisticsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__AreaStatisticsType(struct soap *soap, const char *tag, int id, const om__AreaStatisticsType *a, const char *type)
{
	soap_set_attr(soap, "TotalCells", soap_int2s(soap, ((om__AreaStatisticsType*)a)->TotalCells), 1);
	soap_set_attr(soap, "CellsPredicted", soap_int2s(soap, ((om__AreaStatisticsType*)a)->CellsPredicted), 1);
	soap_set_attr(soap, "PredictionThreshold", soap_double2s(soap, ((om__AreaStatisticsType*)a)->PredictionThreshold), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__AreaStatisticsType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__AreaStatisticsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__AreaStatisticsType(soap, tag, this, type);
}

SOAP_FMAC3 om__AreaStatisticsType * SOAP_FMAC4 soap_in_om__AreaStatisticsType(struct soap *soap, const char *tag, om__AreaStatisticsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__AreaStatisticsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__AreaStatisticsType, sizeof(om__AreaStatisticsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__AreaStatisticsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__AreaStatisticsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "TotalCells", 1), &((om__AreaStatisticsType*)a)->TotalCells))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "CellsPredicted", 1), &((om__AreaStatisticsType*)a)->CellsPredicted))
		return NULL;
	if (soap_s2double(soap, soap_attr_value(soap, "PredictionThreshold", 1), &((om__AreaStatisticsType*)a)->PredictionThreshold))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__AreaStatisticsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__AreaStatisticsType, 0, sizeof(om__AreaStatisticsType), 0, soap_copy_om__AreaStatisticsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__AreaStatisticsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__AreaStatisticsType);
	if (this->soap_out(soap, tag?tag:"om:AreaStatisticsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__AreaStatisticsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__AreaStatisticsType(soap, this, tag, type);
}

SOAP_FMAC3 om__AreaStatisticsType * SOAP_FMAC4 soap_get_om__AreaStatisticsType(struct soap *soap, om__AreaStatisticsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__AreaStatisticsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__AreaStatisticsType * SOAP_FMAC2 soap_instantiate_om__AreaStatisticsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__AreaStatisticsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__AreaStatisticsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__AreaStatisticsType);
		if (size)
			*size = sizeof(om__AreaStatisticsType);
		((om__AreaStatisticsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__AreaStatisticsType, n);
		if (size)
			*size = n * sizeof(om__AreaStatisticsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__AreaStatisticsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__AreaStatisticsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__AreaStatisticsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__AreaStatisticsType %p -> %p\n", q, p));
	*(om__AreaStatisticsType*)p = *(om__AreaStatisticsType*)q;
}

void om__ProjectionEnvelopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ProjectionEnvelopeType::AreaStatistics = NULL;
	/* transient soap skipped */
}

void om__ProjectionEnvelopeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__AreaStatisticsType(soap, &this->om__ProjectionEnvelopeType::AreaStatistics);
	/* transient soap skipped */
#endif
}

int om__ProjectionEnvelopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ProjectionEnvelopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ProjectionEnvelopeType(struct soap *soap, const char *tag, int id, const om__ProjectionEnvelopeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ProjectionEnvelopeType), type))
		return soap->error;
	if (a->om__ProjectionEnvelopeType::AreaStatistics)
	{	if (soap_out_PointerToom__AreaStatisticsType(soap, "om:AreaStatistics", -1, &a->om__ProjectionEnvelopeType::AreaStatistics, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:AreaStatistics"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ProjectionEnvelopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ProjectionEnvelopeType(soap, tag, this, type);
}

SOAP_FMAC3 om__ProjectionEnvelopeType * SOAP_FMAC4 soap_in_om__ProjectionEnvelopeType(struct soap *soap, const char *tag, om__ProjectionEnvelopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ProjectionEnvelopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ProjectionEnvelopeType, sizeof(om__ProjectionEnvelopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ProjectionEnvelopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ProjectionEnvelopeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaStatistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaStatistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__AreaStatisticsType(soap, "om:AreaStatistics", &(a->om__ProjectionEnvelopeType::AreaStatistics), "om:AreaStatisticsType"))
				{	soap_flag_AreaStatistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ProjectionEnvelopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ProjectionEnvelopeType, 0, sizeof(om__ProjectionEnvelopeType), 0, soap_copy_om__ProjectionEnvelopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AreaStatistics1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__ProjectionEnvelopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ProjectionEnvelopeType);
	if (this->soap_out(soap, tag?tag:"om:ProjectionEnvelopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ProjectionEnvelopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ProjectionEnvelopeType(soap, this, tag, type);
}

SOAP_FMAC3 om__ProjectionEnvelopeType * SOAP_FMAC4 soap_get_om__ProjectionEnvelopeType(struct soap *soap, om__ProjectionEnvelopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ProjectionEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ProjectionEnvelopeType * SOAP_FMAC2 soap_instantiate_om__ProjectionEnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ProjectionEnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ProjectionEnvelopeType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ProjectionEnvelopeType);
		if (size)
			*size = sizeof(om__ProjectionEnvelopeType);
		((om__ProjectionEnvelopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ProjectionEnvelopeType, n);
		if (size)
			*size = n * sizeof(om__ProjectionEnvelopeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ProjectionEnvelopeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ProjectionEnvelopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ProjectionEnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ProjectionEnvelopeType %p -> %p\n", q, p));
	*(om__ProjectionEnvelopeType*)p = *(om__ProjectionEnvelopeType*)q;
}

void om__ProjectionStatisticsParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ProjectionStatisticsParametersType::AreaStatistics = NULL;
	/* transient soap skipped */
}

void om__ProjectionStatisticsParametersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, &this->om__ProjectionStatisticsParametersType::AreaStatistics);
	/* transient soap skipped */
#endif
}

int om__ProjectionStatisticsParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ProjectionStatisticsParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ProjectionStatisticsParametersType(struct soap *soap, const char *tag, int id, const om__ProjectionStatisticsParametersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ProjectionStatisticsParametersType), type))
		return soap->error;
	if (soap_out_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, "om:AreaStatistics", -1, &(a->om__ProjectionStatisticsParametersType::AreaStatistics), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ProjectionStatisticsParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ProjectionStatisticsParametersType(soap, tag, this, type);
}

SOAP_FMAC3 om__ProjectionStatisticsParametersType * SOAP_FMAC4 soap_in_om__ProjectionStatisticsParametersType(struct soap *soap, const char *tag, om__ProjectionStatisticsParametersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ProjectionStatisticsParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ProjectionStatisticsParametersType, sizeof(om__ProjectionStatisticsParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ProjectionStatisticsParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ProjectionStatisticsParametersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AreaStatistics1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AreaStatistics1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, "om:AreaStatistics", &(a->om__ProjectionStatisticsParametersType::AreaStatistics), ""))
				{	soap_flag_AreaStatistics1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ProjectionStatisticsParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ProjectionStatisticsParametersType, 0, sizeof(om__ProjectionStatisticsParametersType), 0, soap_copy_om__ProjectionStatisticsParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__ProjectionStatisticsParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ProjectionStatisticsParametersType);
	if (this->soap_out(soap, tag?tag:"om:ProjectionStatisticsParametersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ProjectionStatisticsParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ProjectionStatisticsParametersType(soap, this, tag, type);
}

SOAP_FMAC3 om__ProjectionStatisticsParametersType * SOAP_FMAC4 soap_get_om__ProjectionStatisticsParametersType(struct soap *soap, om__ProjectionStatisticsParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ProjectionStatisticsParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ProjectionStatisticsParametersType * SOAP_FMAC2 soap_instantiate_om__ProjectionStatisticsParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ProjectionStatisticsParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ProjectionStatisticsParametersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ProjectionStatisticsParametersType);
		if (size)
			*size = sizeof(om__ProjectionStatisticsParametersType);
		((om__ProjectionStatisticsParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ProjectionStatisticsParametersType, n);
		if (size)
			*size = n * sizeof(om__ProjectionStatisticsParametersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ProjectionStatisticsParametersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ProjectionStatisticsParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ProjectionStatisticsParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ProjectionStatisticsParametersType %p -> %p\n", q, p));
	*(om__ProjectionStatisticsParametersType*)p = *(om__ProjectionStatisticsParametersType*)q;
}

void om__TestResultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__TestResultType::ConfusionMatrix = NULL;
	this->om__TestResultType::RocCurve = NULL;
	/* transient soap skipped */
}

void om__TestResultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_om__TestResultType_ConfusionMatrix(soap, &this->om__TestResultType::ConfusionMatrix);
	soap_serialize_PointerTo_om__TestResultType_RocCurve(soap, &this->om__TestResultType::RocCurve);
	/* transient soap skipped */
#endif
}

int om__TestResultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__TestResultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__TestResultType(struct soap *soap, const char *tag, int id, const om__TestResultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__TestResultType), type))
		return soap->error;
	if (soap_out_PointerTo_om__TestResultType_ConfusionMatrix(soap, "om:ConfusionMatrix", -1, &(a->om__TestResultType::ConfusionMatrix), ""))
		return soap->error;
	if (soap_out_PointerTo_om__TestResultType_RocCurve(soap, "om:RocCurve", -1, &(a->om__TestResultType::RocCurve), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__TestResultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__TestResultType(soap, tag, this, type);
}

SOAP_FMAC3 om__TestResultType * SOAP_FMAC4 soap_in_om__TestResultType(struct soap *soap, const char *tag, om__TestResultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__TestResultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__TestResultType, sizeof(om__TestResultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__TestResultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__TestResultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfusionMatrix1 = 1;
	size_t soap_flag_RocCurve1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfusionMatrix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__TestResultType_ConfusionMatrix(soap, "om:ConfusionMatrix", &(a->om__TestResultType::ConfusionMatrix), ""))
				{	soap_flag_ConfusionMatrix1--;
					continue;
				}
			if (soap_flag_RocCurve1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__TestResultType_RocCurve(soap, "om:RocCurve", &(a->om__TestResultType::RocCurve), ""))
				{	soap_flag_RocCurve1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__TestResultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__TestResultType, 0, sizeof(om__TestResultType), 0, soap_copy_om__TestResultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__TestResultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__TestResultType);
	if (this->soap_out(soap, tag?tag:"om:TestResultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__TestResultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__TestResultType(soap, this, tag, type);
}

SOAP_FMAC3 om__TestResultType * SOAP_FMAC4 soap_get_om__TestResultType(struct soap *soap, om__TestResultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__TestResultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__TestResultType * SOAP_FMAC2 soap_instantiate_om__TestResultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__TestResultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__TestResultType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__TestResultType);
		if (size)
			*size = sizeof(om__TestResultType);
		((om__TestResultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestResultType, n);
		if (size)
			*size = n * sizeof(om__TestResultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__TestResultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__TestResultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__TestResultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__TestResultType %p -> %p\n", q, p));
	*(om__TestResultType*)p = *(om__TestResultType*)q;
}

void om__TestOptionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__TestOptionsType::ConfusionMatrix = NULL;
	this->om__TestOptionsType::RocCurve = NULL;
	/* transient soap skipped */
}

void om__TestOptionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, &this->om__TestOptionsType::ConfusionMatrix);
	soap_serialize_PointerTo_om__TestOptionsType_RocCurve(soap, &this->om__TestOptionsType::RocCurve);
	/* transient soap skipped */
#endif
}

int om__TestOptionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__TestOptionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__TestOptionsType(struct soap *soap, const char *tag, int id, const om__TestOptionsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__TestOptionsType), type))
		return soap->error;
	if (soap_out_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, "om:ConfusionMatrix", -1, &(a->om__TestOptionsType::ConfusionMatrix), ""))
		return soap->error;
	if (soap_out_PointerTo_om__TestOptionsType_RocCurve(soap, "om:RocCurve", -1, &(a->om__TestOptionsType::RocCurve), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__TestOptionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__TestOptionsType(soap, tag, this, type);
}

SOAP_FMAC3 om__TestOptionsType * SOAP_FMAC4 soap_in_om__TestOptionsType(struct soap *soap, const char *tag, om__TestOptionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__TestOptionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__TestOptionsType, sizeof(om__TestOptionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__TestOptionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__TestOptionsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ConfusionMatrix1 = 1;
	size_t soap_flag_RocCurve1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfusionMatrix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, "om:ConfusionMatrix", &(a->om__TestOptionsType::ConfusionMatrix), ""))
				{	soap_flag_ConfusionMatrix1--;
					continue;
				}
			if (soap_flag_RocCurve1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_om__TestOptionsType_RocCurve(soap, "om:RocCurve", &(a->om__TestOptionsType::RocCurve), ""))
				{	soap_flag_RocCurve1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__TestOptionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__TestOptionsType, 0, sizeof(om__TestOptionsType), 0, soap_copy_om__TestOptionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__TestOptionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__TestOptionsType);
	if (this->soap_out(soap, tag?tag:"om:TestOptionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__TestOptionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__TestOptionsType(soap, this, tag, type);
}

SOAP_FMAC3 om__TestOptionsType * SOAP_FMAC4 soap_get_om__TestOptionsType(struct soap *soap, om__TestOptionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__TestOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__TestOptionsType * SOAP_FMAC2 soap_instantiate_om__TestOptionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__TestOptionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__TestOptionsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__TestOptionsType);
		if (size)
			*size = sizeof(om__TestOptionsType);
		((om__TestOptionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__TestOptionsType, n);
		if (size)
			*size = n * sizeof(om__TestOptionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__TestOptionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__TestOptionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__TestOptionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__TestOptionsType %p -> %p\n", q, p));
	*(om__TestOptionsType*)p = *(om__TestOptionsType*)q;
}

void om__NormalizationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__NormalizationType::Class = NULL;
	this->om__NormalizationType::UseLayerAsRef = NULL;
	this->om__NormalizationType::Min = NULL;
	this->om__NormalizationType::Max = NULL;
	this->om__NormalizationType::Scales = NULL;
	this->om__NormalizationType::Offsets = NULL;
	this->om__NormalizationType::Mean = NULL;
	this->om__NormalizationType::StdDev = NULL;
	/* transient soap skipped */
}

void om__NormalizationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int om__NormalizationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__NormalizationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__NormalizationType(struct soap *soap, const char *tag, int id, const om__NormalizationType *a, const char *type)
{
	if (((om__NormalizationType*)a)->Class)
		soap_set_attr(soap, "Class", ((om__NormalizationType*)a)->Class->c_str(), 1);
	if (((om__NormalizationType*)a)->UseLayerAsRef)
		soap_set_attr(soap, "UseLayerAsRef", soap_bool2s(soap, *((om__NormalizationType*)a)->UseLayerAsRef), 1);
	if (((om__NormalizationType*)a)->Min)
		soap_set_attr(soap, "Min", soap_double2s(soap, *((om__NormalizationType*)a)->Min), 1);
	if (((om__NormalizationType*)a)->Max)
		soap_set_attr(soap, "Max", soap_double2s(soap, *((om__NormalizationType*)a)->Max), 1);
	if (((om__NormalizationType*)a)->Scales)
		soap_set_attr(soap, "Scales", ((om__NormalizationType*)a)->Scales->c_str(), 1);
	if (((om__NormalizationType*)a)->Offsets)
		soap_set_attr(soap, "Offsets", ((om__NormalizationType*)a)->Offsets->c_str(), 1);
	if (((om__NormalizationType*)a)->Mean)
		soap_set_attr(soap, "Mean", ((om__NormalizationType*)a)->Mean->c_str(), 1);
	if (((om__NormalizationType*)a)->StdDev)
		soap_set_attr(soap, "StdDev", ((om__NormalizationType*)a)->StdDev->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__NormalizationType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__NormalizationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__NormalizationType(soap, tag, this, type);
}

SOAP_FMAC3 om__NormalizationType * SOAP_FMAC4 soap_in_om__NormalizationType(struct soap *soap, const char *tag, om__NormalizationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__NormalizationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__NormalizationType, sizeof(om__NormalizationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__NormalizationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__NormalizationType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Class", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__NormalizationType*)a)->Class = soap_new_std__string(soap, -1);
				((om__NormalizationType*)a)->Class->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "UseLayerAsRef", 0);
		if (t)
		{
			if (!(((om__NormalizationType*)a)->UseLayerAsRef = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((om__NormalizationType*)a)->UseLayerAsRef))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Min", 0);
		if (t)
		{
			if (!(((om__NormalizationType*)a)->Min = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__NormalizationType*)a)->Min))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Max", 0);
		if (t)
		{
			if (!(((om__NormalizationType*)a)->Max = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__NormalizationType*)a)->Max))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Scales", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__NormalizationType*)a)->Scales = soap_new_std__string(soap, -1);
				((om__NormalizationType*)a)->Scales->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Offsets", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__NormalizationType*)a)->Offsets = soap_new_std__string(soap, -1);
				((om__NormalizationType*)a)->Offsets->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Mean", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__NormalizationType*)a)->Mean = soap_new_std__string(soap, -1);
				((om__NormalizationType*)a)->Mean->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "StdDev", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__NormalizationType*)a)->StdDev = soap_new_std__string(soap, -1);
				((om__NormalizationType*)a)->StdDev->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__NormalizationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__NormalizationType, 0, sizeof(om__NormalizationType), 0, soap_copy_om__NormalizationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__NormalizationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__NormalizationType);
	if (this->soap_out(soap, tag?tag:"om:NormalizationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__NormalizationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__NormalizationType(soap, this, tag, type);
}

SOAP_FMAC3 om__NormalizationType * SOAP_FMAC4 soap_get_om__NormalizationType(struct soap *soap, om__NormalizationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__NormalizationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__NormalizationType * SOAP_FMAC2 soap_instantiate_om__NormalizationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__NormalizationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__NormalizationType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__NormalizationType);
		if (size)
			*size = sizeof(om__NormalizationType);
		((om__NormalizationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__NormalizationType, n);
		if (size)
			*size = n * sizeof(om__NormalizationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__NormalizationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__NormalizationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__NormalizationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__NormalizationType %p -> %p\n", q, p));
	*(om__NormalizationType*)p = *(om__NormalizationType*)q;
}

void om__SamplerType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__SamplerType::Environment = NULL;
	this->om__SamplerType::Presence = NULL;
	this->om__SamplerType::Absence = NULL;
	this->om__SamplerType::Absence_ = NULL;
	/* transient soap skipped */
}

void om__SamplerType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__EnvironmentType(soap, &this->om__SamplerType::Environment);
	soap_serialize_PointerToom__OccurrencesType(soap, &this->om__SamplerType::Presence);
	soap_serialize_PointerToom__OccurrencesType(soap, &this->om__SamplerType::Absence);
	soap_serialize_PointerToom__OccurrencesType(soap, &this->om__SamplerType::Absence_);
	/* transient soap skipped */
#endif
}

int om__SamplerType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SamplerType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SamplerType(struct soap *soap, const char *tag, int id, const om__SamplerType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SamplerType), type))
		return soap->error;
	if (a->om__SamplerType::Environment)
	{	if (soap_out_PointerToom__EnvironmentType(soap, "om:Environment", -1, &a->om__SamplerType::Environment, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Environment"))
		return soap->error;
	if (soap_out_PointerToom__OccurrencesType(soap, "om:Presence", -1, &(a->om__SamplerType::Presence), ""))
		return soap->error;
	if (soap_out_PointerToom__OccurrencesType(soap, "om:Absence", -1, &(a->om__SamplerType::Absence), ""))
		return soap->error;
	if (soap_out_PointerToom__OccurrencesType(soap, "om:Absence", -1, &(a->om__SamplerType::Absence_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__SamplerType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SamplerType(soap, tag, this, type);
}

SOAP_FMAC3 om__SamplerType * SOAP_FMAC4 soap_in_om__SamplerType(struct soap *soap, const char *tag, om__SamplerType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SamplerType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SamplerType, sizeof(om__SamplerType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SamplerType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SamplerType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Environment1 = 1;
	size_t soap_flag_Presence1 = 1;
	size_t soap_flag_Absence1 = 1;
	size_t soap_flag_Absence_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Environment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__EnvironmentType(soap, "om:Environment", &(a->om__SamplerType::Environment), "om:EnvironmentType"))
				{	soap_flag_Environment1--;
					continue;
				}
			if (soap_flag_Presence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__OccurrencesType(soap, "om:Presence", &(a->om__SamplerType::Presence), "om:OccurrencesType"))
				{	soap_flag_Presence1--;
					continue;
				}
			if (soap_flag_Absence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__OccurrencesType(soap, "om:Absence", &(a->om__SamplerType::Absence), "om:OccurrencesType"))
				{	soap_flag_Absence1--;
					continue;
				}
			if (soap_flag_Absence_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__OccurrencesType(soap, "om:Absence", &(a->om__SamplerType::Absence_), "om:OccurrencesType"))
				{	soap_flag_Absence_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SamplerType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SamplerType, 0, sizeof(om__SamplerType), 0, soap_copy_om__SamplerType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Environment1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__SamplerType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SamplerType);
	if (this->soap_out(soap, tag?tag:"om:SamplerType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SamplerType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SamplerType(soap, this, tag, type);
}

SOAP_FMAC3 om__SamplerType * SOAP_FMAC4 soap_get_om__SamplerType(struct soap *soap, om__SamplerType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SamplerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SamplerType * SOAP_FMAC2 soap_instantiate_om__SamplerType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SamplerType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SamplerType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SamplerType);
		if (size)
			*size = sizeof(om__SamplerType);
		((om__SamplerType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SamplerType, n);
		if (size)
			*size = n * sizeof(om__SamplerType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SamplerType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SamplerType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SamplerType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SamplerType %p -> %p\n", q, p));
	*(om__SamplerType*)p = *(om__SamplerType*)q;
}

void om__OccurrencesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__OccurrencesType::CoordinateSystem = NULL;
	soap_default_std__vectorTemplateOf_om__OccurrencesType_Point(soap, &this->om__OccurrencesType::Point);
	this->om__OccurrencesType::Count = NULL;
	this->om__OccurrencesType::Label = NULL;
	/* transient soap skipped */
}

void om__OccurrencesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->om__OccurrencesType::CoordinateSystem);
	soap_serialize_std__vectorTemplateOf_om__OccurrencesType_Point(soap, &this->om__OccurrencesType::Point);
	/* transient soap skipped */
#endif
}

int om__OccurrencesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__OccurrencesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__OccurrencesType(struct soap *soap, const char *tag, int id, const om__OccurrencesType *a, const char *type)
{
	if (((om__OccurrencesType*)a)->Count)
		soap_set_attr(soap, "Count", soap_int2s(soap, *((om__OccurrencesType*)a)->Count), 1);
	if (((om__OccurrencesType*)a)->Label)
		soap_set_attr(soap, "Label", ((om__OccurrencesType*)a)->Label->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__OccurrencesType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "om:CoordinateSystem", -1, &(a->om__OccurrencesType::CoordinateSystem), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_om__OccurrencesType_Point(soap, "om:Point", -1, &(a->om__OccurrencesType::Point), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__OccurrencesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__OccurrencesType(soap, tag, this, type);
}

SOAP_FMAC3 om__OccurrencesType * SOAP_FMAC4 soap_in_om__OccurrencesType(struct soap *soap, const char *tag, om__OccurrencesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__OccurrencesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__OccurrencesType, sizeof(om__OccurrencesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__OccurrencesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__OccurrencesType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Count", 0);
		if (t)
		{
			if (!(((om__OccurrencesType*)a)->Count = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((om__OccurrencesType*)a)->Count))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Label", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((om__OccurrencesType*)a)->Label = soap_new_std__string(soap, -1);
				((om__OccurrencesType*)a)->Label->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_CoordinateSystem1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CoordinateSystem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:CoordinateSystem", &(a->om__OccurrencesType::CoordinateSystem), "xsd:string"))
				{	soap_flag_CoordinateSystem1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_om__OccurrencesType_Point(soap, "om:Point", &(a->om__OccurrencesType::Point), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__OccurrencesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__OccurrencesType, 0, sizeof(om__OccurrencesType), 0, soap_copy_om__OccurrencesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->om__OccurrencesType::Point.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__OccurrencesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__OccurrencesType);
	if (this->soap_out(soap, tag?tag:"om:OccurrencesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__OccurrencesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__OccurrencesType(soap, this, tag, type);
}

SOAP_FMAC3 om__OccurrencesType * SOAP_FMAC4 soap_get_om__OccurrencesType(struct soap *soap, om__OccurrencesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__OccurrencesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__OccurrencesType * SOAP_FMAC2 soap_instantiate_om__OccurrencesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__OccurrencesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__OccurrencesType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__OccurrencesType);
		if (size)
			*size = sizeof(om__OccurrencesType);
		((om__OccurrencesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__OccurrencesType, n);
		if (size)
			*size = n * sizeof(om__OccurrencesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__OccurrencesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__OccurrencesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__OccurrencesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__OccurrencesType %p -> %p\n", q, p));
	*(om__OccurrencesType*)p = *(om__OccurrencesType*)q;
}

void om__EnvironmentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, &this->om__EnvironmentType::Map);
	this->om__EnvironmentType::Mask = NULL;
	this->om__EnvironmentType::NumLayers = NULL;
	/* transient soap skipped */
}

void om__EnvironmentType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, &this->om__EnvironmentType::Map);
	soap_serialize_PointerToom__BasicLayerType(soap, &this->om__EnvironmentType::Mask);
	/* transient soap skipped */
#endif
}

int om__EnvironmentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__EnvironmentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__EnvironmentType(struct soap *soap, const char *tag, int id, const om__EnvironmentType *a, const char *type)
{
	if (((om__EnvironmentType*)a)->NumLayers)
		soap_set_attr(soap, "NumLayers", soap_int2s(soap, *((om__EnvironmentType*)a)->NumLayers), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__EnvironmentType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, "om:Map", -1, &(a->om__EnvironmentType::Map), ""))
		return soap->error;
	if (a->om__EnvironmentType::Mask)
	{	if (soap_out_PointerToom__BasicLayerType(soap, "om:Mask", -1, &a->om__EnvironmentType::Mask, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Mask"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__EnvironmentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__EnvironmentType(soap, tag, this, type);
}

SOAP_FMAC3 om__EnvironmentType * SOAP_FMAC4 soap_in_om__EnvironmentType(struct soap *soap, const char *tag, om__EnvironmentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__EnvironmentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__EnvironmentType, sizeof(om__EnvironmentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__EnvironmentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__EnvironmentType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "NumLayers", 0);
		if (t)
		{
			if (!(((om__EnvironmentType*)a)->NumLayers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((om__EnvironmentType*)a)->NumLayers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Mask1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, "om:Map", &(a->om__EnvironmentType::Map), "om:ModellingLayerType"))
					continue;
			if (soap_flag_Mask1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__BasicLayerType(soap, "om:Mask", &(a->om__EnvironmentType::Mask), "om:BasicLayerType"))
				{	soap_flag_Mask1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__EnvironmentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__EnvironmentType, 0, sizeof(om__EnvironmentType), 0, soap_copy_om__EnvironmentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->om__EnvironmentType::Map.size() < 1 || soap_flag_Mask1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__EnvironmentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__EnvironmentType);
	if (this->soap_out(soap, tag?tag:"om:EnvironmentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__EnvironmentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__EnvironmentType(soap, this, tag, type);
}

SOAP_FMAC3 om__EnvironmentType * SOAP_FMAC4 soap_get_om__EnvironmentType(struct soap *soap, om__EnvironmentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__EnvironmentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__EnvironmentType * SOAP_FMAC2 soap_instantiate_om__EnvironmentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__EnvironmentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__EnvironmentType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__EnvironmentType);
		if (size)
			*size = sizeof(om__EnvironmentType);
		((om__EnvironmentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__EnvironmentType, n);
		if (size)
			*size = n * sizeof(om__EnvironmentType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__EnvironmentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__EnvironmentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__EnvironmentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__EnvironmentType %p -> %p\n", q, p));
	*(om__EnvironmentType*)p = *(om__EnvironmentType*)q;
}

void om__LayersGroupType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->om__LayersGroupType::Label);
	soap_default_std__vectorTemplateOfPointerToom__LayersGroupType(soap, &this->om__LayersGroupType::LayersGroup);
	soap_default_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, &this->om__LayersGroupType::Layer);
	soap_default_std__string(soap, &this->om__LayersGroupType::Id);
	/* transient soap skipped */
}

void om__LayersGroupType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->om__LayersGroupType::Label, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->om__LayersGroupType::Label);
	soap_serialize_std__vectorTemplateOfPointerToom__LayersGroupType(soap, &this->om__LayersGroupType::LayersGroup);
	soap_serialize_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, &this->om__LayersGroupType::Layer);
	/* transient soap skipped */
#endif
}

int om__LayersGroupType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__LayersGroupType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__LayersGroupType(struct soap *soap, const char *tag, int id, const om__LayersGroupType *a, const char *type)
{
	soap_set_attr(soap, "Id", ((om__LayersGroupType*)a)->Id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__LayersGroupType), type))
		return soap->error;
	if (soap_out_std__string(soap, "om:Label", -1, &(a->om__LayersGroupType::Label), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToom__LayersGroupType(soap, "om:LayersGroup", -1, &(a->om__LayersGroupType::LayersGroup), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, "om:Layer", -1, &(a->om__LayersGroupType::Layer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__LayersGroupType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__LayersGroupType(soap, tag, this, type);
}

SOAP_FMAC3 om__LayersGroupType * SOAP_FMAC4 soap_in_om__LayersGroupType(struct soap *soap, const char *tag, om__LayersGroupType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__LayersGroupType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__LayersGroupType, sizeof(om__LayersGroupType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__LayersGroupType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__LayersGroupType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__LayersGroupType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Label1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Label", &(a->om__LayersGroupType::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToom__LayersGroupType(soap, "om:LayersGroup", &(a->om__LayersGroupType::LayersGroup), "om:LayersGroupType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, "om:Layer", &(a->om__LayersGroupType::Layer), "om:LayerMetadataType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__LayersGroupType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__LayersGroupType, 0, sizeof(om__LayersGroupType), 0, soap_copy_om__LayersGroupType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Label1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__LayersGroupType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__LayersGroupType);
	if (this->soap_out(soap, tag?tag:"om:LayersGroupType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__LayersGroupType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__LayersGroupType(soap, this, tag, type);
}

SOAP_FMAC3 om__LayersGroupType * SOAP_FMAC4 soap_get_om__LayersGroupType(struct soap *soap, om__LayersGroupType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__LayersGroupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__LayersGroupType * SOAP_FMAC2 soap_instantiate_om__LayersGroupType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__LayersGroupType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__LayersGroupType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__LayersGroupType);
		if (size)
			*size = sizeof(om__LayersGroupType);
		((om__LayersGroupType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__LayersGroupType, n);
		if (size)
			*size = n * sizeof(om__LayersGroupType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__LayersGroupType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__LayersGroupType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__LayersGroupType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__LayersGroupType %p -> %p\n", q, p));
	*(om__LayersGroupType*)p = *(om__LayersGroupType*)q;
}

void om__LayerMetadataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__ModellingLayerType::soap_default(soap);
	this->om__BasicLayerType::soap_default(soap);
	this->om__LayerMetadataType::Label = NULL;
	this->om__LayerMetadataType::HasProjection = NULL;
}

void om__LayerMetadataType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->om__LayerMetadataType::Label);
	this->om__ModellingLayerType::soap_serialize(soap);
	this->om__BasicLayerType::soap_serialize(soap);
#endif
}

int om__LayerMetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__LayerMetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__LayerMetadataType(struct soap *soap, const char *tag, int id, const om__LayerMetadataType *a, const char *type)
{
	if (((om__LayerMetadataType*)a)->HasProjection)
		soap_set_attr(soap, "HasProjection", soap_bool2s(soap, *((om__LayerMetadataType*)a)->HasProjection), 1);
	if (((om__ModellingLayerType*)a)->IsCategorical)
		soap_set_attr(soap, "IsCategorical", soap_bool2s(soap, *((om__ModellingLayerType*)a)->IsCategorical), 1);
	if (((om__ModellingLayerType*)a)->Min)
		soap_set_attr(soap, "Min", soap_double2s(soap, *((om__ModellingLayerType*)a)->Min), 1);
	if (((om__ModellingLayerType*)a)->Max)
		soap_set_attr(soap, "Max", soap_double2s(soap, *((om__ModellingLayerType*)a)->Max), 1);
	soap_set_attr(soap, "Id", ((om__BasicLayerType*)a)->Id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__LayerMetadataType), "om:LayerMetadataType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "om:Label", -1, &(a->om__LayerMetadataType::Label), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *om__LayerMetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__LayerMetadataType(soap, tag, this, type);
}

SOAP_FMAC3 om__LayerMetadataType * SOAP_FMAC4 soap_in_om__LayerMetadataType(struct soap *soap, const char *tag, om__LayerMetadataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__LayerMetadataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__LayerMetadataType, sizeof(om__LayerMetadataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__LayerMetadataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__LayerMetadataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "HasProjection", 0);
		if (t)
		{
			if (!(((om__LayerMetadataType*)a)->HasProjection = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((om__LayerMetadataType*)a)->HasProjection))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "IsCategorical", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->IsCategorical = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((om__ModellingLayerType*)a)->IsCategorical))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Min", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->Min = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__ModellingLayerType*)a)->Min))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Max", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->Max = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__ModellingLayerType*)a)->Max))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__BasicLayerType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Label1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:Label", &(a->om__LayerMetadataType::Label), "xsd:string"))
				{	soap_flag_Label1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__LayerMetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__LayerMetadataType, 0, sizeof(om__LayerMetadataType), 0, soap_copy_om__LayerMetadataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__LayerMetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__LayerMetadataType);
	if (this->soap_out(soap, tag?tag:"om:LayerMetadataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__LayerMetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__LayerMetadataType(soap, this, tag, type);
}

SOAP_FMAC3 om__LayerMetadataType * SOAP_FMAC4 soap_get_om__LayerMetadataType(struct soap *soap, om__LayerMetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__LayerMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__LayerMetadataType * SOAP_FMAC2 soap_instantiate_om__LayerMetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__LayerMetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__LayerMetadataType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__LayerMetadataType);
		if (size)
			*size = sizeof(om__LayerMetadataType);
		((om__LayerMetadataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__LayerMetadataType, n);
		if (size)
			*size = n * sizeof(om__LayerMetadataType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__LayerMetadataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__LayerMetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__LayerMetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__LayerMetadataType %p -> %p\n", q, p));
	*(om__LayerMetadataType*)p = *(om__LayerMetadataType*)q;
}

void om__ModellingLayerType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__BasicLayerType::soap_default(soap);
	this->om__ModellingLayerType::IsCategorical = NULL;
	this->om__ModellingLayerType::Min = NULL;
	this->om__ModellingLayerType::Max = NULL;
}

void om__ModellingLayerType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->om__BasicLayerType::soap_serialize(soap);
#endif
}

int om__ModellingLayerType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__ModellingLayerType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__ModellingLayerType(struct soap *soap, const char *tag, int id, const om__ModellingLayerType *a, const char *type)
{
	if (((om__ModellingLayerType*)a)->IsCategorical)
		soap_set_attr(soap, "IsCategorical", soap_bool2s(soap, *((om__ModellingLayerType*)a)->IsCategorical), 1);
	if (((om__ModellingLayerType*)a)->Min)
		soap_set_attr(soap, "Min", soap_double2s(soap, *((om__ModellingLayerType*)a)->Min), 1);
	if (((om__ModellingLayerType*)a)->Max)
		soap_set_attr(soap, "Max", soap_double2s(soap, *((om__ModellingLayerType*)a)->Max), 1);
	soap_set_attr(soap, "Id", ((om__BasicLayerType*)a)->Id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__ModellingLayerType), "om:ModellingLayerType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__ModellingLayerType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__ModellingLayerType(soap, tag, this, type);
}

SOAP_FMAC3 om__ModellingLayerType * SOAP_FMAC4 soap_in_om__ModellingLayerType(struct soap *soap, const char *tag, om__ModellingLayerType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__ModellingLayerType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__ModellingLayerType, sizeof(om__ModellingLayerType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__ModellingLayerType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__ModellingLayerType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "IsCategorical", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->IsCategorical = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((om__ModellingLayerType*)a)->IsCategorical))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Min", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->Min = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__ModellingLayerType*)a)->Min))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Max", 0);
		if (t)
		{
			if (!(((om__ModellingLayerType*)a)->Max = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((om__ModellingLayerType*)a)->Max))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__BasicLayerType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__ModellingLayerType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__ModellingLayerType, 0, sizeof(om__ModellingLayerType), 0, soap_copy_om__ModellingLayerType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__ModellingLayerType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__ModellingLayerType);
	if (this->soap_out(soap, tag?tag:"om:ModellingLayerType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__ModellingLayerType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__ModellingLayerType(soap, this, tag, type);
}

SOAP_FMAC3 om__ModellingLayerType * SOAP_FMAC4 soap_get_om__ModellingLayerType(struct soap *soap, om__ModellingLayerType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__ModellingLayerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__ModellingLayerType * SOAP_FMAC2 soap_instantiate_om__ModellingLayerType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__ModellingLayerType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__ModellingLayerType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "om:LayerMetadataType"))
	{	cp->type = SOAP_TYPE_om_om__LayerMetadataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__LayerMetadataType);
			if (size)
				*size = sizeof(om__LayerMetadataType);
			((om__LayerMetadataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__LayerMetadataType, n);
			if (size)
				*size = n * sizeof(om__LayerMetadataType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__LayerMetadataType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__LayerMetadataType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__ModellingLayerType);
		if (size)
			*size = sizeof(om__ModellingLayerType);
		((om__ModellingLayerType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModellingLayerType, n);
		if (size)
			*size = n * sizeof(om__ModellingLayerType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__ModellingLayerType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__ModellingLayerType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__ModellingLayerType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__ModellingLayerType %p -> %p\n", q, p));
	*(om__ModellingLayerType*)p = *(om__ModellingLayerType*)q;
}

void om__BasicLayerType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->om__BasicLayerType::Id);
	/* transient soap skipped */
}

void om__BasicLayerType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int om__BasicLayerType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__BasicLayerType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__BasicLayerType(struct soap *soap, const char *tag, int id, const om__BasicLayerType *a, const char *type)
{
	soap_set_attr(soap, "Id", ((om__BasicLayerType*)a)->Id.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__BasicLayerType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__BasicLayerType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__BasicLayerType(soap, tag, this, type);
}

SOAP_FMAC3 om__BasicLayerType * SOAP_FMAC4 soap_in_om__BasicLayerType(struct soap *soap, const char *tag, om__BasicLayerType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__BasicLayerType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__BasicLayerType, sizeof(om__BasicLayerType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__BasicLayerType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__BasicLayerType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__BasicLayerType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__BasicLayerType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__BasicLayerType, 0, sizeof(om__BasicLayerType), 0, soap_copy_om__BasicLayerType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__BasicLayerType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__BasicLayerType);
	if (this->soap_out(soap, tag?tag:"om:BasicLayerType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__BasicLayerType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__BasicLayerType(soap, this, tag, type);
}

SOAP_FMAC3 om__BasicLayerType * SOAP_FMAC4 soap_get_om__BasicLayerType(struct soap *soap, om__BasicLayerType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__BasicLayerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__BasicLayerType * SOAP_FMAC2 soap_instantiate_om__BasicLayerType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__BasicLayerType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__BasicLayerType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "om:ModellingLayerType"))
	{	cp->type = SOAP_TYPE_om_om__ModellingLayerType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__ModellingLayerType);
			if (size)
				*size = sizeof(om__ModellingLayerType);
			((om__ModellingLayerType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__ModellingLayerType, n);
			if (size)
				*size = n * sizeof(om__ModellingLayerType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__ModellingLayerType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__ModellingLayerType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "om:LayerMetadataType"))
	{	cp->type = SOAP_TYPE_om_om__LayerMetadataType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(om__LayerMetadataType);
			if (size)
				*size = sizeof(om__LayerMetadataType);
			((om__LayerMetadataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__LayerMetadataType, n);
			if (size)
				*size = n * sizeof(om__LayerMetadataType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((om__LayerMetadataType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (om__LayerMetadataType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__BasicLayerType);
		if (size)
			*size = sizeof(om__BasicLayerType);
		((om__BasicLayerType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__BasicLayerType, n);
		if (size)
			*size = n * sizeof(om__BasicLayerType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__BasicLayerType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__BasicLayerType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__BasicLayerType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__BasicLayerType %p -> %p\n", q, p));
	*(om__BasicLayerType*)p = *(om__BasicLayerType*)q;
}

void om__AvailableLayersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__AvailableLayersType::LayersGroup = NULL;
	/* transient soap skipped */
}

void om__AvailableLayersType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__LayersGroupType(soap, &this->om__AvailableLayersType::LayersGroup);
	/* transient soap skipped */
#endif
}

int om__AvailableLayersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__AvailableLayersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__AvailableLayersType(struct soap *soap, const char *tag, int id, const om__AvailableLayersType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__AvailableLayersType), type))
		return soap->error;
	if (a->om__AvailableLayersType::LayersGroup)
	{	if (soap_out_PointerToom__LayersGroupType(soap, "om:LayersGroup", -1, &a->om__AvailableLayersType::LayersGroup, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:LayersGroup"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__AvailableLayersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__AvailableLayersType(soap, tag, this, type);
}

SOAP_FMAC3 om__AvailableLayersType * SOAP_FMAC4 soap_in_om__AvailableLayersType(struct soap *soap, const char *tag, om__AvailableLayersType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__AvailableLayersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__AvailableLayersType, sizeof(om__AvailableLayersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__AvailableLayersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__AvailableLayersType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LayersGroup1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LayersGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__LayersGroupType(soap, "om:LayersGroup", &(a->om__AvailableLayersType::LayersGroup), "om:LayersGroupType"))
				{	soap_flag_LayersGroup1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__AvailableLayersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__AvailableLayersType, 0, sizeof(om__AvailableLayersType), 0, soap_copy_om__AvailableLayersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LayersGroup1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__AvailableLayersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__AvailableLayersType);
	if (this->soap_out(soap, tag?tag:"om:AvailableLayersType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__AvailableLayersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__AvailableLayersType(soap, this, tag, type);
}

SOAP_FMAC3 om__AvailableLayersType * SOAP_FMAC4 soap_get_om__AvailableLayersType(struct soap *soap, om__AvailableLayersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__AvailableLayersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__AvailableLayersType * SOAP_FMAC2 soap_instantiate_om__AvailableLayersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__AvailableLayersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__AvailableLayersType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__AvailableLayersType);
		if (size)
			*size = sizeof(om__AvailableLayersType);
		((om__AvailableLayersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__AvailableLayersType, n);
		if (size)
			*size = n * sizeof(om__AvailableLayersType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__AvailableLayersType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__AvailableLayersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__AvailableLayersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__AvailableLayersType %p -> %p\n", q, p));
	*(om__AvailableLayersType*)p = *(om__AvailableLayersType*)q;
}

void om__SerializedAlgorithmType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__SerializedAlgorithmType::Parameters._om__SerializedAlgorithmType_Parameters::soap_default(soap);
	this->om__SerializedAlgorithmType::Normalization = NULL;
	this->om__SerializedAlgorithmType::Model._om__SerializedAlgorithmType_Model::soap_default(soap);
	soap_default_std__string(soap, &this->om__SerializedAlgorithmType::Id);
	soap_default_std__string(soap, &this->om__SerializedAlgorithmType::Version);
	/* transient soap skipped */
}

void om__SerializedAlgorithmType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->om__SerializedAlgorithmType::Parameters.soap_serialize(soap);
	soap_serialize_PointerToom__NormalizationType(soap, &this->om__SerializedAlgorithmType::Normalization);
	this->om__SerializedAlgorithmType::Model.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int om__SerializedAlgorithmType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__SerializedAlgorithmType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__SerializedAlgorithmType(struct soap *soap, const char *tag, int id, const om__SerializedAlgorithmType *a, const char *type)
{
	soap_set_attr(soap, "Id", ((om__SerializedAlgorithmType*)a)->Id.c_str(), 1);
	soap_set_attr(soap, "Version", ((om__SerializedAlgorithmType*)a)->Version.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__SerializedAlgorithmType), type))
		return soap->error;
	if ((a->om__SerializedAlgorithmType::Parameters).soap_out(soap, "om:Parameters", -1, ""))
		return soap->error;
	if (soap_out_PointerToom__NormalizationType(soap, "om:Normalization", -1, &(a->om__SerializedAlgorithmType::Normalization), ""))
		return soap->error;
	if ((a->om__SerializedAlgorithmType::Model).soap_out(soap, "om:Model", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__SerializedAlgorithmType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__SerializedAlgorithmType(soap, tag, this, type);
}

SOAP_FMAC3 om__SerializedAlgorithmType * SOAP_FMAC4 soap_in_om__SerializedAlgorithmType(struct soap *soap, const char *tag, om__SerializedAlgorithmType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__SerializedAlgorithmType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__SerializedAlgorithmType, sizeof(om__SerializedAlgorithmType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__SerializedAlgorithmType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__SerializedAlgorithmType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__SerializedAlgorithmType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Version", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__SerializedAlgorithmType*)a)->Version.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Parameters1 = 1;
	size_t soap_flag_Normalization1 = 1;
	size_t soap_flag_Model1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__SerializedAlgorithmType::Parameters).soap_in(soap, "om:Parameters", ""))
				{	soap_flag_Parameters1--;
					continue;
				}
			if (soap_flag_Normalization1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__NormalizationType(soap, "om:Normalization", &(a->om__SerializedAlgorithmType::Normalization), "om:NormalizationType"))
				{	soap_flag_Normalization1--;
					continue;
				}
			if (soap_flag_Model1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__SerializedAlgorithmType::Model).soap_in(soap, "om:Model", ""))
				{	soap_flag_Model1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__SerializedAlgorithmType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__SerializedAlgorithmType, 0, sizeof(om__SerializedAlgorithmType), 0, soap_copy_om__SerializedAlgorithmType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters1 > 0 || soap_flag_Model1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__SerializedAlgorithmType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__SerializedAlgorithmType);
	if (this->soap_out(soap, tag?tag:"om:SerializedAlgorithmType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__SerializedAlgorithmType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__SerializedAlgorithmType(soap, this, tag, type);
}

SOAP_FMAC3 om__SerializedAlgorithmType * SOAP_FMAC4 soap_get_om__SerializedAlgorithmType(struct soap *soap, om__SerializedAlgorithmType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__SerializedAlgorithmType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__SerializedAlgorithmType * SOAP_FMAC2 soap_instantiate_om__SerializedAlgorithmType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__SerializedAlgorithmType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__SerializedAlgorithmType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__SerializedAlgorithmType);
		if (size)
			*size = sizeof(om__SerializedAlgorithmType);
		((om__SerializedAlgorithmType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__SerializedAlgorithmType, n);
		if (size)
			*size = n * sizeof(om__SerializedAlgorithmType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__SerializedAlgorithmType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__SerializedAlgorithmType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__SerializedAlgorithmType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__SerializedAlgorithmType %p -> %p\n", q, p));
	*(om__SerializedAlgorithmType*)p = *(om__SerializedAlgorithmType*)q;
}

void om__BasicAlgorithmDefinitionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__BasicAlgorithmDefinitionType::Parameters._om__BasicAlgorithmDefinitionType_Parameters::soap_default(soap);
	soap_default_std__string(soap, &this->om__BasicAlgorithmDefinitionType::Id);
	soap_default_std__string(soap, &this->om__BasicAlgorithmDefinitionType::Version);
	/* transient soap skipped */
}

void om__BasicAlgorithmDefinitionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->om__BasicAlgorithmDefinitionType::Parameters.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int om__BasicAlgorithmDefinitionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__BasicAlgorithmDefinitionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__BasicAlgorithmDefinitionType(struct soap *soap, const char *tag, int id, const om__BasicAlgorithmDefinitionType *a, const char *type)
{
	soap_set_attr(soap, "Id", ((om__BasicAlgorithmDefinitionType*)a)->Id.c_str(), 1);
	soap_set_attr(soap, "Version", ((om__BasicAlgorithmDefinitionType*)a)->Version.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType), type))
		return soap->error;
	if ((a->om__BasicAlgorithmDefinitionType::Parameters).soap_out(soap, "om:Parameters", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__BasicAlgorithmDefinitionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__BasicAlgorithmDefinitionType(soap, tag, this, type);
}

SOAP_FMAC3 om__BasicAlgorithmDefinitionType * SOAP_FMAC4 soap_in_om__BasicAlgorithmDefinitionType(struct soap *soap, const char *tag, om__BasicAlgorithmDefinitionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__BasicAlgorithmDefinitionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType, sizeof(om__BasicAlgorithmDefinitionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__BasicAlgorithmDefinitionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__BasicAlgorithmDefinitionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__BasicAlgorithmDefinitionType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Version", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__BasicAlgorithmDefinitionType*)a)->Version.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__BasicAlgorithmDefinitionType::Parameters).soap_in(soap, "om:Parameters", ""))
				{	soap_flag_Parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__BasicAlgorithmDefinitionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType, 0, sizeof(om__BasicAlgorithmDefinitionType), 0, soap_copy_om__BasicAlgorithmDefinitionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__BasicAlgorithmDefinitionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType);
	if (this->soap_out(soap, tag?tag:"om:BasicAlgorithmDefinitionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__BasicAlgorithmDefinitionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__BasicAlgorithmDefinitionType(soap, this, tag, type);
}

SOAP_FMAC3 om__BasicAlgorithmDefinitionType * SOAP_FMAC4 soap_get_om__BasicAlgorithmDefinitionType(struct soap *soap, om__BasicAlgorithmDefinitionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__BasicAlgorithmDefinitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__BasicAlgorithmDefinitionType * SOAP_FMAC2 soap_instantiate_om__BasicAlgorithmDefinitionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__BasicAlgorithmDefinitionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__BasicAlgorithmDefinitionType);
		if (size)
			*size = sizeof(om__BasicAlgorithmDefinitionType);
		((om__BasicAlgorithmDefinitionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__BasicAlgorithmDefinitionType, n);
		if (size)
			*size = n * sizeof(om__BasicAlgorithmDefinitionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__BasicAlgorithmDefinitionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__BasicAlgorithmDefinitionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__BasicAlgorithmDefinitionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__BasicAlgorithmDefinitionType %p -> %p\n", q, p));
	*(om__BasicAlgorithmDefinitionType*)p = *(om__BasicAlgorithmDefinitionType*)q;
}

void om__AlgorithmMetadataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->om__AlgorithmMetadataType::Name);
	soap_default_std__string(soap, &this->om__AlgorithmMetadataType::Overview);
	soap_default_std__string(soap, &this->om__AlgorithmMetadataType::Description);
	this->om__AlgorithmMetadataType::Designers._om__AlgorithmMetadataType_Designers::soap_default(soap);
	this->om__AlgorithmMetadataType::Bibliography = NULL;
	this->om__AlgorithmMetadataType::Developers._om__AlgorithmMetadataType_Developers::soap_default(soap);
	soap_default_bool(soap, &this->om__AlgorithmMetadataType::AcceptsCategoricalMaps);
	soap_default_bool(soap, &this->om__AlgorithmMetadataType::RequiresAbsencePoints);
	this->om__AlgorithmMetadataType::Parameters._om__AlgorithmMetadataType_Parameters::soap_default(soap);
	soap_default_std__string(soap, &this->om__AlgorithmMetadataType::Id);
	soap_default_std__string(soap, &this->om__AlgorithmMetadataType::Version);
	/* transient soap skipped */
}

void om__AlgorithmMetadataType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->om__AlgorithmMetadataType::Name, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->om__AlgorithmMetadataType::Name);
	soap_embedded(soap, &this->om__AlgorithmMetadataType::Overview, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->om__AlgorithmMetadataType::Overview);
	soap_embedded(soap, &this->om__AlgorithmMetadataType::Description, SOAP_TYPE_om_std__string);
	soap_serialize_std__string(soap, &this->om__AlgorithmMetadataType::Description);
	this->om__AlgorithmMetadataType::Designers.soap_serialize(soap);
	soap_serialize_PointerTostd__string(soap, &this->om__AlgorithmMetadataType::Bibliography);
	this->om__AlgorithmMetadataType::Developers.soap_serialize(soap);
	soap_embedded(soap, &this->om__AlgorithmMetadataType::AcceptsCategoricalMaps, SOAP_TYPE_om_bool);
	soap_embedded(soap, &this->om__AlgorithmMetadataType::RequiresAbsencePoints, SOAP_TYPE_om_bool);
	this->om__AlgorithmMetadataType::Parameters.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int om__AlgorithmMetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__AlgorithmMetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__AlgorithmMetadataType(struct soap *soap, const char *tag, int id, const om__AlgorithmMetadataType *a, const char *type)
{
	soap_set_attr(soap, "Id", ((om__AlgorithmMetadataType*)a)->Id.c_str(), 1);
	soap_set_attr(soap, "Version", ((om__AlgorithmMetadataType*)a)->Version.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__AlgorithmMetadataType), type))
		return soap->error;
	if (soap_out_std__string(soap, "om:Name", -1, &(a->om__AlgorithmMetadataType::Name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "om:Overview", -1, &(a->om__AlgorithmMetadataType::Overview), ""))
		return soap->error;
	if (soap_out_std__string(soap, "om:Description", -1, &(a->om__AlgorithmMetadataType::Description), ""))
		return soap->error;
	if ((a->om__AlgorithmMetadataType::Designers).soap_out(soap, "om:Designers", -1, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "om:Bibliography", -1, &(a->om__AlgorithmMetadataType::Bibliography), ""))
		return soap->error;
	if ((a->om__AlgorithmMetadataType::Developers).soap_out(soap, "om:Developers", -1, ""))
		return soap->error;
	if (soap_out_bool(soap, "om:AcceptsCategoricalMaps", -1, &(a->om__AlgorithmMetadataType::AcceptsCategoricalMaps), ""))
		return soap->error;
	if (soap_out_bool(soap, "om:RequiresAbsencePoints", -1, &(a->om__AlgorithmMetadataType::RequiresAbsencePoints), ""))
		return soap->error;
	if ((a->om__AlgorithmMetadataType::Parameters).soap_out(soap, "om:Parameters", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__AlgorithmMetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__AlgorithmMetadataType(soap, tag, this, type);
}

SOAP_FMAC3 om__AlgorithmMetadataType * SOAP_FMAC4 soap_in_om__AlgorithmMetadataType(struct soap *soap, const char *tag, om__AlgorithmMetadataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__AlgorithmMetadataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__AlgorithmMetadataType, sizeof(om__AlgorithmMetadataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__AlgorithmMetadataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__AlgorithmMetadataType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__AlgorithmMetadataType*)a)->Id.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Version", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, 0, -1))
				return NULL;
			((om__AlgorithmMetadataType*)a)->Version.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Overview1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Designers1 = 1;
	size_t soap_flag_Bibliography1 = 1;
	size_t soap_flag_Developers1 = 1;
	size_t soap_flag_AcceptsCategoricalMaps1 = 1;
	size_t soap_flag_RequiresAbsencePoints1 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Name", &(a->om__AlgorithmMetadataType::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Overview1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Overview", &(a->om__AlgorithmMetadataType::Overview), "xsd:string"))
				{	soap_flag_Overview1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "om:Description", &(a->om__AlgorithmMetadataType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Designers1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__AlgorithmMetadataType::Designers).soap_in(soap, "om:Designers", ""))
				{	soap_flag_Designers1--;
					continue;
				}
			if (soap_flag_Bibliography1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "om:Bibliography", &(a->om__AlgorithmMetadataType::Bibliography), "xsd:string"))
				{	soap_flag_Bibliography1--;
					continue;
				}
			if (soap_flag_Developers1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__AlgorithmMetadataType::Developers).soap_in(soap, "om:Developers", ""))
				{	soap_flag_Developers1--;
					continue;
				}
			if (soap_flag_AcceptsCategoricalMaps1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "om:AcceptsCategoricalMaps", &(a->om__AlgorithmMetadataType::AcceptsCategoricalMaps), "xsd:boolean"))
				{	soap_flag_AcceptsCategoricalMaps1--;
					continue;
				}
			if (soap_flag_RequiresAbsencePoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "om:RequiresAbsencePoints", &(a->om__AlgorithmMetadataType::RequiresAbsencePoints), "xsd:boolean"))
				{	soap_flag_RequiresAbsencePoints1--;
					continue;
				}
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->om__AlgorithmMetadataType::Parameters).soap_in(soap, "om:Parameters", ""))
				{	soap_flag_Parameters1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__AlgorithmMetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__AlgorithmMetadataType, 0, sizeof(om__AlgorithmMetadataType), 0, soap_copy_om__AlgorithmMetadataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Overview1 > 0 || soap_flag_Description1 > 0 || soap_flag_Designers1 > 0 || soap_flag_Developers1 > 0 || soap_flag_AcceptsCategoricalMaps1 > 0 || soap_flag_RequiresAbsencePoints1 > 0 || soap_flag_Parameters1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__AlgorithmMetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__AlgorithmMetadataType);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmMetadataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__AlgorithmMetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__AlgorithmMetadataType(soap, this, tag, type);
}

SOAP_FMAC3 om__AlgorithmMetadataType * SOAP_FMAC4 soap_get_om__AlgorithmMetadataType(struct soap *soap, om__AlgorithmMetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__AlgorithmMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__AlgorithmMetadataType * SOAP_FMAC2 soap_instantiate_om__AlgorithmMetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__AlgorithmMetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__AlgorithmMetadataType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__AlgorithmMetadataType);
		if (size)
			*size = sizeof(om__AlgorithmMetadataType);
		((om__AlgorithmMetadataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__AlgorithmMetadataType, n);
		if (size)
			*size = n * sizeof(om__AlgorithmMetadataType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__AlgorithmMetadataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__AlgorithmMetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__AlgorithmMetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__AlgorithmMetadataType %p -> %p\n", q, p));
	*(om__AlgorithmMetadataType*)p = *(om__AlgorithmMetadataType*)q;
}

void om__AlgorithmsMetadataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, &this->om__AlgorithmsMetadataType::Algorithm);
	/* transient soap skipped */
}

void om__AlgorithmsMetadataType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, &this->om__AlgorithmsMetadataType::Algorithm);
	/* transient soap skipped */
#endif
}

int om__AlgorithmsMetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__AlgorithmsMetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__AlgorithmsMetadataType(struct soap *soap, const char *tag, int id, const om__AlgorithmsMetadataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__AlgorithmsMetadataType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, "om:Algorithm", -1, &(a->om__AlgorithmsMetadataType::Algorithm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__AlgorithmsMetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__AlgorithmsMetadataType(soap, tag, this, type);
}

SOAP_FMAC3 om__AlgorithmsMetadataType * SOAP_FMAC4 soap_in_om__AlgorithmsMetadataType(struct soap *soap, const char *tag, om__AlgorithmsMetadataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__AlgorithmsMetadataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__AlgorithmsMetadataType, sizeof(om__AlgorithmsMetadataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__AlgorithmsMetadataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__AlgorithmsMetadataType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, "om:Algorithm", &(a->om__AlgorithmsMetadataType::Algorithm), "om:AlgorithmMetadataType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__AlgorithmsMetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__AlgorithmsMetadataType, 0, sizeof(om__AlgorithmsMetadataType), 0, soap_copy_om__AlgorithmsMetadataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int om__AlgorithmsMetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__AlgorithmsMetadataType);
	if (this->soap_out(soap, tag?tag:"om:AlgorithmsMetadataType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__AlgorithmsMetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__AlgorithmsMetadataType(soap, this, tag, type);
}

SOAP_FMAC3 om__AlgorithmsMetadataType * SOAP_FMAC4 soap_get_om__AlgorithmsMetadataType(struct soap *soap, om__AlgorithmsMetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__AlgorithmsMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__AlgorithmsMetadataType * SOAP_FMAC2 soap_instantiate_om__AlgorithmsMetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__AlgorithmsMetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__AlgorithmsMetadataType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__AlgorithmsMetadataType);
		if (size)
			*size = sizeof(om__AlgorithmsMetadataType);
		((om__AlgorithmsMetadataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__AlgorithmsMetadataType, n);
		if (size)
			*size = n * sizeof(om__AlgorithmsMetadataType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__AlgorithmsMetadataType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__AlgorithmsMetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__AlgorithmsMetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__AlgorithmsMetadataType %p -> %p\n", q, p));
	*(om__AlgorithmsMetadataType*)p = *(om__AlgorithmsMetadataType*)q;
}

void om__AvailableAlgorithmsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->om__AvailableAlgorithmsType::Algorithms = NULL;
	/* transient soap skipped */
}

void om__AvailableAlgorithmsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToom__AlgorithmsMetadataType(soap, &this->om__AvailableAlgorithmsType::Algorithms);
	/* transient soap skipped */
#endif
}

int om__AvailableAlgorithmsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_om__AvailableAlgorithmsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_om__AvailableAlgorithmsType(struct soap *soap, const char *tag, int id, const om__AvailableAlgorithmsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_om__AvailableAlgorithmsType), type))
		return soap->error;
	if (a->om__AvailableAlgorithmsType::Algorithms)
	{	if (soap_out_PointerToom__AlgorithmsMetadataType(soap, "om:Algorithms", -1, &a->om__AvailableAlgorithmsType::Algorithms, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "om:Algorithms"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *om__AvailableAlgorithmsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_om__AvailableAlgorithmsType(soap, tag, this, type);
}

SOAP_FMAC3 om__AvailableAlgorithmsType * SOAP_FMAC4 soap_in_om__AvailableAlgorithmsType(struct soap *soap, const char *tag, om__AvailableAlgorithmsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (om__AvailableAlgorithmsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_om_om__AvailableAlgorithmsType, sizeof(om__AvailableAlgorithmsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_om_om__AvailableAlgorithmsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (om__AvailableAlgorithmsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Algorithms1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToom__AlgorithmsMetadataType(soap, "om:Algorithms", &(a->om__AvailableAlgorithmsType::Algorithms), "om:AlgorithmsMetadataType"))
				{	soap_flag_Algorithms1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (om__AvailableAlgorithmsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_om__AvailableAlgorithmsType, 0, sizeof(om__AvailableAlgorithmsType), 0, soap_copy_om__AvailableAlgorithmsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Algorithms1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int om__AvailableAlgorithmsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_om_om__AvailableAlgorithmsType);
	if (this->soap_out(soap, tag?tag:"om:AvailableAlgorithmsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *om__AvailableAlgorithmsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_om__AvailableAlgorithmsType(soap, this, tag, type);
}

SOAP_FMAC3 om__AvailableAlgorithmsType * SOAP_FMAC4 soap_get_om__AvailableAlgorithmsType(struct soap *soap, om__AvailableAlgorithmsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_om__AvailableAlgorithmsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 om__AvailableAlgorithmsType * SOAP_FMAC2 soap_instantiate_om__AvailableAlgorithmsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_om__AvailableAlgorithmsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_om__AvailableAlgorithmsType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(om__AvailableAlgorithmsType);
		if (size)
			*size = sizeof(om__AvailableAlgorithmsType);
		((om__AvailableAlgorithmsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(om__AvailableAlgorithmsType, n);
		if (size)
			*size = n * sizeof(om__AvailableAlgorithmsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((om__AvailableAlgorithmsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (om__AvailableAlgorithmsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_om__AvailableAlgorithmsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying om__AvailableAlgorithmsType %p -> %p\n", q, p));
	*(om__AvailableAlgorithmsType*)p = *(om__AvailableAlgorithmsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_om_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_om_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__IDREF(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_om_xsd__IDREF), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_om_xsd__IDREF, 0, sizeof(std::string), 0, soap_copy_xsd__IDREF);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_xsd__IDREF);
	if (soap_out_xsd__IDREF(soap, tag?tag:"xsd:IDREF", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_om_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_om_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_om_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_om_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_om_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__string, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_SOAP_ENV__Fault, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_SOAP_ENV__Reason, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_SOAP_ENV__Detail, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_SOAP_ENV__Code, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_om_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_om_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_om_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_SOAP_ENV__Header, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

}

namespace om {

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag?tag:"xsd:anyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_attribute * SOAP_FMAC2 soap_instantiate_xsd__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_xsd__anyAttribute, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute);
		if (size)
			*size = sizeof(struct soap_dom_attribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct soap_dom_attribute, n);
		if (size)
			*size = n * sizeof(struct soap_dom_attribute);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct soap_dom_attribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_attribute %p -> %p\n", q, p));
	*(struct soap_dom_attribute*)p = *(struct soap_dom_attribute*)q;
}

}

namespace om {

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_element * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_xsd__anyType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element);
		if (size)
			*size = sizeof(struct soap_dom_element);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct soap_dom_element, n);
		if (size)
			*size = n * sizeof(struct soap_dom_element);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct soap_dom_element*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_element %p -> %p\n", q, p));
	*(struct soap_dom_element*)p = *(struct soap_dom_element*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__om__union_ResultSetType_Job(struct soap *soap, int choice, const union _om__union_ResultSetType_Job *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__om__union_ResultSetType_Job_Sampler:
		soap_serialize_PointerToom__SamplerType(soap, &a->Sampler);
		break;
	case SOAP_UNION__om__union_ResultSetType_Job_ModelEnvelope:
		soap_serialize_PointerToom__ModelEnvelopeType(soap, &a->ModelEnvelope);
		break;
	case SOAP_UNION__om__union_ResultSetType_Job_TestResultEnvelope:
		soap_serialize_PointerToom__TestResultEnvelopeType(soap, &a->TestResultEnvelope);
		break;
	case SOAP_UNION__om__union_ResultSetType_Job_ProjectionEnvelope:
		soap_serialize_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, &a->ProjectionEnvelope);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__union_ResultSetType_Job(struct soap *soap, int choice, const union _om__union_ResultSetType_Job *a)
{
	switch (choice)
	{
	case SOAP_UNION__om__union_ResultSetType_Job_Sampler:
		return soap_out_PointerToom__SamplerType(soap, "om:Sampler", -1, &a->Sampler, "");
	case SOAP_UNION__om__union_ResultSetType_Job_ModelEnvelope:
		return soap_out_PointerToom__ModelEnvelopeType(soap, "om:ModelEnvelope", -1, &a->ModelEnvelope, "");
	case SOAP_UNION__om__union_ResultSetType_Job_TestResultEnvelope:
		return soap_out_PointerToom__TestResultEnvelopeType(soap, "om:TestResultEnvelope", -1, &a->TestResultEnvelope, "");
	case SOAP_UNION__om__union_ResultSetType_Job_ProjectionEnvelope:
		return soap_out_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, "om:ProjectionEnvelope", -1, &a->ProjectionEnvelope, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _om__union_ResultSetType_Job * SOAP_FMAC4 soap_in__om__union_ResultSetType_Job(struct soap *soap, int *choice, union _om__union_ResultSetType_Job *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Sampler = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__SamplerType(soap, "om:Sampler", &a->Sampler, "om:SamplerType"))
	{	*choice = SOAP_UNION__om__union_ResultSetType_Job_Sampler;
		return a;
	}
	a->ModelEnvelope = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__ModelEnvelopeType(soap, "om:ModelEnvelope", &a->ModelEnvelope, "om:ModelEnvelopeType"))
	{	*choice = SOAP_UNION__om__union_ResultSetType_Job_ModelEnvelope;
		return a;
	}
	a->TestResultEnvelope = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__TestResultEnvelopeType(soap, "om:TestResultEnvelope", &a->TestResultEnvelope, "om:TestResultEnvelopeType"))
	{	*choice = SOAP_UNION__om__union_ResultSetType_Job_TestResultEnvelope;
		return a;
	}
	a->ProjectionEnvelope = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, "om:ProjectionEnvelope", &a->ProjectionEnvelope, ""))
	{	*choice = SOAP_UNION__om__union_ResultSetType_Job_ProjectionEnvelope;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__om__union_ExperimentParametersType_Jobs(struct soap *soap, int choice, const union _om__union_ExperimentParametersType_Jobs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_SamplingJob:
		soap_serialize_PointerToom__SamplingJobType(soap, &a->SamplingJob);
		break;
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_CreateModelJob:
		soap_serialize_PointerToom__CreateModelJobType(soap, &a->CreateModelJob);
		break;
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_TestModelJob:
		soap_serialize_PointerToom__TestModelJobType(soap, &a->TestModelJob);
		break;
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_ProjectModelJob:
		soap_serialize_PointerToom__ProjectModelJobType(soap, &a->ProjectModelJob);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__union_ExperimentParametersType_Jobs(struct soap *soap, int choice, const union _om__union_ExperimentParametersType_Jobs *a)
{
	switch (choice)
	{
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_SamplingJob:
		return soap_out_PointerToom__SamplingJobType(soap, "om:SamplingJob", -1, &a->SamplingJob, "");
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_CreateModelJob:
		return soap_out_PointerToom__CreateModelJobType(soap, "om:CreateModelJob", -1, &a->CreateModelJob, "");
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_TestModelJob:
		return soap_out_PointerToom__TestModelJobType(soap, "om:TestModelJob", -1, &a->TestModelJob, "");
	case SOAP_UNION__om__union_ExperimentParametersType_Jobs_ProjectModelJob:
		return soap_out_PointerToom__ProjectModelJobType(soap, "om:ProjectModelJob", -1, &a->ProjectModelJob, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _om__union_ExperimentParametersType_Jobs * SOAP_FMAC4 soap_in__om__union_ExperimentParametersType_Jobs(struct soap *soap, int *choice, union _om__union_ExperimentParametersType_Jobs *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->SamplingJob = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__SamplingJobType(soap, "om:SamplingJob", &a->SamplingJob, "om:SamplingJobType"))
	{	*choice = SOAP_UNION__om__union_ExperimentParametersType_Jobs_SamplingJob;
		return a;
	}
	a->CreateModelJob = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__CreateModelJobType(soap, "om:CreateModelJob", &a->CreateModelJob, "om:CreateModelJobType"))
	{	*choice = SOAP_UNION__om__union_ExperimentParametersType_Jobs_CreateModelJob;
		return a;
	}
	a->TestModelJob = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__TestModelJobType(soap, "om:TestModelJob", &a->TestModelJob, "om:TestModelJobType"))
	{	*choice = SOAP_UNION__om__union_ExperimentParametersType_Jobs_TestModelJob;
		return a;
	}
	a->ProjectModelJob = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToom__ProjectModelJobType(soap, "om:ProjectModelJob", &a->ProjectModelJob, "om:ProjectModelJobType"))
	{	*choice = SOAP_UNION__om__union_ExperimentParametersType_Jobs_ProjectModelJob;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__om__union_OccurrencesFilterType(struct soap *soap, int choice, const union _om__union_OccurrencesFilterType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__om__union_OccurrencesFilterType_SpatiallyUnique:
		soap_serialize_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, &a->SpatiallyUnique);
		break;
	case SOAP_UNION__om__union_OccurrencesFilterType_EnvironmentallyUnique:
		soap_serialize_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, &a->EnvironmentallyUnique);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__om__union_OccurrencesFilterType(struct soap *soap, int choice, const union _om__union_OccurrencesFilterType *a)
{
	switch (choice)
	{
	case SOAP_UNION__om__union_OccurrencesFilterType_SpatiallyUnique:
		return soap_out_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, "om:SpatiallyUnique", -1, &a->SpatiallyUnique, "");
	case SOAP_UNION__om__union_OccurrencesFilterType_EnvironmentallyUnique:
		return soap_out_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, "om:EnvironmentallyUnique", -1, &a->EnvironmentallyUnique, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _om__union_OccurrencesFilterType * SOAP_FMAC4 soap_in__om__union_OccurrencesFilterType(struct soap *soap, int *choice, union _om__union_OccurrencesFilterType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->SpatiallyUnique = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, "om:SpatiallyUnique", &a->SpatiallyUnique, ""))
	{	*choice = SOAP_UNION__om__union_OccurrencesFilterType_SpatiallyUnique;
		return a;
	}
	a->EnvironmentallyUnique = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, "om:EnvironmentallyUnique", &a->EnvironmentallyUnique, ""))
	{	*choice = SOAP_UNION__om__union_OccurrencesFilterType_EnvironmentallyUnique;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ReferenceType(struct soap *soap, om__ReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ReferenceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ReferenceType(struct soap *soap, const char *tag, int id, om__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ReferenceType ** SOAP_FMAC4 soap_in_PointerToom__ReferenceType(struct soap *soap, const char *tag, om__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ReferenceType **)soap_malloc(soap, sizeof(om__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ReferenceType *)soap_instantiate_om__ReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ReferenceType ** p = (om__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ReferenceType, sizeof(om__ReferenceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ReferenceType(struct soap *soap, om__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ReferenceType);
	if (soap_out_PointerToom__ReferenceType(soap, tag?tag:"om:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ReferenceType ** SOAP_FMAC4 soap_get_PointerToom__ReferenceType(struct soap *soap, om__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, _om__ResultSetType_Job_ProjectionEnvelope *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, const char *tag, int id, _om__ResultSetType_Job_ProjectionEnvelope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__ResultSetType_Job_ProjectionEnvelope ** SOAP_FMAC4 soap_in_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, const char *tag, _om__ResultSetType_Job_ProjectionEnvelope **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__ResultSetType_Job_ProjectionEnvelope **)soap_malloc(soap, sizeof(_om__ResultSetType_Job_ProjectionEnvelope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__ResultSetType_Job_ProjectionEnvelope *)soap_instantiate__om__ResultSetType_Job_ProjectionEnvelope(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__ResultSetType_Job_ProjectionEnvelope ** p = (_om__ResultSetType_Job_ProjectionEnvelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__ResultSetType_Job_ProjectionEnvelope, sizeof(_om__ResultSetType_Job_ProjectionEnvelope), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, _om__ResultSetType_Job_ProjectionEnvelope *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__ResultSetType_Job_ProjectionEnvelope);
	if (soap_out_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, tag?tag:"om:ResultSetType-Job-ProjectionEnvelope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__ResultSetType_Job_ProjectionEnvelope ** SOAP_FMAC4 soap_get_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(struct soap *soap, _om__ResultSetType_Job_ProjectionEnvelope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__ResultSetType_Job_ProjectionEnvelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ProjectionEnvelopeType(struct soap *soap, om__ProjectionEnvelopeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ProjectionEnvelopeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ProjectionEnvelopeType(struct soap *soap, const char *tag, int id, om__ProjectionEnvelopeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ProjectionEnvelopeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ProjectionEnvelopeType ** SOAP_FMAC4 soap_in_PointerToom__ProjectionEnvelopeType(struct soap *soap, const char *tag, om__ProjectionEnvelopeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ProjectionEnvelopeType **)soap_malloc(soap, sizeof(om__ProjectionEnvelopeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ProjectionEnvelopeType *)soap_instantiate_om__ProjectionEnvelopeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ProjectionEnvelopeType ** p = (om__ProjectionEnvelopeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ProjectionEnvelopeType, sizeof(om__ProjectionEnvelopeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ProjectionEnvelopeType(struct soap *soap, om__ProjectionEnvelopeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ProjectionEnvelopeType);
	if (soap_out_PointerToom__ProjectionEnvelopeType(soap, tag?tag:"om:ProjectionEnvelopeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ProjectionEnvelopeType ** SOAP_FMAC4 soap_get_PointerToom__ProjectionEnvelopeType(struct soap *soap, om__ProjectionEnvelopeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ProjectionEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__TestResultEnvelopeType(struct soap *soap, om__TestResultEnvelopeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__TestResultEnvelopeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__TestResultEnvelopeType(struct soap *soap, const char *tag, int id, om__TestResultEnvelopeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__TestResultEnvelopeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__TestResultEnvelopeType ** SOAP_FMAC4 soap_in_PointerToom__TestResultEnvelopeType(struct soap *soap, const char *tag, om__TestResultEnvelopeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__TestResultEnvelopeType **)soap_malloc(soap, sizeof(om__TestResultEnvelopeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__TestResultEnvelopeType *)soap_instantiate_om__TestResultEnvelopeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__TestResultEnvelopeType ** p = (om__TestResultEnvelopeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__TestResultEnvelopeType, sizeof(om__TestResultEnvelopeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__TestResultEnvelopeType(struct soap *soap, om__TestResultEnvelopeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__TestResultEnvelopeType);
	if (soap_out_PointerToom__TestResultEnvelopeType(soap, tag?tag:"om:TestResultEnvelopeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__TestResultEnvelopeType ** SOAP_FMAC4 soap_get_PointerToom__TestResultEnvelopeType(struct soap *soap, om__TestResultEnvelopeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__TestResultEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ModelEnvelopeType(struct soap *soap, om__ModelEnvelopeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ModelEnvelopeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ModelEnvelopeType(struct soap *soap, const char *tag, int id, om__ModelEnvelopeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ModelEnvelopeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ModelEnvelopeType ** SOAP_FMAC4 soap_in_PointerToom__ModelEnvelopeType(struct soap *soap, const char *tag, om__ModelEnvelopeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ModelEnvelopeType **)soap_malloc(soap, sizeof(om__ModelEnvelopeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ModelEnvelopeType *)soap_instantiate_om__ModelEnvelopeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ModelEnvelopeType ** p = (om__ModelEnvelopeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ModelEnvelopeType, sizeof(om__ModelEnvelopeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ModelEnvelopeType(struct soap *soap, om__ModelEnvelopeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ModelEnvelopeType);
	if (soap_out_PointerToom__ModelEnvelopeType(soap, tag?tag:"om:ModelEnvelopeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ModelEnvelopeType ** SOAP_FMAC4 soap_get_PointerToom__ModelEnvelopeType(struct soap *soap, om__ModelEnvelopeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ModelEnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__om__union_ExperimentParametersType_Jobs(struct soap *soap, __om__union_ExperimentParametersType_Jobs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__om__union_ExperimentParametersType_Jobs(struct soap *soap, const char *tag, int id, __om__union_ExperimentParametersType_Jobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __om__union_ExperimentParametersType_Jobs ** SOAP_FMAC4 soap_in_PointerTo__om__union_ExperimentParametersType_Jobs(struct soap *soap, const char *tag, __om__union_ExperimentParametersType_Jobs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__om__union_ExperimentParametersType_Jobs **)soap_malloc(soap, sizeof(__om__union_ExperimentParametersType_Jobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__om__union_ExperimentParametersType_Jobs *)soap_instantiate___om__union_ExperimentParametersType_Jobs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__om__union_ExperimentParametersType_Jobs ** p = (__om__union_ExperimentParametersType_Jobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om___om__union_ExperimentParametersType_Jobs, sizeof(__om__union_ExperimentParametersType_Jobs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__om__union_ExperimentParametersType_Jobs(struct soap *soap, __om__union_ExperimentParametersType_Jobs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo__om__union_ExperimentParametersType_Jobs);
	if (soap_out_PointerTo__om__union_ExperimentParametersType_Jobs(soap, tag?tag:"-om:union-ExperimentParametersType-Jobs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __om__union_ExperimentParametersType_Jobs ** SOAP_FMAC4 soap_get_PointerTo__om__union_ExperimentParametersType_Jobs(struct soap *soap, __om__union_ExperimentParametersType_Jobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__om__union_ExperimentParametersType_Jobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ProjectModelJobType(struct soap *soap, om__ProjectModelJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ProjectModelJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ProjectModelJobType(struct soap *soap, const char *tag, int id, om__ProjectModelJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ProjectModelJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ProjectModelJobType ** SOAP_FMAC4 soap_in_PointerToom__ProjectModelJobType(struct soap *soap, const char *tag, om__ProjectModelJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ProjectModelJobType **)soap_malloc(soap, sizeof(om__ProjectModelJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ProjectModelJobType *)soap_instantiate_om__ProjectModelJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ProjectModelJobType ** p = (om__ProjectModelJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ProjectModelJobType, sizeof(om__ProjectModelJobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ProjectModelJobType(struct soap *soap, om__ProjectModelJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ProjectModelJobType);
	if (soap_out_PointerToom__ProjectModelJobType(soap, tag?tag:"om:ProjectModelJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ProjectModelJobType ** SOAP_FMAC4 soap_get_PointerToom__ProjectModelJobType(struct soap *soap, om__ProjectModelJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ProjectModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__TestModelJobType(struct soap *soap, om__TestModelJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__TestModelJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__TestModelJobType(struct soap *soap, const char *tag, int id, om__TestModelJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__TestModelJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__TestModelJobType ** SOAP_FMAC4 soap_in_PointerToom__TestModelJobType(struct soap *soap, const char *tag, om__TestModelJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__TestModelJobType **)soap_malloc(soap, sizeof(om__TestModelJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__TestModelJobType *)soap_instantiate_om__TestModelJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__TestModelJobType ** p = (om__TestModelJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__TestModelJobType, sizeof(om__TestModelJobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__TestModelJobType(struct soap *soap, om__TestModelJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__TestModelJobType);
	if (soap_out_PointerToom__TestModelJobType(soap, tag?tag:"om:TestModelJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__TestModelJobType ** SOAP_FMAC4 soap_get_PointerToom__TestModelJobType(struct soap *soap, om__TestModelJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__TestModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__CreateModelJobType(struct soap *soap, om__CreateModelJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__CreateModelJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__CreateModelJobType(struct soap *soap, const char *tag, int id, om__CreateModelJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__CreateModelJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__CreateModelJobType ** SOAP_FMAC4 soap_in_PointerToom__CreateModelJobType(struct soap *soap, const char *tag, om__CreateModelJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__CreateModelJobType **)soap_malloc(soap, sizeof(om__CreateModelJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__CreateModelJobType *)soap_instantiate_om__CreateModelJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__CreateModelJobType ** p = (om__CreateModelJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__CreateModelJobType, sizeof(om__CreateModelJobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__CreateModelJobType(struct soap *soap, om__CreateModelJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__CreateModelJobType);
	if (soap_out_PointerToom__CreateModelJobType(soap, tag?tag:"om:CreateModelJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__CreateModelJobType ** SOAP_FMAC4 soap_get_PointerToom__CreateModelJobType(struct soap *soap, om__CreateModelJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__CreateModelJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__SamplingJobType(struct soap *soap, om__SamplingJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__SamplingJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__SamplingJobType(struct soap *soap, const char *tag, int id, om__SamplingJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__SamplingJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__SamplingJobType ** SOAP_FMAC4 soap_in_PointerToom__SamplingJobType(struct soap *soap, const char *tag, om__SamplingJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__SamplingJobType **)soap_malloc(soap, sizeof(om__SamplingJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__SamplingJobType *)soap_instantiate_om__SamplingJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__SamplingJobType ** p = (om__SamplingJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__SamplingJobType, sizeof(om__SamplingJobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__SamplingJobType(struct soap *soap, om__SamplingJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__SamplingJobType);
	if (soap_out_PointerToom__SamplingJobType(soap, tag?tag:"om:SamplingJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__SamplingJobType ** SOAP_FMAC4 soap_get_PointerToom__SamplingJobType(struct soap *soap, om__SamplingJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__SamplingJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm))
		soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, int id, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_SerializedAlgorithm >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__ExperimentParametersType_SerializedAlgorithm >**)soap_malloc(soap, sizeof(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm);
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_SerializedAlgorithm >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, std::vector<_om__ExperimentParametersType_AlgorithmSettings >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings))
		soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, int id, std::vector<_om__ExperimentParametersType_AlgorithmSettings >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_AlgorithmSettings >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_AlgorithmSettings >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__ExperimentParametersType_AlgorithmSettings >**)soap_malloc(soap, sizeof(std::vector<_om__ExperimentParametersType_AlgorithmSettings >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, std::vector<_om__ExperimentParametersType_AlgorithmSettings >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings);
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_AlgorithmSettings >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, std::vector<_om__ExperimentParametersType_AlgorithmSettings >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, std::vector<_om__ExperimentParametersType_Absence >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence))
		soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, int id, std::vector<_om__ExperimentParametersType_Absence >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Absence >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Absence >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__ExperimentParametersType_Absence >**)soap_malloc(soap, sizeof(std::vector<_om__ExperimentParametersType_Absence >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, std::vector<_om__ExperimentParametersType_Absence >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence);
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Absence >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, std::vector<_om__ExperimentParametersType_Absence >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, std::vector<_om__ExperimentParametersType_Presence >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence))
		soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, int id, std::vector<_om__ExperimentParametersType_Presence >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Presence >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Presence >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__ExperimentParametersType_Presence >**)soap_malloc(soap, sizeof(std::vector<_om__ExperimentParametersType_Presence >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, std::vector<_om__ExperimentParametersType_Presence >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence);
	if (soap_out_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Presence >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, std::vector<_om__ExperimentParametersType_Presence >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__SamplingOptionsType(struct soap *soap, om__SamplingOptionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__SamplingOptionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__SamplingOptionsType(struct soap *soap, const char *tag, int id, om__SamplingOptionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__SamplingOptionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__SamplingOptionsType ** SOAP_FMAC4 soap_in_PointerToom__SamplingOptionsType(struct soap *soap, const char *tag, om__SamplingOptionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__SamplingOptionsType **)soap_malloc(soap, sizeof(om__SamplingOptionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__SamplingOptionsType *)soap_instantiate_om__SamplingOptionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__SamplingOptionsType ** p = (om__SamplingOptionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__SamplingOptionsType, sizeof(om__SamplingOptionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__SamplingOptionsType(struct soap *soap, om__SamplingOptionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__SamplingOptionsType);
	if (soap_out_PointerToom__SamplingOptionsType(soap, tag?tag:"om:SamplingOptionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__SamplingOptionsType ** SOAP_FMAC4 soap_get_PointerToom__SamplingOptionsType(struct soap *soap, om__SamplingOptionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__SamplingOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ProjectionStatisticsParametersType(struct soap *soap, om__ProjectionStatisticsParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ProjectionStatisticsParametersType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ProjectionStatisticsParametersType(struct soap *soap, const char *tag, int id, om__ProjectionStatisticsParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ProjectionStatisticsParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ProjectionStatisticsParametersType ** SOAP_FMAC4 soap_in_PointerToom__ProjectionStatisticsParametersType(struct soap *soap, const char *tag, om__ProjectionStatisticsParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ProjectionStatisticsParametersType **)soap_malloc(soap, sizeof(om__ProjectionStatisticsParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ProjectionStatisticsParametersType *)soap_instantiate_om__ProjectionStatisticsParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ProjectionStatisticsParametersType ** p = (om__ProjectionStatisticsParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ProjectionStatisticsParametersType, sizeof(om__ProjectionStatisticsParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ProjectionStatisticsParametersType(struct soap *soap, om__ProjectionStatisticsParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ProjectionStatisticsParametersType);
	if (soap_out_PointerToom__ProjectionStatisticsParametersType(soap, tag?tag:"om:ProjectionStatisticsParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ProjectionStatisticsParametersType ** SOAP_FMAC4 soap_get_PointerToom__ProjectionStatisticsParametersType(struct soap *soap, om__ProjectionStatisticsParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ProjectionStatisticsParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__MapOutputParametersType(struct soap *soap, om__MapOutputParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__MapOutputParametersType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__MapOutputParametersType(struct soap *soap, const char *tag, int id, om__MapOutputParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__MapOutputParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__MapOutputParametersType ** SOAP_FMAC4 soap_in_PointerToom__MapOutputParametersType(struct soap *soap, const char *tag, om__MapOutputParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__MapOutputParametersType **)soap_malloc(soap, sizeof(om__MapOutputParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__MapOutputParametersType *)soap_instantiate_om__MapOutputParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__MapOutputParametersType ** p = (om__MapOutputParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__MapOutputParametersType, sizeof(om__MapOutputParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__MapOutputParametersType(struct soap *soap, om__MapOutputParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__MapOutputParametersType);
	if (soap_out_PointerToom__MapOutputParametersType(soap, tag?tag:"om:MapOutputParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__MapOutputParametersType ** SOAP_FMAC4 soap_get_PointerToom__MapOutputParametersType(struct soap *soap, om__MapOutputParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__MapOutputParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__TestOptionsType(struct soap *soap, om__TestOptionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__TestOptionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__TestOptionsType(struct soap *soap, const char *tag, int id, om__TestOptionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__TestOptionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__TestOptionsType ** SOAP_FMAC4 soap_in_PointerToom__TestOptionsType(struct soap *soap, const char *tag, om__TestOptionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__TestOptionsType **)soap_malloc(soap, sizeof(om__TestOptionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__TestOptionsType *)soap_instantiate_om__TestOptionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__TestOptionsType ** p = (om__TestOptionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__TestOptionsType, sizeof(om__TestOptionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__TestOptionsType(struct soap *soap, om__TestOptionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__TestOptionsType);
	if (soap_out_PointerToom__TestOptionsType(soap, tag?tag:"om:TestOptionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__TestOptionsType ** SOAP_FMAC4 soap_get_PointerToom__TestOptionsType(struct soap *soap, om__TestOptionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__TestOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__TestResultType(struct soap *soap, om__TestResultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__TestResultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__TestResultType(struct soap *soap, const char *tag, int id, om__TestResultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__TestResultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__TestResultType ** SOAP_FMAC4 soap_in_PointerToom__TestResultType(struct soap *soap, const char *tag, om__TestResultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__TestResultType **)soap_malloc(soap, sizeof(om__TestResultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__TestResultType *)soap_instantiate_om__TestResultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__TestResultType ** p = (om__TestResultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__TestResultType, sizeof(om__TestResultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__TestResultType(struct soap *soap, om__TestResultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__TestResultType);
	if (soap_out_PointerToom__TestResultType(soap, tag?tag:"om:TestResultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__TestResultType ** SOAP_FMAC4 soap_get_PointerToom__TestResultType(struct soap *soap, om__TestResultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__TestResultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__SerializedAlgorithmType(struct soap *soap, om__SerializedAlgorithmType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__SerializedAlgorithmType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__SerializedAlgorithmType(struct soap *soap, const char *tag, int id, om__SerializedAlgorithmType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__SerializedAlgorithmType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__SerializedAlgorithmType ** SOAP_FMAC4 soap_in_PointerToom__SerializedAlgorithmType(struct soap *soap, const char *tag, om__SerializedAlgorithmType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__SerializedAlgorithmType **)soap_malloc(soap, sizeof(om__SerializedAlgorithmType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__SerializedAlgorithmType *)soap_instantiate_om__SerializedAlgorithmType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__SerializedAlgorithmType ** p = (om__SerializedAlgorithmType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__SerializedAlgorithmType, sizeof(om__SerializedAlgorithmType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__SerializedAlgorithmType(struct soap *soap, om__SerializedAlgorithmType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__SerializedAlgorithmType);
	if (soap_out_PointerToom__SerializedAlgorithmType(soap, tag?tag:"om:SerializedAlgorithmType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__SerializedAlgorithmType ** SOAP_FMAC4 soap_get_PointerToom__SerializedAlgorithmType(struct soap *soap, om__SerializedAlgorithmType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__SerializedAlgorithmType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__SerializedModelType(struct soap *soap, om__SerializedModelType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__SerializedModelType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__SerializedModelType(struct soap *soap, const char *tag, int id, om__SerializedModelType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__SerializedModelType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__SerializedModelType ** SOAP_FMAC4 soap_in_PointerToom__SerializedModelType(struct soap *soap, const char *tag, om__SerializedModelType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__SerializedModelType **)soap_malloc(soap, sizeof(om__SerializedModelType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__SerializedModelType *)soap_instantiate_om__SerializedModelType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__SerializedModelType ** p = (om__SerializedModelType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__SerializedModelType, sizeof(om__SerializedModelType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__SerializedModelType(struct soap *soap, om__SerializedModelType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__SerializedModelType);
	if (soap_out_PointerToom__SerializedModelType(soap, tag?tag:"om:SerializedModelType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__SerializedModelType ** SOAP_FMAC4 soap_get_PointerToom__SerializedModelType(struct soap *soap, om__SerializedModelType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__SerializedModelType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__OccurrencesFilterType(struct soap *soap, om__OccurrencesFilterType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__OccurrencesFilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__OccurrencesFilterType(struct soap *soap, const char *tag, int id, om__OccurrencesFilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__OccurrencesFilterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__OccurrencesFilterType ** SOAP_FMAC4 soap_in_PointerToom__OccurrencesFilterType(struct soap *soap, const char *tag, om__OccurrencesFilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__OccurrencesFilterType **)soap_malloc(soap, sizeof(om__OccurrencesFilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__OccurrencesFilterType *)soap_instantiate_om__OccurrencesFilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__OccurrencesFilterType ** p = (om__OccurrencesFilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__OccurrencesFilterType, sizeof(om__OccurrencesFilterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__OccurrencesFilterType(struct soap *soap, om__OccurrencesFilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__OccurrencesFilterType);
	if (soap_out_PointerToom__OccurrencesFilterType(soap, tag?tag:"om:OccurrencesFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__OccurrencesFilterType ** SOAP_FMAC4 soap_get_PointerToom__OccurrencesFilterType(struct soap *soap, om__OccurrencesFilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__OccurrencesFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, _om__OccurrencesFilterType_EnvironmentallyUnique *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, const char *tag, int id, _om__OccurrencesFilterType_EnvironmentallyUnique *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_EnvironmentallyUnique ** SOAP_FMAC4 soap_in_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, const char *tag, _om__OccurrencesFilterType_EnvironmentallyUnique **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__OccurrencesFilterType_EnvironmentallyUnique **)soap_malloc(soap, sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__OccurrencesFilterType_EnvironmentallyUnique *)soap_instantiate__om__OccurrencesFilterType_EnvironmentallyUnique(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__OccurrencesFilterType_EnvironmentallyUnique ** p = (_om__OccurrencesFilterType_EnvironmentallyUnique **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__OccurrencesFilterType_EnvironmentallyUnique, sizeof(_om__OccurrencesFilterType_EnvironmentallyUnique), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, _om__OccurrencesFilterType_EnvironmentallyUnique *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique);
	if (soap_out_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag?tag:"om:OccurrencesFilterType-EnvironmentallyUnique", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__OccurrencesFilterType_EnvironmentallyUnique ** SOAP_FMAC4 soap_get_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(struct soap *soap, _om__OccurrencesFilterType_EnvironmentallyUnique **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__OccurrencesFilterType_EnvironmentallyUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, _om__OccurrencesFilterType_SpatiallyUnique *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, const char *tag, int id, _om__OccurrencesFilterType_SpatiallyUnique *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__OccurrencesFilterType_SpatiallyUnique ** SOAP_FMAC4 soap_in_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, const char *tag, _om__OccurrencesFilterType_SpatiallyUnique **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__OccurrencesFilterType_SpatiallyUnique **)soap_malloc(soap, sizeof(_om__OccurrencesFilterType_SpatiallyUnique *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__OccurrencesFilterType_SpatiallyUnique *)soap_instantiate__om__OccurrencesFilterType_SpatiallyUnique(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__OccurrencesFilterType_SpatiallyUnique ** p = (_om__OccurrencesFilterType_SpatiallyUnique **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__OccurrencesFilterType_SpatiallyUnique, sizeof(_om__OccurrencesFilterType_SpatiallyUnique), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, _om__OccurrencesFilterType_SpatiallyUnique *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__OccurrencesFilterType_SpatiallyUnique);
	if (soap_out_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, tag?tag:"om:OccurrencesFilterType-SpatiallyUnique", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__OccurrencesFilterType_SpatiallyUnique ** SOAP_FMAC4 soap_get_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(struct soap *soap, _om__OccurrencesFilterType_SpatiallyUnique **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__OccurrencesFilterType_SpatiallyUnique(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ModelOptionsType(struct soap *soap, om__ModelOptionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ModelOptionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ModelOptionsType(struct soap *soap, const char *tag, int id, om__ModelOptionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ModelOptionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ModelOptionsType ** SOAP_FMAC4 soap_in_PointerToom__ModelOptionsType(struct soap *soap, const char *tag, om__ModelOptionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ModelOptionsType **)soap_malloc(soap, sizeof(om__ModelOptionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ModelOptionsType *)soap_instantiate_om__ModelOptionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ModelOptionsType ** p = (om__ModelOptionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ModelOptionsType, sizeof(om__ModelOptionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ModelOptionsType(struct soap *soap, om__ModelOptionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ModelOptionsType);
	if (soap_out_PointerToom__ModelOptionsType(soap, tag?tag:"om:ModelOptionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ModelOptionsType ** SOAP_FMAC4 soap_get_PointerToom__ModelOptionsType(struct soap *soap, om__ModelOptionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ModelOptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__BasicAlgorithmDefinitionType(struct soap *soap, om__BasicAlgorithmDefinitionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__BasicAlgorithmDefinitionType(struct soap *soap, const char *tag, int id, om__BasicAlgorithmDefinitionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__BasicAlgorithmDefinitionType ** SOAP_FMAC4 soap_in_PointerToom__BasicAlgorithmDefinitionType(struct soap *soap, const char *tag, om__BasicAlgorithmDefinitionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__BasicAlgorithmDefinitionType **)soap_malloc(soap, sizeof(om__BasicAlgorithmDefinitionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__BasicAlgorithmDefinitionType *)soap_instantiate_om__BasicAlgorithmDefinitionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__BasicAlgorithmDefinitionType ** p = (om__BasicAlgorithmDefinitionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__BasicAlgorithmDefinitionType, sizeof(om__BasicAlgorithmDefinitionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__BasicAlgorithmDefinitionType(struct soap *soap, om__BasicAlgorithmDefinitionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__BasicAlgorithmDefinitionType);
	if (soap_out_PointerToom__BasicAlgorithmDefinitionType(soap, tag?tag:"om:BasicAlgorithmDefinitionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__BasicAlgorithmDefinitionType ** SOAP_FMAC4 soap_get_PointerToom__BasicAlgorithmDefinitionType(struct soap *soap, om__BasicAlgorithmDefinitionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__BasicAlgorithmDefinitionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__SamplerType(struct soap *soap, om__SamplerType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__SamplerType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__SamplerType(struct soap *soap, const char *tag, int id, om__SamplerType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__SamplerType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__SamplerType ** SOAP_FMAC4 soap_in_PointerToom__SamplerType(struct soap *soap, const char *tag, om__SamplerType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__SamplerType **)soap_malloc(soap, sizeof(om__SamplerType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__SamplerType *)soap_instantiate_om__SamplerType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__SamplerType ** p = (om__SamplerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__SamplerType, sizeof(om__SamplerType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__SamplerType(struct soap *soap, om__SamplerType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__SamplerType);
	if (soap_out_PointerToom__SamplerType(soap, tag?tag:"om:SamplerType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__SamplerType ** SOAP_FMAC4 soap_get_PointerToom__SamplerType(struct soap *soap, om__SamplerType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__SamplerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__AreaStatisticsType(struct soap *soap, om__AreaStatisticsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__AreaStatisticsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__AreaStatisticsType(struct soap *soap, const char *tag, int id, om__AreaStatisticsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__AreaStatisticsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__AreaStatisticsType ** SOAP_FMAC4 soap_in_PointerToom__AreaStatisticsType(struct soap *soap, const char *tag, om__AreaStatisticsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__AreaStatisticsType **)soap_malloc(soap, sizeof(om__AreaStatisticsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__AreaStatisticsType *)soap_instantiate_om__AreaStatisticsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__AreaStatisticsType ** p = (om__AreaStatisticsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__AreaStatisticsType, sizeof(om__AreaStatisticsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__AreaStatisticsType(struct soap *soap, om__AreaStatisticsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__AreaStatisticsType);
	if (soap_out_PointerToom__AreaStatisticsType(soap, tag?tag:"om:AreaStatisticsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__AreaStatisticsType ** SOAP_FMAC4 soap_get_PointerToom__AreaStatisticsType(struct soap *soap, om__AreaStatisticsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__AreaStatisticsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, _om__ProjectionStatisticsParametersType_AreaStatistics *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, const char *tag, int id, _om__ProjectionStatisticsParametersType_AreaStatistics *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__ProjectionStatisticsParametersType_AreaStatistics ** SOAP_FMAC4 soap_in_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, const char *tag, _om__ProjectionStatisticsParametersType_AreaStatistics **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__ProjectionStatisticsParametersType_AreaStatistics **)soap_malloc(soap, sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__ProjectionStatisticsParametersType_AreaStatistics *)soap_instantiate__om__ProjectionStatisticsParametersType_AreaStatistics(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__ProjectionStatisticsParametersType_AreaStatistics ** p = (_om__ProjectionStatisticsParametersType_AreaStatistics **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__ProjectionStatisticsParametersType_AreaStatistics, sizeof(_om__ProjectionStatisticsParametersType_AreaStatistics), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, _om__ProjectionStatisticsParametersType_AreaStatistics *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics);
	if (soap_out_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag?tag:"om:ProjectionStatisticsParametersType-AreaStatistics", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__ProjectionStatisticsParametersType_AreaStatistics ** SOAP_FMAC4 soap_get_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(struct soap *soap, _om__ProjectionStatisticsParametersType_AreaStatistics **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__ProjectionStatisticsParametersType_AreaStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__TestResultType_RocCurve(struct soap *soap, _om__TestResultType_RocCurve *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__TestResultType_RocCurve))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__TestResultType_RocCurve(struct soap *soap, const char *tag, int id, _om__TestResultType_RocCurve *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__TestResultType_RocCurve);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve ** SOAP_FMAC4 soap_in_PointerTo_om__TestResultType_RocCurve(struct soap *soap, const char *tag, _om__TestResultType_RocCurve **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__TestResultType_RocCurve **)soap_malloc(soap, sizeof(_om__TestResultType_RocCurve *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__TestResultType_RocCurve *)soap_instantiate__om__TestResultType_RocCurve(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__TestResultType_RocCurve ** p = (_om__TestResultType_RocCurve **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__TestResultType_RocCurve, sizeof(_om__TestResultType_RocCurve), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__TestResultType_RocCurve(struct soap *soap, _om__TestResultType_RocCurve *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve);
	if (soap_out_PointerTo_om__TestResultType_RocCurve(soap, tag?tag:"om:TestResultType-RocCurve", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__TestResultType_RocCurve ** SOAP_FMAC4 soap_get_PointerTo_om__TestResultType_RocCurve(struct soap *soap, _om__TestResultType_RocCurve **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__TestResultType_RocCurve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__TestResultType_RocCurve_Ratio(struct soap *soap, _om__TestResultType_RocCurve_Ratio *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__TestResultType_RocCurve_Ratio(struct soap *soap, const char *tag, int id, _om__TestResultType_RocCurve_Ratio *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__TestResultType_RocCurve_Ratio ** SOAP_FMAC4 soap_in_PointerTo_om__TestResultType_RocCurve_Ratio(struct soap *soap, const char *tag, _om__TestResultType_RocCurve_Ratio **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__TestResultType_RocCurve_Ratio **)soap_malloc(soap, sizeof(_om__TestResultType_RocCurve_Ratio *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__TestResultType_RocCurve_Ratio *)soap_instantiate__om__TestResultType_RocCurve_Ratio(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__TestResultType_RocCurve_Ratio ** p = (_om__TestResultType_RocCurve_Ratio **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__TestResultType_RocCurve_Ratio, sizeof(_om__TestResultType_RocCurve_Ratio), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__TestResultType_RocCurve_Ratio(struct soap *soap, _om__TestResultType_RocCurve_Ratio *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__TestResultType_RocCurve_Ratio);
	if (soap_out_PointerTo_om__TestResultType_RocCurve_Ratio(soap, tag?tag:"om:TestResultType-RocCurve-Ratio", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__TestResultType_RocCurve_Ratio ** SOAP_FMAC4 soap_get_PointerTo_om__TestResultType_RocCurve_Ratio(struct soap *soap, _om__TestResultType_RocCurve_Ratio **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__TestResultType_RocCurve_Ratio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__TestResultType_ConfusionMatrix(struct soap *soap, _om__TestResultType_ConfusionMatrix *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__TestResultType_ConfusionMatrix(struct soap *soap, const char *tag, int id, _om__TestResultType_ConfusionMatrix *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__TestResultType_ConfusionMatrix ** SOAP_FMAC4 soap_in_PointerTo_om__TestResultType_ConfusionMatrix(struct soap *soap, const char *tag, _om__TestResultType_ConfusionMatrix **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__TestResultType_ConfusionMatrix **)soap_malloc(soap, sizeof(_om__TestResultType_ConfusionMatrix *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__TestResultType_ConfusionMatrix *)soap_instantiate__om__TestResultType_ConfusionMatrix(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__TestResultType_ConfusionMatrix ** p = (_om__TestResultType_ConfusionMatrix **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__TestResultType_ConfusionMatrix, sizeof(_om__TestResultType_ConfusionMatrix), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__TestResultType_ConfusionMatrix(struct soap *soap, _om__TestResultType_ConfusionMatrix *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__TestResultType_ConfusionMatrix);
	if (soap_out_PointerTo_om__TestResultType_ConfusionMatrix(soap, tag?tag:"om:TestResultType-ConfusionMatrix", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__TestResultType_ConfusionMatrix ** SOAP_FMAC4 soap_get_PointerTo_om__TestResultType_ConfusionMatrix(struct soap *soap, _om__TestResultType_ConfusionMatrix **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__TestResultType_ConfusionMatrix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__TestOptionsType_RocCurve(struct soap *soap, _om__TestOptionsType_RocCurve *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__TestOptionsType_RocCurve))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__TestOptionsType_RocCurve(struct soap *soap, const char *tag, int id, _om__TestOptionsType_RocCurve *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__TestOptionsType_RocCurve);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__TestOptionsType_RocCurve ** SOAP_FMAC4 soap_in_PointerTo_om__TestOptionsType_RocCurve(struct soap *soap, const char *tag, _om__TestOptionsType_RocCurve **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__TestOptionsType_RocCurve **)soap_malloc(soap, sizeof(_om__TestOptionsType_RocCurve *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__TestOptionsType_RocCurve *)soap_instantiate__om__TestOptionsType_RocCurve(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__TestOptionsType_RocCurve ** p = (_om__TestOptionsType_RocCurve **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__TestOptionsType_RocCurve, sizeof(_om__TestOptionsType_RocCurve), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__TestOptionsType_RocCurve(struct soap *soap, _om__TestOptionsType_RocCurve *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__TestOptionsType_RocCurve);
	if (soap_out_PointerTo_om__TestOptionsType_RocCurve(soap, tag?tag:"om:TestOptionsType-RocCurve", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__TestOptionsType_RocCurve ** SOAP_FMAC4 soap_get_PointerTo_om__TestOptionsType_RocCurve(struct soap *soap, _om__TestOptionsType_RocCurve **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__TestOptionsType_RocCurve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ZeroOneIntervalType(struct soap *soap, double *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om_om__ZeroOneIntervalType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ZeroOneIntervalType(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ZeroOneIntervalType);
	if (id < 0)
		return soap->error;
	return soap_out_om__ZeroOneIntervalType(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerToom__ZeroOneIntervalType(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_om__ZeroOneIntervalType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ZeroOneIntervalType, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ZeroOneIntervalType(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ZeroOneIntervalType);
	if (soap_out_PointerToom__ZeroOneIntervalType(soap, tag?tag:"om:ZeroOneIntervalType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerToom__ZeroOneIntervalType(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ZeroOneIntervalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__TestOptionsType_ConfusionMatrix(struct soap *soap, _om__TestOptionsType_ConfusionMatrix *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__TestOptionsType_ConfusionMatrix(struct soap *soap, const char *tag, int id, _om__TestOptionsType_ConfusionMatrix *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__TestOptionsType_ConfusionMatrix ** SOAP_FMAC4 soap_in_PointerTo_om__TestOptionsType_ConfusionMatrix(struct soap *soap, const char *tag, _om__TestOptionsType_ConfusionMatrix **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__TestOptionsType_ConfusionMatrix **)soap_malloc(soap, sizeof(_om__TestOptionsType_ConfusionMatrix *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__TestOptionsType_ConfusionMatrix *)soap_instantiate__om__TestOptionsType_ConfusionMatrix(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__TestOptionsType_ConfusionMatrix ** p = (_om__TestOptionsType_ConfusionMatrix **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__TestOptionsType_ConfusionMatrix, sizeof(_om__TestOptionsType_ConfusionMatrix), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__TestOptionsType_ConfusionMatrix(struct soap *soap, _om__TestOptionsType_ConfusionMatrix *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__TestOptionsType_ConfusionMatrix);
	if (soap_out_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, tag?tag:"om:TestOptionsType-ConfusionMatrix", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__TestOptionsType_ConfusionMatrix ** SOAP_FMAC4 soap_get_PointerTo_om__TestOptionsType_ConfusionMatrix(struct soap *soap, _om__TestOptionsType_ConfusionMatrix **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__TestOptionsType_ConfusionMatrix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ThresholdParameterType(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ThresholdParameterType))
		soap_serialize_om__ThresholdParameterType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ThresholdParameterType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ThresholdParameterType);
	if (id < 0)
		return soap->error;
	return soap_out_om__ThresholdParameterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToom__ThresholdParameterType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_om__ThresholdParameterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ThresholdParameterType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ThresholdParameterType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ThresholdParameterType);
	if (soap_out_PointerToom__ThresholdParameterType(soap, tag?tag:"om:ThresholdParameterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToom__ThresholdParameterType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ThresholdParameterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__OccurrencesType(struct soap *soap, om__OccurrencesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__OccurrencesType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__OccurrencesType(struct soap *soap, const char *tag, int id, om__OccurrencesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__OccurrencesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__OccurrencesType ** SOAP_FMAC4 soap_in_PointerToom__OccurrencesType(struct soap *soap, const char *tag, om__OccurrencesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__OccurrencesType **)soap_malloc(soap, sizeof(om__OccurrencesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__OccurrencesType *)soap_instantiate_om__OccurrencesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__OccurrencesType ** p = (om__OccurrencesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__OccurrencesType, sizeof(om__OccurrencesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__OccurrencesType(struct soap *soap, om__OccurrencesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__OccurrencesType);
	if (soap_out_PointerToom__OccurrencesType(soap, tag?tag:"om:OccurrencesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__OccurrencesType ** SOAP_FMAC4 soap_get_PointerToom__OccurrencesType(struct soap *soap, om__OccurrencesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__OccurrencesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__EnvironmentType(struct soap *soap, om__EnvironmentType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__EnvironmentType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__EnvironmentType(struct soap *soap, const char *tag, int id, om__EnvironmentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__EnvironmentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__EnvironmentType ** SOAP_FMAC4 soap_in_PointerToom__EnvironmentType(struct soap *soap, const char *tag, om__EnvironmentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__EnvironmentType **)soap_malloc(soap, sizeof(om__EnvironmentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__EnvironmentType *)soap_instantiate_om__EnvironmentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__EnvironmentType ** p = (om__EnvironmentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__EnvironmentType, sizeof(om__EnvironmentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__EnvironmentType(struct soap *soap, om__EnvironmentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__EnvironmentType);
	if (soap_out_PointerToom__EnvironmentType(soap, tag?tag:"om:EnvironmentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__EnvironmentType ** SOAP_FMAC4 soap_get_PointerToom__EnvironmentType(struct soap *soap, om__EnvironmentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__EnvironmentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__BasicLayerType(struct soap *soap, om__BasicLayerType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__BasicLayerType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__BasicLayerType(struct soap *soap, const char *tag, int id, om__BasicLayerType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__BasicLayerType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__BasicLayerType ** SOAP_FMAC4 soap_in_PointerToom__BasicLayerType(struct soap *soap, const char *tag, om__BasicLayerType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__BasicLayerType **)soap_malloc(soap, sizeof(om__BasicLayerType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__BasicLayerType *)soap_instantiate_om__BasicLayerType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__BasicLayerType ** p = (om__BasicLayerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__BasicLayerType, sizeof(om__BasicLayerType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (om__BasicLayerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ModellingLayerType, sizeof(om__ModellingLayerType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (om__BasicLayerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__LayerMetadataType, sizeof(om__LayerMetadataType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__BasicLayerType(struct soap *soap, om__BasicLayerType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__BasicLayerType);
	if (soap_out_PointerToom__BasicLayerType(soap, tag?tag:"om:BasicLayerType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__BasicLayerType ** SOAP_FMAC4 soap_get_PointerToom__BasicLayerType(struct soap *soap, om__BasicLayerType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__BasicLayerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__ModellingLayerType(struct soap *soap, om__ModellingLayerType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__ModellingLayerType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__ModellingLayerType(struct soap *soap, const char *tag, int id, om__ModellingLayerType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__ModellingLayerType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__ModellingLayerType ** SOAP_FMAC4 soap_in_PointerToom__ModellingLayerType(struct soap *soap, const char *tag, om__ModellingLayerType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__ModellingLayerType **)soap_malloc(soap, sizeof(om__ModellingLayerType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__ModellingLayerType *)soap_instantiate_om__ModellingLayerType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__ModellingLayerType ** p = (om__ModellingLayerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__ModellingLayerType, sizeof(om__ModellingLayerType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (om__ModellingLayerType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__LayerMetadataType, sizeof(om__LayerMetadataType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__ModellingLayerType(struct soap *soap, om__ModellingLayerType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__ModellingLayerType);
	if (soap_out_PointerToom__ModellingLayerType(soap, tag?tag:"om:ModellingLayerType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__ModellingLayerType ** SOAP_FMAC4 soap_get_PointerToom__ModellingLayerType(struct soap *soap, om__ModellingLayerType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__ModellingLayerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__LayerMetadataType(struct soap *soap, om__LayerMetadataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__LayerMetadataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__LayerMetadataType(struct soap *soap, const char *tag, int id, om__LayerMetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__LayerMetadataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__LayerMetadataType ** SOAP_FMAC4 soap_in_PointerToom__LayerMetadataType(struct soap *soap, const char *tag, om__LayerMetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__LayerMetadataType **)soap_malloc(soap, sizeof(om__LayerMetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__LayerMetadataType *)soap_instantiate_om__LayerMetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__LayerMetadataType ** p = (om__LayerMetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__LayerMetadataType, sizeof(om__LayerMetadataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__LayerMetadataType(struct soap *soap, om__LayerMetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__LayerMetadataType);
	if (soap_out_PointerToom__LayerMetadataType(soap, tag?tag:"om:LayerMetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__LayerMetadataType ** SOAP_FMAC4 soap_get_PointerToom__LayerMetadataType(struct soap *soap, om__LayerMetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__LayerMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__LayersGroupType(struct soap *soap, om__LayersGroupType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__LayersGroupType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__LayersGroupType(struct soap *soap, const char *tag, int id, om__LayersGroupType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__LayersGroupType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__LayersGroupType ** SOAP_FMAC4 soap_in_PointerToom__LayersGroupType(struct soap *soap, const char *tag, om__LayersGroupType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__LayersGroupType **)soap_malloc(soap, sizeof(om__LayersGroupType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__LayersGroupType *)soap_instantiate_om__LayersGroupType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__LayersGroupType ** p = (om__LayersGroupType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__LayersGroupType, sizeof(om__LayersGroupType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__LayersGroupType(struct soap *soap, om__LayersGroupType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__LayersGroupType);
	if (soap_out_PointerToom__LayersGroupType(soap, tag?tag:"om:LayersGroupType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__LayersGroupType ** SOAP_FMAC4 soap_get_PointerToom__LayersGroupType(struct soap *soap, om__LayersGroupType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__LayersGroupType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__NormalizationType(struct soap *soap, om__NormalizationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__NormalizationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__NormalizationType(struct soap *soap, const char *tag, int id, om__NormalizationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__NormalizationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__NormalizationType ** SOAP_FMAC4 soap_in_PointerToom__NormalizationType(struct soap *soap, const char *tag, om__NormalizationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__NormalizationType **)soap_malloc(soap, sizeof(om__NormalizationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__NormalizationType *)soap_instantiate_om__NormalizationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__NormalizationType ** p = (om__NormalizationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__NormalizationType, sizeof(om__NormalizationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__NormalizationType(struct soap *soap, om__NormalizationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__NormalizationType);
	if (soap_out_PointerToom__NormalizationType(soap, tag?tag:"om:NormalizationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__NormalizationType ** SOAP_FMAC4 soap_get_PointerToom__NormalizationType(struct soap *soap, om__NormalizationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__NormalizationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter))
		soap_serialize_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, int id, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >**)soap_malloc(soap, sizeof(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter);
	if (soap_out_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter))
		soap_serialize_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, int id, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >**)soap_malloc(soap, sizeof(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter);
	if (soap_out_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter))
		soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, int id, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >**)soap_malloc(soap, sizeof(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter);
	if (soap_out_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, const char *tag, int id, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues ** SOAP_FMAC4 soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues **)soap_malloc(soap, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *)soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues ** p = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues);
	if (soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag?tag:"om:AlgorithmMetadataType-Parameters-Parameter-AcceptedValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues ** SOAP_FMAC4 soap_get_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, const char *tag, int id, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange ** SOAP_FMAC4 soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, const char *tag, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange **)soap_malloc(soap, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *)soap_instantiate__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange ** p = (_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange);
	if (soap_out_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag?tag:"om:AlgorithmMetadataType-Parameters-Parameter-AcceptedRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange ** SOAP_FMAC4 soap_get_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(struct soap *soap, _om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_om__AlgorithmMetadataType_Parameters_Parameter_AcceptedRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__AlgorithmMetadataType(struct soap *soap, om__AlgorithmMetadataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__AlgorithmMetadataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__AlgorithmMetadataType(struct soap *soap, const char *tag, int id, om__AlgorithmMetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__AlgorithmMetadataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__AlgorithmMetadataType ** SOAP_FMAC4 soap_in_PointerToom__AlgorithmMetadataType(struct soap *soap, const char *tag, om__AlgorithmMetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__AlgorithmMetadataType **)soap_malloc(soap, sizeof(om__AlgorithmMetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__AlgorithmMetadataType *)soap_instantiate_om__AlgorithmMetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__AlgorithmMetadataType ** p = (om__AlgorithmMetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__AlgorithmMetadataType, sizeof(om__AlgorithmMetadataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__AlgorithmMetadataType(struct soap *soap, om__AlgorithmMetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__AlgorithmMetadataType);
	if (soap_out_PointerToom__AlgorithmMetadataType(soap, tag?tag:"om:AlgorithmMetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__AlgorithmMetadataType ** SOAP_FMAC4 soap_get_PointerToom__AlgorithmMetadataType(struct soap *soap, om__AlgorithmMetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__AlgorithmMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToom__AlgorithmsMetadataType(struct soap *soap, om__AlgorithmsMetadataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_om_om__AlgorithmsMetadataType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToom__AlgorithmsMetadataType(struct soap *soap, const char *tag, int id, om__AlgorithmsMetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_om_om__AlgorithmsMetadataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 om__AlgorithmsMetadataType ** SOAP_FMAC4 soap_in_PointerToom__AlgorithmsMetadataType(struct soap *soap, const char *tag, om__AlgorithmsMetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (om__AlgorithmsMetadataType **)soap_malloc(soap, sizeof(om__AlgorithmsMetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (om__AlgorithmsMetadataType *)soap_instantiate_om__AlgorithmsMetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	om__AlgorithmsMetadataType ** p = (om__AlgorithmsMetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_om_om__AlgorithmsMetadataType, sizeof(om__AlgorithmsMetadataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToom__AlgorithmsMetadataType(struct soap *soap, om__AlgorithmsMetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_PointerToom__AlgorithmsMetadataType);
	if (soap_out_PointerToom__AlgorithmsMetadataType(soap, tag?tag:"om:AlgorithmsMetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 om__AlgorithmsMetadataType ** SOAP_FMAC4 soap_get_PointerToom__AlgorithmsMetadataType(struct soap *soap, om__AlgorithmsMetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToom__AlgorithmsMetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_om__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_om__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_om_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_om_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_om_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_om_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, std::vector<_om__ResultSetType_Job >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, const std::vector<_om__ResultSetType_Job >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ResultSetType_Job >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, const char *tag, int id, const std::vector<_om__ResultSetType_Job >*a, const char *type)
{
	for (std::vector<_om__ResultSetType_Job >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ResultSetType_Job >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, const char *tag, std::vector<_om__ResultSetType_Job >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ResultSetType_Job n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ResultSetType_Job, SOAP_TYPE_om_std__vectorTemplateOf_om__ResultSetType_Job, sizeof(_om__ResultSetType_Job), 0))
				break;
			if (!soap_in__om__ResultSetType_Job(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ResultSetType_Job(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ResultSetType_Job(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ResultSetType_Job > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ResultSetType_Job(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ResultSetType_Job, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ResultSetType_Job >);
		if (size)
			*size = sizeof(std::vector<_om__ResultSetType_Job >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ResultSetType_Job >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ResultSetType_Job >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ResultSetType_Job >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ResultSetType_Job(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ResultSetType_Job > %p -> %p\n", q, p));
	*(std::vector<_om__ResultSetType_Job >*)p = *(std::vector<_om__ResultSetType_Job >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, std::vector<_om__JobTicketsType_Job >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, const std::vector<_om__JobTicketsType_Job >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__JobTicketsType_Job >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, const char *tag, int id, const std::vector<_om__JobTicketsType_Job >*a, const char *type)
{
	for (std::vector<_om__JobTicketsType_Job >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__JobTicketsType_Job >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, const char *tag, std::vector<_om__JobTicketsType_Job >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__JobTicketsType_Job n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__JobTicketsType_Job, SOAP_TYPE_om_std__vectorTemplateOf_om__JobTicketsType_Job, sizeof(_om__JobTicketsType_Job), 0))
				break;
			if (!soap_in__om__JobTicketsType_Job(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__JobTicketsType_Job(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__JobTicketsType_Job(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__JobTicketsType_Job > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__JobTicketsType_Job(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__JobTicketsType_Job, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__JobTicketsType_Job >);
		if (size)
			*size = sizeof(std::vector<_om__JobTicketsType_Job >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__JobTicketsType_Job >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__JobTicketsType_Job >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__JobTicketsType_Job >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__JobTicketsType_Job(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__JobTicketsType_Job > %p -> %p\n", q, p));
	*(std::vector<_om__JobTicketsType_Job >*)p = *(std::vector<_om__JobTicketsType_Job >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_SerializedAlgorithm >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_SerializedAlgorithm >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_SerializedAlgorithm >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_SerializedAlgorithm n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_SerializedAlgorithm, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm, sizeof(_om__ExperimentParametersType_SerializedAlgorithm), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_SerializedAlgorithm(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_SerializedAlgorithm(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_SerializedAlgorithm > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_SerializedAlgorithm(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_SerializedAlgorithm > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)p = *(std::vector<_om__ExperimentParametersType_SerializedAlgorithm >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, std::vector<_om__ExperimentParametersType_AlgorithmSettings >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const std::vector<_om__ExperimentParametersType_AlgorithmSettings >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_AlgorithmSettings >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_AlgorithmSettings >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_AlgorithmSettings >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_AlgorithmSettings >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_AlgorithmSettings >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_AlgorithmSettings n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_AlgorithmSettings, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings, sizeof(_om__ExperimentParametersType_AlgorithmSettings), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_AlgorithmSettings(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_AlgorithmSettings(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_AlgorithmSettings > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_AlgorithmSettings >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_AlgorithmSettings >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_AlgorithmSettings >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_AlgorithmSettings >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_AlgorithmSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_AlgorithmSettings > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)p = *(std::vector<_om__ExperimentParametersType_AlgorithmSettings >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, std::vector<_om__ExperimentParametersType_Absence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, const std::vector<_om__ExperimentParametersType_Absence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_Absence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_Absence >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_Absence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Absence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Absence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_Absence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_Absence, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence, sizeof(_om__ExperimentParametersType_Absence), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_Absence(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_Absence(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_Absence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_Absence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_Absence >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_Absence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_Absence >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_Absence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_Absence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_Absence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_Absence > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_Absence >*)p = *(std::vector<_om__ExperimentParametersType_Absence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, std::vector<_om__ExperimentParametersType_Absence_Point >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, const std::vector<_om__ExperimentParametersType_Absence_Point >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_Absence_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_Absence_Point >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_Absence_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Absence_Point >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Absence_Point >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_Absence_Point n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_Absence_Point, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point, sizeof(_om__ExperimentParametersType_Absence_Point), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_Absence_Point(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_Absence_Point(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_Absence_Point > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_Absence_Point >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_Absence_Point >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_Absence_Point >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_Absence_Point >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_Absence_Point >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_Absence_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_Absence_Point > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_Absence_Point >*)p = *(std::vector<_om__ExperimentParametersType_Absence_Point >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, std::vector<_om__ExperimentParametersType_Presence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, const std::vector<_om__ExperimentParametersType_Presence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_Presence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_Presence >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_Presence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Presence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Presence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_Presence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_Presence, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence, sizeof(_om__ExperimentParametersType_Presence), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_Presence(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_Presence(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_Presence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_Presence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_Presence >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_Presence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_Presence >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_Presence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_Presence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_Presence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_Presence > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_Presence >*)p = *(std::vector<_om__ExperimentParametersType_Presence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, std::vector<_om__ExperimentParametersType_Presence_Point >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, const std::vector<_om__ExperimentParametersType_Presence_Point >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_Presence_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_Presence_Point >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_Presence_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Presence_Point >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Presence_Point >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_Presence_Point n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_Presence_Point, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point, sizeof(_om__ExperimentParametersType_Presence_Point), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_Presence_Point(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_Presence_Point(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_Presence_Point > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_Presence_Point >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_Presence_Point >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_Presence_Point >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_Presence_Point >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_Presence_Point >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_Presence_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_Presence_Point > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_Presence_Point >*)p = *(std::vector<_om__ExperimentParametersType_Presence_Point >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, std::vector<_om__ExperimentParametersType_Environment >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, const std::vector<_om__ExperimentParametersType_Environment >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__ExperimentParametersType_Environment >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, const char *tag, int id, const std::vector<_om__ExperimentParametersType_Environment >*a, const char *type)
{
	for (std::vector<_om__ExperimentParametersType_Environment >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__ExperimentParametersType_Environment >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, const char *tag, std::vector<_om__ExperimentParametersType_Environment >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__ExperimentParametersType_Environment n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__ExperimentParametersType_Environment, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Environment, sizeof(_om__ExperimentParametersType_Environment), 0))
				break;
			if (!soap_in__om__ExperimentParametersType_Environment(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__ExperimentParametersType_Environment(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__ExperimentParametersType_Environment(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__ExperimentParametersType_Environment > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__ExperimentParametersType_Environment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__ExperimentParametersType_Environment, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__ExperimentParametersType_Environment >);
		if (size)
			*size = sizeof(std::vector<_om__ExperimentParametersType_Environment >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__ExperimentParametersType_Environment >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__ExperimentParametersType_Environment >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__ExperimentParametersType_Environment >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__ExperimentParametersType_Environment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__ExperimentParametersType_Environment > %p -> %p\n", q, p));
	*(std::vector<_om__ExperimentParametersType_Environment >*)p = *(std::vector<_om__ExperimentParametersType_Environment >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, std::vector<_om__OccurrencesType_Point >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, const std::vector<_om__OccurrencesType_Point >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__OccurrencesType_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, const char *tag, int id, const std::vector<_om__OccurrencesType_Point >*a, const char *type)
{
	for (std::vector<_om__OccurrencesType_Point >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__OccurrencesType_Point >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, const char *tag, std::vector<_om__OccurrencesType_Point >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__OccurrencesType_Point n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__OccurrencesType_Point, SOAP_TYPE_om_std__vectorTemplateOf_om__OccurrencesType_Point, sizeof(_om__OccurrencesType_Point), 0))
				break;
			if (!soap_in__om__OccurrencesType_Point(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__OccurrencesType_Point(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__OccurrencesType_Point(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__OccurrencesType_Point > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__OccurrencesType_Point(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__OccurrencesType_Point, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__OccurrencesType_Point >);
		if (size)
			*size = sizeof(std::vector<_om__OccurrencesType_Point >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__OccurrencesType_Point >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__OccurrencesType_Point >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__OccurrencesType_Point >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__OccurrencesType_Point(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__OccurrencesType_Point > %p -> %p\n", q, p));
	*(std::vector<_om__OccurrencesType_Point >*)p = *(std::vector<_om__OccurrencesType_Point >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, std::vector<om__ModellingLayerType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, const std::vector<om__ModellingLayerType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<om__ModellingLayerType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToom__ModellingLayerType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, const char *tag, int id, const std::vector<om__ModellingLayerType * >*a, const char *type)
{
	for (std::vector<om__ModellingLayerType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToom__ModellingLayerType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<om__ModellingLayerType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, const char *tag, std::vector<om__ModellingLayerType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	om__ModellingLayerType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om_om__ModellingLayerType, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__ModellingLayerType, sizeof(om__ModellingLayerType), 1))
				break;
			if (!soap_in_PointerToom__ModellingLayerType(soap, tag, NULL, "om:ModellingLayerType"))
				break;
		}
		else if (!soap_in_PointerToom__ModellingLayerType(soap, tag, &n, "om:ModellingLayerType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToom__ModellingLayerType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<om__ModellingLayerType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToom__ModellingLayerType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__ModellingLayerType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<om__ModellingLayerType * >);
		if (size)
			*size = sizeof(std::vector<om__ModellingLayerType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<om__ModellingLayerType * >, n);
		if (size)
			*size = n * sizeof(std::vector<om__ModellingLayerType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<om__ModellingLayerType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToom__ModellingLayerType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<om__ModellingLayerType * > %p -> %p\n", q, p));
	*(std::vector<om__ModellingLayerType * >*)p = *(std::vector<om__ModellingLayerType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, std::vector<om__LayerMetadataType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, const std::vector<om__LayerMetadataType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<om__LayerMetadataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToom__LayerMetadataType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, const char *tag, int id, const std::vector<om__LayerMetadataType * >*a, const char *type)
{
	for (std::vector<om__LayerMetadataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToom__LayerMetadataType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<om__LayerMetadataType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, const char *tag, std::vector<om__LayerMetadataType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	om__LayerMetadataType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om_om__LayerMetadataType, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayerMetadataType, sizeof(om__LayerMetadataType), 1))
				break;
			if (!soap_in_PointerToom__LayerMetadataType(soap, tag, NULL, "om:LayerMetadataType"))
				break;
		}
		else if (!soap_in_PointerToom__LayerMetadataType(soap, tag, &n, "om:LayerMetadataType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToom__LayerMetadataType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<om__LayerMetadataType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToom__LayerMetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayerMetadataType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<om__LayerMetadataType * >);
		if (size)
			*size = sizeof(std::vector<om__LayerMetadataType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<om__LayerMetadataType * >, n);
		if (size)
			*size = n * sizeof(std::vector<om__LayerMetadataType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<om__LayerMetadataType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToom__LayerMetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<om__LayerMetadataType * > %p -> %p\n", q, p));
	*(std::vector<om__LayerMetadataType * >*)p = *(std::vector<om__LayerMetadataType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, std::vector<om__LayersGroupType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, const std::vector<om__LayersGroupType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<om__LayersGroupType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToom__LayersGroupType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, const char *tag, int id, const std::vector<om__LayersGroupType * >*a, const char *type)
{
	for (std::vector<om__LayersGroupType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToom__LayersGroupType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<om__LayersGroupType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, const char *tag, std::vector<om__LayersGroupType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	om__LayersGroupType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om_om__LayersGroupType, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayersGroupType, sizeof(om__LayersGroupType), 1))
				break;
			if (!soap_in_PointerToom__LayersGroupType(soap, tag, NULL, "om:LayersGroupType"))
				break;
		}
		else if (!soap_in_PointerToom__LayersGroupType(soap, tag, &n, "om:LayersGroupType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToom__LayersGroupType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<om__LayersGroupType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToom__LayersGroupType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__LayersGroupType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<om__LayersGroupType * >);
		if (size)
			*size = sizeof(std::vector<om__LayersGroupType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<om__LayersGroupType * >, n);
		if (size)
			*size = n * sizeof(std::vector<om__LayersGroupType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<om__LayersGroupType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToom__LayersGroupType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<om__LayersGroupType * > %p -> %p\n", q, p));
	*(std::vector<om__LayersGroupType * >*)p = *(std::vector<om__LayersGroupType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*a, const char *type)
{
	for (std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__SerializedAlgorithmType_Parameters_Parameter n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__SerializedAlgorithmType_Parameters_Parameter, SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter, sizeof(_om__SerializedAlgorithmType_Parameters_Parameter), 0))
				break;
			if (!soap_in__om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__SerializedAlgorithmType_Parameters_Parameter(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__SerializedAlgorithmType_Parameters_Parameter > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >);
		if (size)
			*size = sizeof(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__SerializedAlgorithmType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__SerializedAlgorithmType_Parameters_Parameter > %p -> %p\n", q, p));
	*(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)p = *(std::vector<_om__SerializedAlgorithmType_Parameters_Parameter >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*a, const char *type)
{
	for (std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__BasicAlgorithmDefinitionType_Parameters_Parameter n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__BasicAlgorithmDefinitionType_Parameters_Parameter, SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter, sizeof(_om__BasicAlgorithmDefinitionType_Parameters_Parameter), 0))
				break;
			if (!soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >);
		if (size)
			*size = sizeof(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__BasicAlgorithmDefinitionType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter > %p -> %p\n", q, p));
	*(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)p = *(std::vector<_om__BasicAlgorithmDefinitionType_Parameters_Parameter >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, int id, const std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*a, const char *type)
{
	for (std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, const char *tag, std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__AlgorithmMetadataType_Parameters_Parameter n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__AlgorithmMetadataType_Parameters_Parameter, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter, sizeof(_om__AlgorithmMetadataType_Parameters_Parameter), 0))
				break;
			if (!soap_in__om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__AlgorithmMetadataType_Parameters_Parameter(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__AlgorithmMetadataType_Parameters_Parameter > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >);
		if (size)
			*size = sizeof(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__AlgorithmMetadataType_Parameters_Parameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__AlgorithmMetadataType_Parameters_Parameter > %p -> %p\n", q, p));
	*(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)p = *(std::vector<_om__AlgorithmMetadataType_Parameters_Parameter >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__string(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om_std__string, SOAP_TYPE_om_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOfstd__string, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Developers_Developer >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, const std::vector<_om__AlgorithmMetadataType_Developers_Developer >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__AlgorithmMetadataType_Developers_Developer >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, const char *tag, int id, const std::vector<_om__AlgorithmMetadataType_Developers_Developer >*a, const char *type)
{
	for (std::vector<_om__AlgorithmMetadataType_Developers_Developer >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__AlgorithmMetadataType_Developers_Developer >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, const char *tag, std::vector<_om__AlgorithmMetadataType_Developers_Developer >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__AlgorithmMetadataType_Developers_Developer n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__AlgorithmMetadataType_Developers_Developer, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer, sizeof(_om__AlgorithmMetadataType_Developers_Developer), 0))
				break;
			if (!soap_in__om__AlgorithmMetadataType_Developers_Developer(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__AlgorithmMetadataType_Developers_Developer(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__AlgorithmMetadataType_Developers_Developer > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__AlgorithmMetadataType_Developers_Developer >);
		if (size)
			*size = sizeof(std::vector<_om__AlgorithmMetadataType_Developers_Developer >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__AlgorithmMetadataType_Developers_Developer >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__AlgorithmMetadataType_Developers_Developer >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__AlgorithmMetadataType_Developers_Developer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__AlgorithmMetadataType_Developers_Developer > %p -> %p\n", q, p));
	*(std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)p = *(std::vector<_om__AlgorithmMetadataType_Developers_Developer >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, std::vector<_om__AlgorithmMetadataType_Designers_Designer >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, const std::vector<_om__AlgorithmMetadataType_Designers_Designer >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_om__AlgorithmMetadataType_Designers_Designer >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, const char *tag, int id, const std::vector<_om__AlgorithmMetadataType_Designers_Designer >*a, const char *type)
{
	for (std::vector<_om__AlgorithmMetadataType_Designers_Designer >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_om__AlgorithmMetadataType_Designers_Designer >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, const char *tag, std::vector<_om__AlgorithmMetadataType_Designers_Designer >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_om__AlgorithmMetadataType_Designers_Designer n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om__om__AlgorithmMetadataType_Designers_Designer, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer, sizeof(_om__AlgorithmMetadataType_Designers_Designer), 0))
				break;
			if (!soap_in__om__AlgorithmMetadataType_Designers_Designer(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__om__AlgorithmMetadataType_Designers_Designer(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_om__AlgorithmMetadataType_Designers_Designer > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_om__AlgorithmMetadataType_Designers_Designer >);
		if (size)
			*size = sizeof(std::vector<_om__AlgorithmMetadataType_Designers_Designer >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_om__AlgorithmMetadataType_Designers_Designer >, n);
		if (size)
			*size = n * sizeof(std::vector<_om__AlgorithmMetadataType_Designers_Designer >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_om__AlgorithmMetadataType_Designers_Designer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_om__AlgorithmMetadataType_Designers_Designer > %p -> %p\n", q, p));
	*(std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)p = *(std::vector<_om__AlgorithmMetadataType_Designers_Designer >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, std::vector<om__AlgorithmMetadataType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, const std::vector<om__AlgorithmMetadataType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<om__AlgorithmMetadataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToom__AlgorithmMetadataType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, const char *tag, int id, const std::vector<om__AlgorithmMetadataType * >*a, const char *type)
{
	for (std::vector<om__AlgorithmMetadataType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToom__AlgorithmMetadataType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<om__AlgorithmMetadataType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, const char *tag, std::vector<om__AlgorithmMetadataType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	om__AlgorithmMetadataType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_om_om__AlgorithmMetadataType, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__AlgorithmMetadataType, sizeof(om__AlgorithmMetadataType), 1))
				break;
			if (!soap_in_PointerToom__AlgorithmMetadataType(soap, tag, NULL, "om:AlgorithmMetadataType"))
				break;
		}
		else if (!soap_in_PointerToom__AlgorithmMetadataType(soap, tag, &n, "om:AlgorithmMetadataType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<om__AlgorithmMetadataType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_om_std__vectorTemplateOfPointerToom__AlgorithmMetadataType, n, om_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<om__AlgorithmMetadataType * >);
		if (size)
			*size = sizeof(std::vector<om__AlgorithmMetadataType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<om__AlgorithmMetadataType * >, n);
		if (size)
			*size = n * sizeof(std::vector<om__AlgorithmMetadataType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<om__AlgorithmMetadataType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToom__AlgorithmMetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<om__AlgorithmMetadataType * > %p -> %p\n", q, p));
	*(std::vector<om__AlgorithmMetadataType * >*)p = *(std::vector<om__AlgorithmMetadataType * >*)q;
}

} // namespace om


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of omC.cpp */
